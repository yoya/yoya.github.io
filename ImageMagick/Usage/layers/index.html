<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Layering -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/layers/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Multi-Image Layers</h1>
        <div>
          <dl>
            <dt><b>Index</b></dt>
            <dt>
              <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
            </dt>
            <dd>
              <a href="#intro"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Layers Introduction</a>
            </dd>
            <dd>
              <a href="#append"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Appending Images</a> (-append)
              <ul>
                <li>
                  <a href="#append_array">Append an Array of Images</a>
                </li>
                <li>
                  <a href="#append_overlap">Append with Overlap</a>
                </li>
                <li>
                  <a href="#smush">Smushing Append</a> (-smush)
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#composition"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Composition of Multiple Pairs of Images</a>
              <ul>
                <li>
                  <a href="#composite">Using Composite Command</a> (composite, -geometry)
                </li>
                <li>
                  <a href="#convert">Composite Operator of Convert</a> (-composite, -geometry)
                </li>
                <li>
                  <a href="#draw">Draw Multiple Images</a> (-draw 'image ..')
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#layers"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Layering Multiple Images</a>
              <ul>
                <li>
                  <a href="#flatten">Flatten - onto a Background Image</a>
                </li>
                <li>
                  <a href="#mosaic">Mosaics - Canvas Expanding</a>
                </li>
                <li>
                  <a href="#merge">Merging - to Create a New Layer Image</a>
                </li>
                <li>
                  <a href="#coalesce">Coalesce Composition - a Progressive Layering</a>
                </li>
                <li>
                  <a href="#compose">Compose Methods and Layering</a>
                </li>
                <li>
                  <a href="#layer_composite">Layers Composite - Merge Two Image Lists</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#layer_examples"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Layering Image Examples</a>
              <ul>
                <li>
                  <a href="#layer_thumbnails">Layering Thumbnails</a>
                </li>
                <li>
                  <a href="#layer_calc">Calculated Positioning of Images</a>
                </li>
                <li>
                  <a href="#layer_prog">Two Stage Positioning of Images</a>
                </li>
                <li>
                  <a href="#layer_pins">Pins in a Map</a>
                </li>
                <li>
                  <a href="#layer_shadow">Layers of Shadows</a>
                </li>
                <li>
                  <a href="#layer_distort">Distorted Image Placement using Layers</a>
                </li>
              </ul>
            </dd>
            <dd><br></dd>
            <dd>
              <a href="#evaluate-sequence"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Evaluate Sequence Multi-Image Merging</a>
              <dl>
                <dd>
                  <a href="#eval-seq_mean">Mean (average)</a>,&nbsp; <a href="#eval-seq_max">Min/Max Value</a>,&nbsp; <a href="#eval-seq_median">Median Pixel</a>, &nbsp; <a href="#eval-seq_add">Add</a>,&nbsp; <a href="#eval-seq_multiply">Multiply</a>
                </dd>
              </dl>
            </dd>
            <dd>
              <a href="#poly"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Poly - Merge Mutli-images Using a Polynomial</a>
            </dd>
          </dl>Overlaying multiple images onto each other to generate a larger 'composite' is generally known as using image 'layering'. These examples involve the combining of multiple 'layers' of images to produce the final larger more complex image.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="intro" id="intro"></a>
          <h2>Layering Images Introduction</h2>As we have previously noted, ImageMagick does not deal with just one image, but a sequence or list of images. This allows you to use IM in two very special image processing techniques. You can for example think of each image in the list as a single frame in time, so that the whole list can be regarded as being a <i>Animation</i>. This will be explored in other IM Example Pages. See <a href="../anim_basics/">Animation Basics</a>. Alternatively, you can think of each image in the sequence as <i>Layers</i> of a set of see-through overhead transparencies. That is, each image represents a small part of the final image. For example: the first (lowest) layer can represent a background image. Above that you can have a fuzzy see though shadow. Then the next layer image contains the object that casts that shadow. On top of this a layer with some text that is written over that object. That is, you can have a sequence of images or 'layers' that each adds one more piece to a much more complex image. Each image layer can be moved, edited, or modified completely separately from any other layer, and even saved into a multi-image file (such as TIFF:, MIFF: or XCF:) or as separate images, for future processing. And that is the point of image layering. Only when all the image layers have been created do you <a href="#flatten">Flatten</a>, <a href="#mosaic">Mosaic</a>, or <a href="#merge">Merge</a> all the <a href="#example">Layered Images</a> into a single final image.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="append" id="append"></a>
          <h2>Appending Images</h2>Appending is probably the simplest, of the multi-image operations provided to handle multiple images. Basically it joins the current sequence of images in memory into a column, or a row, without gaps. The "<code><a href="../option_link.cgi?append">-append</a></code>" option appends vertically, while the plus form "<code><a href="../option_link.cgi?append">+append</a></code>" appends horizontally. For example, here we append a set of letter images together, side-by-side, to form a fancy word, in a similar way that individual 'glyphs' or letters of a 'font', are joined together.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick font_A.gif font_P.gif font_P.gif font_E.gif font_N.gif \
          font_D.gif font_E.gif font_D.gif +append  append_row.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="append_row.gif"><img src="append_row.gif" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The above is similar (in a very basic way) to how fonts are handled. Unlike real fonts you are not limited to just two colors, but can generate some very fancy colorful alphabets from individual character images. Many of these 'image fonts' are available on the WWW for download. A very small set can be found in <a href="http://www.ict.griffith.edu.au/anthony/icons/">Anthony's Icon Library</a>, in <a href="http://www.ict.griffith.edu.au/anthony/icons/prog/fonts/Icons.html">Fonts for Text and Counters</a>, which is also where I found the above <a href="http://www.ict.griffith.edu.au/anthony/icons/prog/fonts/bubble_blue.xpm">Blue Bubble Font</a>. Note also how the "<code><a href="../option_link.cgi?append">+append</a></code>" operator was done as the last operation, after all the images that you want to append have been added to the current image sequence. This is great for appending a label to an image, for example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white  -append append_label.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_label.jpg"><img src="append_label.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that the "<code><a href="../option_link.cgi?background">-background</a></code>" color was used to fill in any space that was not filled in. Of course if the all the images are the same width, no space will be left for this fill. From IM v6.4.7-1 the "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" setting can be used to specify how the images should be added together. As such in a vertical append, a setting of '<code>Center</code>' will center the image relative to the final resulting image (so will a setting of either '<code>North</code>' or '<code>South</code>').
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white -gravity center -append \
          append_center.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_center.jpg"><img src="append_center.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Naturally any '<code>East</code>' gravity setting will align the images on the right side.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white -gravity east -append \
          append_east.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_east.jpg"><img src="append_east.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Similar vertical alignment can be achieved when using "<code><a href="../option_link.cgi?append">+append</a></code>"
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%">
                <font size="-1"><i>Before IM v6.4.7 it was much more difficult to align appended images, and generally involved using a "<code><a href="../option_link.cgi?flop">-flop</a></code>" for right alignment. Or using "<code><a href="../option_link.cgi?extent">-extent</a></code>" or "<code><a href="../option_link.cgi?border">-border</a></code>" to adjust the image width for centered aligned appends.<br>
                <br>
                For example, this will work with an older 6.3.2 version of IM...</i></font>
                <table border="0" cellspacing="0" cellpadding="0" width="100%">
                  <tr>
                    <td width="100%" align="justify">
                      <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                        <tr>
                          <td>
                            <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background SkyBlue label:Rose \
          -background White -gravity center -extent 200x \
          -append -trim +repage   append_center_old.jpg
</samp></pre>
                          </td>
                        </tr>
                      </table>
                    </td>
                    <td>
                      <a href="append_center_old.jpg"><img src="append_center_old.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>You can also use multiple append operations, in the same command without conflict or confusion as to the outcome of the operations (which was not the case before IM v6).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <!-- <CODE EXECUTE>
  magick $HOME/icons/dragons/dragon_long.xpm  dragon_long.gif
</CODE> -->
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick font_{0,0,6,1,2}.gif +append  dragon_long.gif \
          -background none   -append   append_multi.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_multi.gif"><img src="append_multi.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>We appended each row of images together, then appende a larger image below that. This is very simple, and straight-forward. By using <a href="../basics/#parenthesis">parenthesis</a>, you can append just the numbers after the larger image. For example, here append all the numbers together, before appending them vertically to the dragon image we read in before the numbers.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick dragon_long.gif  '(' font_{0,0,6,2,9}.gif +append ')' \
          -background none   -append   append_parenthesis.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_parenthesis.gif"><img src="append_parenthesis.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The parenthesis in the above must be either quoted, or escaped with a backslashed ('<code>\</code>') when used with an UNIX shell, otherwise they will be interpreted by the shell as something completely different.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As only two images were involved we could have just used "<code><a href="../option_link.cgi?swap">+swap</a></code>" or "<code><a href="../option_link.cgi?reverse">-reverse</a></code>" instead of using parenthesis.</i></font></td>
            </tr>
          </table><a name="append_array" id="append_array"></a>
          <h2>Append an Array of Images</h2><a name="append_array" id="append_array"></a> You can take this further to make a whole array of images, and build them either by rows, or by columns.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( font_1.gif font_2.gif font_3.gif +append \) \
          \( font_4.gif font_5.gif font_6.gif +append \) \
          \( font_7.gif font_8.gif font_9.gif +append \) \
          \( -size 32x32 xc:none  font_0.gif +append \) \
          -background none -append   append_array.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_array.gif"><img src="append_array.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Technically the first set of parenthesis is not needed, as no images have been read in yet, but it makes the whole thing look uniform and shows the intent of the command, in making an array of images. See also <a href="../montage/#concatenate">Montage Concatenation Mode</a>, for an alternative way of creating arrays of equal sized images.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?append">-append</a></code>" operator will only append the actual images, and does not make use the virtual canvas (image page) size, or the image offset. However the virtual canvas information seems to be left in a funny state with the canvas sizes being added together and the offset set to some undefined value.<br>
              <br>
              This may be regarded as a bug, and means either the input images or result should have the virtual canvas reset using "<code><a href="../option_link.cgi?repage">+repage</a></code>", before saving, or using the image in operations where this information can become important.<br>
              <br>
              This situation will probably be fixed in some future expansion of the operation. Caution is thus advised, especially if re-appending <a href="../crop/#crop_tile">Tile Cropped</a> images.</i></font></td>
            </tr>
          </table><a name="append_overlap" id="append_overlap"></a>
          <h2>Append with Overlap</h2>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                On the IM Forum an user asked for a simple way to <a href="../forum_link.cgi?t=30720">Append images with some overlap</a>. Many solutions were offered. This was one of the simplest solutions, with the amount of overlap given in a single location.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick granite: rose: -gravity east -background none \
          \( -clone 1 -chop 30x0 \) \( -clone 0,2 +append \) \
          -delete 0,2 +swap -composite append_overlap.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="append_overlap.gif"><img src="append_overlap.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above did not need to any image positioning calculations, typically involving image sizes, that would represent a more general solution. See <a href="#layer_examples">Handling Image Layers</a> below. What this did was chop off the part that overlapped, before appending the result to the first image, producing the final image size. The original image is then composed (with gravity) on top to generate the actual overlap. It can be easily modified for vertical overlapping, or even right to left overlapping relatively easily. <a name="smush" id="smush"></a>
          <h2>Smushing Append</h2>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                Another way of appending images is by smushing. The "<code><a href="../option_link.cgi?smush">-smush</a></code>" operator works much like the <a href="#addend">Append Operator</a> (see above) does, but it takes an argument of how much space (or anti-space) you want between the images. For example, lets use it to so the previous example more simply.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick granite: rose: -background none -gravity Center \
          +smush -20 smush_overlap.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="smush_overlap.png"><img src="smush_overlap.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>That works very well, though that is not what the operator is actually designed for, and it is probably a lot slower. What smush actually is ment to do is move 'shaped images' as close togther as posible. For example, here I generate the letters '<code>A</code>' and '<code>V</code>' and 'smush' them together with as little space between them as posible.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -background none -pointsize 72 \
          -fill red label:A -fill blue label:V \
          +smush 0 smush_append.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="smush_append.png"><img src="smush_append.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Notice that how the two letters were appended together far closer than append would, taking advantage of the empty space of the images 'shape'. The gap in the above is caused by anti-aliasing edge pixels of the two letters. That is, what "<code><a href="../option_link.cgi?smush">-smush</a></code>" is designed to do, though it requires a lot of calculations, so is a lot slower than <a href="#addend">Append</a> (see above). The argument, is an offset for that final position, and is usually a positive value to generate a gap, but can be negative to create an overlap.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -background none -pointsize 72 \
          -fill red label:A -fill blue label:V \
          +smush -15 smush_offset.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="smush_offset.png"><img src="smush_offset.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Images may become clipped in undocumented ways if a very large negative value is used.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="composition" id="composition"></a>
          <h2>Composition of Multiple Pairs of Images</h2>Composition is the low-level operation that is used to merge two individual images together. Almost all layering techniques eventually devolve down to merging images together two at a time, until only one image is left. So lets start by looking at ways of doing low-level composition of image pairs. <a name="composite" id="composite"></a>
          <h3>Using the Composite Command</h3>The traditional method of combining two images together using ImageMagick is though the "<code>magick composite</code>" command. This command can only combine only two images at a time, saving the results of each operation into a file. This of course does not stop you from using it to layer multiple images, one image at a time...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" nowarn="">
  magick -size 100x100 xc:skyblue composite.gif
  magick composite -geometry  +5+10 balloon.gif composite.gif composite.gif
  magick composite -geometry +35+30 medical.gif composite.gif composite.gif
  magick composite -geometry +62+50 present.gif composite.gif composite.gif
  magick composite -geometry +10+55 shading.gif composite.gif composite.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="composite.gif"><img src="composite.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As all input images are read in by ImageMagick BEFORE the output image is opened, you can output to one of the input images. This allows you to work on the same image over and over, as shown above, without problems.<br>
              <br>
              Do not do this with a lossy image format like "JPEG" as the format errors are accumulative, and the base image will quickly degrade.</i></font></td>
            </tr>
          </table>You can also resize the overlaid image as well as position it using the "<code><a href="../option_link.cgi?geometry">-geometry</a></code>" setting.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" nowarn="">
  magick -size 100x100 xc:skyblue comp_resize.gif
  magick composite -geometry 40x40+5+10  balloon.gif comp_resize.gif comp_resize.gif
  magick composite -geometry      +35+30 medical.gif comp_resize.gif comp_resize.gif
  magick composite -geometry 24x24+62+50 present.gif comp_resize.gif comp_resize.gif
  magick composite -geometry 16x16+10+55 shading.gif comp_resize.gif comp_resize.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="comp_resize.gif"><img src="comp_resize.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The "<code>magick composite</code>" command also has a few other advantages in that you can use to control the way the image is drawn onto the background with the "<code><a href="../option_link.cgi?compose">-compose</a></code>" option and its relative position is effected by the "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" setting. You can also "<code><a href="../option_link.cgi?tile">-tile</a></code>" the overlay so that it will just cover the background image, without needing to specify tile limits. This is something only available when using "<code>magick composite</code>". The big disadvantage with this method is that you are using multiple commands, and IM has to write-out the working image, either to a pipeline, or to disk, for the next command to read-in again. To find more examples of using the "<code>magick composite</code>" command, to overlay images on top of other images, see "<a href="../annotating/#overlay">Annotating by Overlaying Images</a>" and "<a href="../annotating/#image_gravity">Image Positioning using Gravity</a>". <a name="magick" id="magick"></a>
          <h3>Composite Operator of Convert</h3>The "<code><a href="../option_link.cgi?composite">-composite</a></code>" operator is available within the "<code>magick</code>" command. For more details see <a href="../compose/#composite">Image Composition in IM</a>. This allows you to do the same as the above, but all in one command.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          balloon.gif  -geometry  +5+10  -composite \
          medical.gif  -geometry +35+30  -composite \
          present.gif  -geometry +62+50  -composite \
          shading.gif  -geometry +10+55  -composite \
          compose.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="compose.gif"><img src="compose.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This first creates a <a href="../canvas/#solid">Canvas Image</a> which is "<code>skyblue</code>" in color, and then layers each of the later images onto that canvas at the given locations. Now the "<code><a href="../option_link.cgi?geometry">-geometry</a></code>" is is a very special operator that not only sets an overlay position for the next "<code><a href="../option_link.cgi?composite">-composite</a></code>" operation, it will also "<code><a href="../option_link.cgi?resize">-resize</a></code>" the <i>last</i> image (and only the last image) in the current image sequence.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          balloon.gif  -geometry 40x40+5+10   -composite \
          medical.gif  -geometry      +35+30  -composite \
          present.gif  -geometry 24x24+62+50  -composite \
          shading.gif  -geometry 16x16+10+55  -composite \
          compose_geometry.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="compose_geometry.gif"><img src="compose_geometry.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note it is recommended that you avoid this 'resize' side-effect of of the "<code><a href="../option_link.cgi?geometry">-geometry</a></code>", even if it is convenient. Basically as it is more of a backward compatibility effect and may in some situations generate other effects. Here is the more verbose recommendation...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          \( balloon.gif -resize 40x40 \) -geometry +5+10   -composite \
          \( medical.gif               \) -geometry +35+30  -composite \
          \( present.gif -resize 24x24 \) -geometry +62+50  -composite \
          \( shading.gif -resize 16x16 \) -geometry +10+55  -composite \
          compose_resize.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="compose_resize.gif"><img src="compose_resize.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="draw" id="draw"></a>
          <h3>Draw Multiple Images</h3>Also using "<code>magick</code>" you can also use <a href="../draw/#primitive">Draw Primitives</a> to overlay images onto its working canvas.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -draw "image over  5,10 0,0 'balloon.gif'" \
          -draw "image over 35,30 0,0 'medical.gif'" \
          -draw "image over 62,50 0,0 'present.gif'" \
          -draw "image over 10,55 0,0 'shading.gif'" \
          drawn.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="drawn.gif"><img src="drawn.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can of course also specify a resize for the overlaid image too..
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -draw "image over  5,10 40,40 'balloon.gif'" \
          -draw "image over 35,30  0,0  'medical.gif'" \
          -draw "image over 62,50 24,24 'present.gif'" \
          -draw "image over 10,55 16,16 'shading.gif'" \
          drawn_resize.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="drawn_resize.gif"><img src="drawn_resize.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The 'drawn' images can also be <a href="../draw/#transform">Rotated, Scaled, and Affine Distorted</a> during the overlay process. Though that can be tricky to get working the way you want. Drawn images are "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" effected, just like text.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="layers" id="layers"></a>
          <h2>Layering Multiple Images</h2>True layering of images requires methods to combine multiple images together, without needing to individually compose each pair of images separately. This is where the various <code><a href="../option_link.cgi?layers">-layers</a></code> operator methods come into their own. Ordering of layered images can be important, so it is a good idea to understand the special <a href="../basics/#image_seq">Image Sequence or List Operators</a>. Note that 'layered images' is practically identical to the handling 'animated frames'. As such it is recommended you also look at both <a href="../anim_basics/">Animation Basics</a> and <a href="../anim_mods/">Animation Modifications</a> for techniques involving processing individual 'layers' or 'frames'. Actually animations often use the same <code><a href="../option_link.cgi?layers">-layers</a></code> operator for processing images. <a name="flatten" id="flatten"></a>
          <h3>Flatten - onto a Background Image</h3>The "<code><a href="../option_link.cgi?layers">-layers</a> <b>flatten</b></code>" image list operator, (or its shortcut "<code><a href="../option_link.cgi?flatten">-flatten</a></code>") will basically "<a href="../compose/">Compose</a>" each of the given images on to a background to form one single image. However the image positions are specified using their current <a href="../basics/#page">Virtual Canvas, or Page</a> offset. For example, here I create a nice canvas, and specify each of the images I want to overlay onto that canvas.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -fill dodgerblue -draw 'circle 50,50 15,25' \
          \( -page +5+10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -layers flatten  flatten_canvas.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_canvas.gif"><img src="flatten_canvas.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As of IM v6.3.6-2 the "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" operator is only an alias for a "<code><a href="../option_link.cgi?layers">-layers</a> 'flatten'</code>" method.<br>
              <br>
              Thus the "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" option can be regarded as a short cut for the "<code><a href="../option_link.cgi?layers">-layers</a></code>" method of the same name.</i></font></td>
            </tr>
          </table>You don't need to create an initial canvas as we did above, you can instead let "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" create one for you. The canvas color will be the current "<code><a href="../option_link.cgi?background">-background</a></code>" color, while its size is defined by the first images <a href="../basics/#page">Virtual Canvas</a> size.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page 100x100+5+10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( --page +62+50        present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -layers flatten  flatten_page.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_page.gif"><img src="flatten_page.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>While the "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" setting will effect image placement defined using "<code><a href="../option_link.cgi?geometry">-geometry</a></code>" settings, it will not effect image positioning using <a href="../basics/#page">virtual canvas offsets</a> set via the "<code><a href="../option_link.cgi?page">-page</a></code>" setting. This is part of the definition of such offsets. See <a href="../compose/#geometry">Geometry vs Page Offsets</a> for more details.<br>
              <br>
              If placement with "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" is need look at either the above multi-image composition methods, or the special <a href="../anim_mods/#composite">Layers Composition</a> method that can handle both positioning methods simultaneously.</i></font></td>
            </tr>
          </table>If any image does not appear in the defined virtual canvas area, it will either be clipped or ignored, as appropriate. For example, here we used a smaller canvas size, causing the later images not to appear completely on that canvas.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page 75x75+5+10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -flatten  flatten_bounds.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_bounds.gif"><img src="flatten_bounds.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The normal use of <a href="#flatten">Flatten</a> is to merge multiple 'layers' of images together. That is, you can be generating various parts of a larger image, usually using <a href="../basics/#parenthesis">Parenthesis</a> to limit image operators to the single 'layer' image being generated, and then flatten the final result together. For example one typical use is to create a <a href="../blur/#shadow">Shadow Image</a> layer, onto which the original image is flattened. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick balloon.gif \( +clone  -background navy  -shadow 80x3+5+5 \) +swap \
          -background none   -flatten   flatten_shadow.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_shadow.png"><img src="flatten_shadow.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that as I want the shadow under the original image, I needed to <a href="../basics/#swap">swap</a> the two images place them in the right order.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Using <a href="#flatten">Flatten</a> for adding generated <a href="../blur/#shadow">Shadow Images</a> is not recommended, as generated shadow images can have negative image offsets.<br>
              <br>
              The recommended solution, as given in the section on <a href="../blur/#shadow">Shadow Images</a>, is to use the more advanced <a href="#merge">Layer Merging</a> technique, we will look at later.</i></font></td>
            </tr>
          </table>Because the <a href="../basics/#page">Virtual Canvas</a> consists of just a size, the resulting image will be that size, but have no virtual canvas offset, as such you do not need to worry about any offsets present in the final image. This use of the virtual canvas to define the canvas on which to overlay the image means you can use it to add a surrounding border to an image. For example here I set an image's size and virtual offset to 'pad out' an image to a specific size.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick medical.gif -set page 64x64+20+20 \
          -background SkyBlue   -flatten   flatten_padding.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_padding.gif"><img src="flatten_padding.gif" width="64" height="64" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Of course there are better ways to <a href="../thumbnails/#pad">Pad Out an Image</a> so that IM automatically centers the image in the larger area.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Strangely the exact same handling can be used to 'clip' or <a href="../crop/#crop">Crop</a> an image to a virtual canvas that is smaller than the original image. In this case however you want to use a negative offset to position the 'crop' location, as you are offsetting the image and not positioning the crop 'window'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick logo:  -repage 100x100-190-60  -flatten  flatten_crop.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_crop.gif"><img src="flatten_crop.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Of course a <a href="../crop/#crop_viewport">Viewport Crop</a> would also do this better, without the extra processing of canvas generation and overlaying that "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" also does. It also will not 'expand' the image itself to cover the whole viewport if the image was only partially contained in that viewing window. A common mis-use of the "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" operator is to <a href="../masking/#remove">Remove Transparency</a> from an image. That is, to get rid of any transparency that an image may have, but overlaying it on the background color. However this will not work when multiple images are involved as as such no longer recommended. <a name="mosaic" id="mosaic"></a>
          <h3>Mosaic - Canvas Expanding</h3>The "<code><a href="../option_link.cgi?layers">-layers</a> <b>mosaic</b></code>" operator (or its "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" shortcut) is more like an expanding canvas version of the <a href=".#flatten">Flatten Operator</a>. Rather than only creating an initial canvas based on just the canvas size of the initial image, the <a href="#mosaic">Mosaic Operator</a> creates a canvas that is large enough to hold all the images (in the positive direction only). For example, here I don't even set an appropriate <a href="../basics/#page">Virtual Canvas</a>, however the "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" operator will work out how big such a canvas needs to be to hold all the image layers.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page +5+10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -layers mosaic  mosaic.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="mosaic.gif"><img src="mosaic.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As on IM v6.3.6-2 the "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" operator is only an alias for a "<code><a href="../option_link.cgi?layers">-layers</a> 'mosaic'</code>".<br>
              <br>
              Thus the "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" option can be regarded as a short cut for the "<code><a href="../option_link.cgi?layers">-layers</a></code>" method of the same name.</i></font></td>
            </tr>
          </table>Note that both "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" and "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" still creates a canvas that started from the 'origin' or 0,0 pixel. This is part of the definition of an images 'virtual canvas' or 'page' and because of this you can be sure that the final image for both operators will have a no virtual offset, and the whole canvas will be fully defined in terms of actual pixel data. Also note that "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" will only expand the canvas in the positive directions (the bottom or right edges), as the top and left edge are fixed to the virtual origin. That of course means "<code><a href="../option_link.cgi?mosaic">-mosaic</a></code>" will still clip images with negative offsets...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page -5-10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -mosaic  mosaic_clip.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="mosaic_clip.gif"><img src="mosaic_clip.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="merge" id="merge"></a>
          <h3>Merging - to Create a New Layer Image</h3>The "<code><a href="../option_link.cgi?layers">-layers</a> <b>merge</b></code>" operator is almost identical to the previous operators and was added with IM v6.3.6-2. It only creates a canvas image just large enough to hold all the given images at their respective offsets. Like <a href="#mosaic">Mosaic</a> will also expand the canvas, but not only in the positive direction, but also in the negative direction. Basically it means that you don't have to worry about clipping, offset, or other aspects when merging layer images together. All images will be merged relative to each others location. The output does not include or ensure the origin is part of the expanded canvas. As such the output of a <a href="#merge">Layers Merge</a> can contain a 'layers offset' which may be positive or negative. In other words.. <a href="#merge">Layers Merge</a> merges layer images to produce a new <i>layer image</i>. As such if you don't want that offset when finished you will probably want to include a "<code><a href="../option_link.cgi?repage">+repage</a></code>" operator before the final save. For example, here is the same set of layer image we have used previously...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page +5+10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -layers merge  +repage layers_merge.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layers_merge.gif"><img src="layers_merge.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the image is only just big enough to hold all the images which were placed relative to each other, while I discarded the resulting images offset relative to the virtual canvas origin. This preservation of relative position without clipping or extra unneeded space is what make this variant so powerful. Lets try this again by giving one image a negative offset...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page -5-10  balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( -page +62+50 present.gif \)   \( -page +10+55 shading.gif \)  \
          -background dodgerblue  -layers merge  +repage layers_merge_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layers_merge_2.gif"><img src="layers_merge_2.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the "balloon" was not clipped, just moved further away from the others so as to preserve its relative distance to them. Of course the "<code><a href="../option_link.cgi?repage">+repage</a></code>" operator in the above examples, removes the absolute virtual canvas offset in the final image, preserving only the relative image placements between the images. The offset was removed as web browsers often have trouble with image offsets and especially negative image offsets, unless part of a GIF animation. But if I did not remove that offset, all the images will remain in their correct location on the virtual canvas within the generated single layer image, allowing you to continue to process and add more images to the merged image. Typically you would use a "<code><a href="../option_link.cgi?background">-background</a></code>" color of '<code>None</code>', to make the unused areas of the merged image transparent. When applied to a single image, <a href="#merge">Layer Merging</a> will replace any transparency in the image with the solid color background, but preserve the images original size, as well as any any offsets in that image, The virtual canvas size of the image however may be adjusted to 'best fit' that images size and offset. The operators original purpose was allow users to more easily merge multiple distorted images into an unified whole, regardless of the individual images offset. For example when aligning photos to form a larger 'panorama'. You could simply start with a central undistorted base image (without an offset), and use this operator to overlay the other images around that starting point (using either negative or positive offsets) that have been aligned and distorted to match that central image. For other examples of using this operator by distorting images to align common control points, see <a href="../distorts/#cube3d">3D Isometric Photo Cube</a>, and <a href="../distorts/#cube3d">3D Perspective Box</a>. Other examples of using this operator is to generate a simple series of <a href="../photos/#overlap">Overlapping Photos</a>.
          <pre>
The operation "<code>-layers trim-bounds</code>" can be used to ensure all
images get a positive offset on a minimal canvas size, while retaining there
relative positions, and without actually layer merging the images into one
final image.

This lets you then perform further processing of the images before they are
actually merged, such as placing more images relative to the that image group
but looking up the resulting virtual canvas bounds.

However if images have a transparency, it is probably a good idea to trim
that transparency from images first, making the ideal usage...

  -alpha set -bordercolor none -border 1x1 -trim -layers trim-bounds

This minimizes the image layers including any and all transparent areas of
actual image data, while ensuring everything is contained on a valid
virtual (positive) canvas of minimal size.

</pre><a name="coalesce" id="coalesce"></a>
          <h3>Coalesce Composition - a Progressive Layering</h3>The "<code><a href="../option_link.cgi?layers">-layers</a> <b>coalesce</b></code>" image operator (or its "<code><a href="../option_link.cgi?coalesce">-coalesce</a></code>" shortcut) is really designed for converting GIF animations into a sequence of images. For examples, see <a href="../anim_basics/#coalesce">Coalescing Animations</a> for details. However, it is very closely associated with "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" and has very useful effects for multi-layered images in this regard.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example using <a href="#coalesce">Coalesce</a> on a single image, will do exact the same job as using <a href="#flatten">Flatten</a> with a "<code><a href="../option_link.cgi?background">-background</a></code>" color of '<code>None</code>' or '<code>Transparency</code>'. That is, it will 'fill out' the canvas of the image with transparent pixels.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page 100x100+5+10 balloon.gif \) -layers coalesce  coalesce_canvas.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="coalesce_canvas.gif"><img src="coalesce_canvas.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>When dealing with an image consisting on multiple layers, <a href="#coalesce">Coalesce</a> can be used to generate a 'Progressive Layering' of the image. But to do this we need to take a few precautions, to disable any 'GIF animation' handling by the operator.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   magick \( -page 100x100+5+10 balloon.gif \)   \( -page +35+30 medical.gif \)  \
           \( --page +62+50       present.gif \)   \( -page +10+55 shading.gif \)  \
           -set dispose None  -coalesce  miff:- |\
     montage - -frame 4 -tile x1 -geometry +2+2 \
             -background none -bordercolor none  coalesce_none.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="coalesce_none.gif"><img src="coalesce_none.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>In the above, we "<code><a href="../option_link.cgi?set">-set</a></code>" all the "<code><a href="../option_link.cgi?dispose">-dispose</a></code>" settings to '<code><a href="../anim_basics/#none">None</a></code>'. This effectively tells "<code><a href="../option_link.cgi?coalesce">-coalesce</a></code>" to just overlay each frame on top the results of the previous overlays. The result is the first image is just a 'fill out' of the images canvas, with a transparency background. The next image is the previous image with that layer overlaid. And so on. A 'progressive' flatten of the image sequence. The last image in the sequence will thus be the same as if you did a normal "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" with a transparent background. You can get a completely different sort of effect if you had used a "<code><a href="../option_link.cgi?dispose">-dispose</a></code>" setting of '<code><a href="../anim_basics/#background">Background</a></code>'. In this case "<code><a href="../option_link.cgi?coalesce">-coalesce</a></code>" will just 'fill out' the canvas of each image, as if they were completely separate images!
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page 100x100+5+10 balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( --page +62+50       present.gif \)   \( -page +10+55 shading.gif \)  \
          -set dispose Background  -coalesce  miff:- |\
    montage - -frame 4 -tile x1 -geometry +2+2 \
            -background none -bordercolor none  coalesce_bgnd.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="coalesce_bgnd.gif"><img src="coalesce_bgnd.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>Please note however that unlike <a href="#flatten">Flatten</a>, <a href="#mosaic">Mosaic</a>, or <a href="#merge">Merge</a> the "<code><a href="../option_link.cgi?coalesce">-coalesce</a></code>" operator does <i>not</i> make use of the current "<code><a href="../option_link.cgi?compose">-compose</a></code>" alpha composition setting. It only uses an '<code><a href="../compose/#over">Over</a></code>' compose method, as this is what is required for GIF animation handling. Using different "<code><a href="../option_link.cgi?compose">-compose</a></code>" methods with the more standard image layering operators is the subject of the next set of examples. <a name="compose" id="compose"></a>
          <h3>Compose Methods and Layering</h3>The three <a href="#layers">Layering</a> methods: <a href="#flatten">Flatten</a>, <a href="#mosaic">Mosaic</a>, and <a href="#merge">Merge</a>; will make use of the "<code><a href="../option_link.cgi?compose">-compose</a></code>" setting to determine the composition method used to overlay each image in sequence. As such you could think of these functions as a multi-image "<code><a href="../option_link.cgi?composite">-composite</a></code>" operator with the ability to set an initial "<code><a href="../option_link.cgi?background">-background</a></code>" canvas of a specified color. However using anything but the default <a href="../compose/">Alpha Composition</a> of '<code>Over</code>' requires some thought before applying or you will get unexpected results. You may also may need to think about the effect of the "<code><a href="../option_link.cgi?background">-background</a></code>" color that is used by these operators to generate a starting canvas, onto with each image (including the first) in composed. For example lets place each successive image <i>under</i> the previous images using a '<code><a href="../compose/#dstover">DstOver</a></code>'...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( -page 100x100+5+10 balloon.gif \)   \( -page +35+30 medical.gif \)  \
          \( --page +62+50       present.gif \)   \( -page +10+55 shading.gif \)  \
          -background none  -compose DstOver  -flatten  flatten_dstover.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_dstover.gif"><img src="flatten_dstover.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Here the background was set to be transparent, otherwise you will only see the background canvas in the result as all the other images will have been placed 'under' this initial canvas! This does provide a way of 'blanking' an image with a particular color, as shown in <a href="../canvas/#sized">Canvases Sized to an Existing Image</a>. Here is a more practical example. Rather than layering the images with the background canvas first, which awkward and un-natural in some image processing situations, you can just generate the images top-down or foreground to background order.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -repage +10+10 \
          \( +clone -background black -shadow 60x3+5+5 \) \
          \( granite: -crop 100x80+0+0 +repage \) \
          -background none  -compose DstOver -layers merge layer_dstover.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layer_dstover.gif"><img src="layer_dstover.gif" width="100" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Each of the first three lines generates one layer image, with the final line merging all the layers under the previous layers, effectively reversing the order.
          <p>As you can see the image processing for the above was simpler and cleaner than you normally would see with shadow generation, just by underlaying each image in sequence (with a transparent starting canvas)</p>Of course I could have just as easily <a href="../basics/#reverse">Reverse</a> the image list instead.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -repage +10+10 \
          \( +clone -background black -shadow 60x3+5+5 \) \
          \( granite: -crop 100x80+0+0 +repage \) \
          -reverse -layers merge layer_reverse.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layer_reverse.gif"><img src="layer_reverse.gif" width="100" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However remember that this only re-orders the existing images, and does not effect the 'starting background canvas' that the layering methods create. The compose methods can also be used to produce some interesting effects. For example, if you draw three circles, then by overlaying them using the '<code>Xor</code>' compose method, you get an unusual and complex looking symbol, for minimal effort.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 \
          \( xc:none -fill blue   -draw 'circle 21,39 24,57' \) \
          \( xc:none -fill red    -draw 'circle 39,39 36,57' \) \
          \( xc:none -fill green  -draw 'circle 30,21 30,3'  \) \
          -background none  -compose Xor   -flatten  flatten_xor.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flatten_xor.png"><img src="flatten_xor.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="layer_composite" id="layer_composite"></a>
          <h3>Layers Composite - Merge Two Layer Lists</h3>With IM v6.3.3-7 the "<code><a href="../option_link.cgi?layers">-layers</a></code>" method, '<code><b>Composite</b></code>' was added allowing you compose two completely separate sets of images together. To do this on the command line a special '<code><a href="../files/#null">null:</a></code>' marker image is needed to define where the first <i>destination</i> list of images ends and the overlaid <i>source</i> image list begins. But that is the only real complication of this method. Basically each image from the first list is composed against the corresponding image in the second list, effectively merging the two lists together. The second list can be positioned globally relative to the first list, using a <a href="../compose/#geometry">Geometry Offset</a>, just as you can with a normal <a href="../compose/#convert">Composite Operator</a> (see above). Gravity is also applied using the canvas size of the first image, to do the calculations. On top of that 'global offset', the individual virtual offset of image is also preserved, as each pair of images is composited together. One special case is also handled. If one of the image lists contains only one image, that image will be composed against all the images of the other list. Also in that case the image meta-data (such as animation timings) of larger list is what will be kept, even if it is not the destination side of the composition.<br>
          This laying operator is more typically used when composing two animations, which can be regarded as a sort of time-wise layered image list. Because of this it is better exampled in the <a href="../anim_mods/">Animation Modifications</a> section of the examples. So see <a href="../anim_mods/#compose">Multi-Image Alpha Composition</a> for more details.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="layer_handling" id="layer_handling"></a> <a name="layer_examples" id="layer_examples"></a>
          <h2>Handling Image Layers</h2>Laying multiple images using the various layer operators above is a very versatile technique. It lets you work on a large number of images individually, and then when finished you combine them all into a single unified whole. So far we have shown various ways of merging (composing or layering) multiple images in many different ways. Here I provide some more practical examples on just how to make use of those techniques. <a name="layer_thumbnails" id="layer_thumbnails"></a>
          <h3>Layering Of Thumbnail Images</h3>You can also use this technique for merging multiple thumbnails together in various complex ways. Here I add a <a href="../thumbnails/#soft_edges">Soft Edge</a> to the images as you read and position them, you can generate a rather nice composition of images, on a <a href="../canvas/#tile">Tiled Canvas</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -page +5+5    holocaust_tn.gif \
          -page +80+50  spiral_stairs_tn.gif \
          -page +40+105 chinese_chess_tn.gif \
          +page \
          -alpha Set -virtual-pixel transparent \
          -channel A -blur 0x10  -level 50,100% +channel \
          \( -size 200x200 tile:tile_fabric.gif -alpha Set \) -insert 0 \
          -background None -flatten  overlap_canvas.jpg
</samp></pre>
                </td>
              </tr>
            </table><a href="overlap_canvas.jpg"><img src="overlap_canvas.jpg" width="200" height="200" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div><a name="layer_calc" id="layer_calc"></a>
          <h3>Calculated Positioning of Images.</h3>The <a href="../basics/#page">Virtual Canvas Offset (page)</a> can be set in many ways. More specifically you can "<code><a href="../option_link.cgi?set">-set</a></code>" set this per-image <a href="../basics/#attribute">Attribute</a>, and even calculate a different location for each and every image. For example, here I read in a big set of images (small icon images all the same size) and arrange them in a circle.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick {balloon,castle,eye,eyeguy,ghost,hand_point,medical}.gif \
          {news,noseguy,paint_brush,pencil,present,recycle}.gif \
          {shading,skull,snowman,storm,terminal,tree}.gif \
          \
          -set page '+%[fx:80*cos((t/n)*2*pi)]+%[fx:80*sin((t/n)*2*pi)]' \
          \
          -background none -layers merge +repage image_circle.png
</samp></pre>
                </td>
              </tr>
            </table><a href="image_circle.png"><img src="image_circle.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The key to the above example is the "<code><a href="../option_link.cgi?set">-set</a> page</code>" operation that uses the normalized image index (the <a href="https://imagemagick.org/script/fx.php">FX Expression</a> '<code>t/n</code>'&nbsp;) to create a value from 0.0 to not quite 1.0 for each individual image. This value is then mapped to position the image (by angle) in a circle of 80 pixels radius, using <a href="../transform/#fx_escapes">FX Expressions as a Percent Escape</a>. The position calculated is of the top-left corner of the image (not its center, though that is a simple adjustment), which is then <a href="#merge">Merged</a> to generate a new image. The positioning is done without regard of the offset being positive or negative, which is the power of the <a href="#merge">Merge Laying Operator</a>. That is, we generated a new image of all the images as they are relative to each other. The final "<code><a href="../option_link.cgi?repage">+repage</a></code>" removes the final resulting negative offset of the merged layer image, as this is no longer needed and can cause problems when viewing the resulting image. Note that the first image (right-most in result) is layered below every other image. If you want the layering to be truly cyclic so the last image was below this first one, you may have to divide that first image in half and put the top half at the end of the sequence so the top half of the first image layers over last image, while the lower half remains below the second image. This technique is powerful, but it can only position images to an integer offset. If you need more exact sub-pixel positioning of images then the images will need to be distorted (translated) to the exact sub-pixel location rather than simply adjusting its virtual offset. <a name="layer_calc_inc" id="layer_calc_inc"></a>
          <h4>Incrementally Calculated Positions</h4>You can access some image attributes of other images using FX expressions, while setting the attribute of images as they are processed. This means that you can set the location of each image, relative the calculated position of the previous image. For example this sets the position of each image to be to the right of the previous image. That is, the previous image's position plus its width.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick rose: netscape: granite: \
          \
          +repage -set page '+%[fx:u[t-1]page.x+u[t-1].w]+0' \
          \
          -background none -layers merge +repage append_diy.png
</samp></pre>
                </td>
              </tr>
            </table><a href="append_diy.png"><img src="append_diy.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>Each image is appended to the location of the previous image, by looking up that location and adding that images width. This previous location was in fact just calculated, as IM looped through each image setting the '<code>page</code>' (virtual offset) attribute. The result is a DIY <a href="#append">Append Operator</a> equivalent, and from which you can develop your own variations. You should note that the whole sequence is actually shifted by '<code>u[-1].w</code>' set during the position calculation of the first image. This should be the width of the last image in the current image sequence. That overall displacement however is junked by the final "<code><a href="../option_link.cgi?repage">+repage</a></code>". You can use some extra calculation to have it ignore this offset, but it isn't needed in the above.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>When using an image index such as '<code>u[t]</code>' all image selectors '<code>u</code>', '<code>v</code>', and '<code>s</code>', all references the same image, according to the '<code>[index]</code>' given. As such it is better to use '<code>u</code>' (the first or zeroth image) as a mnemonic of this indexing behaviour (and in case this changes).<br>
              <br>
              For more information see <a href="../transform/#fx">FX, The DIY Image Operator</a>.</i></font></td>
            </tr>
          </table>Here is another example. Each image is offset relative to the previous image, using both position and width of that image, so as to calculate a <a href="#append_overlap">Overlapped Append</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
magick font_[0-9].gif \
        -set page '+%[fx:u[t-1]page.x+u[t-1].w-8]+%[fx:u[t-1]page.y+4]' \
        -background none -layers merge +repage append_offset.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="append_offset.gif"><img src="append_offset.gif" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>This ability to access attributes of other images, also includes the pixel data of other images. That means you could create a special image where the color values represent the 'mapped positions' of the other images. Of course that 'mapping' image would also be positioned, and would need to be removed before the overlay is performed. How useful creating special 'mapped position' images is another matter. It is just another possibility. <a name="layer_prog" id="layer_prog"></a>
          <h3>Two Stage Positioning of Images</h3>You can simplify your image processing, by separating them into two steps. One step can be used to generate, distort, position and add fluff to images, with a final step to merge them all together. For example, lets create <a href="../transform/#polaroid">Polaroid Thumbnails</a> from the larger original images in <a href="../img_photos/INDEX.html">Photo Store</a>, processing each of them individually (keeping that aspect separate and simple).
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" random="" image="overlapped_polaroids.jpg">
  center=0   # Start position of the center of the first image.
             # This can be ANYTHING, as only relative changes are important.

  for image in ../img_photos/[a-m]*_orig.jpg
  do

    # Add 70 to the previous images relative offset to add to each image
    #
    center=`magick xc: -format "%[fx: $center +70 ]" info:`

    # read image, add fluff, and using centered padding/trim locate the
    # center of the image at the next location (relative to the last).
    #
    magick -size 500x500 "$image" -thumbnail 240x240 \
            -set caption '%t' -bordercolor Lavender -background black \
            -pointsize 12  -density 96x96  +polaroid  -resize 30% \
            -gravity center -background None -extent 100x100 -trim \
            -repage +${center}+0\!    MIFF:-

  done |
    # read pipeline of positioned images, and merge together
    magick -background skyblue   MIFF:-  -layers merge +repage \
            -bordercolor skyblue -border 3x3   overlapped_polaroids.jpg

</code></pre>
                </td>
              </tr>
            </table><a href="overlapped_polaroids.jpg"><img src="overlapped_polaroids.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>The script above seem complicated but isn't really. It simply generates each thumbnail image in a loop, while at the same time center pads (using <a href="../crop/#extent">Extent</a>) and <a href="../canvas/#trim">Trims</a> each image so that the images 'center' is in a known location on the virtual canvas. It could actually calculate that postion, though that may require temporary files, so it is better to ensure it is in a well known location, for all images. The image is then translated (using a relative "<code><a href="../option_link.cgi?repage">-repage</a></code>" operator, see <a href="../basics/#page">Canvas Offsets</a>), so that each image generated will be exactly 60 pixels to the right of the previous image. That is, each image center is spaced a fixed distance apart, regardless of the images actual size, which could have changed due to aspect ratios and rotations. The other major trick with this script is that rather than save each 'layer image' into a temporary file, you can just write the image into a pipeline using the <a href="../files/#miff">MIFF:</a> file format. A method known as a <a href="../files/#miff_stream">MIFF Image Streaming</a>. This works because the "<code>MIFF:</code>" file format allows you to simply concatenate multiple images together into a single data stream, while preserving all the images meta-data, such as its virtual canvas offset. This technique provides a good starting point for many other scripts. Images can be generated, or modified and the final size and position can be calculated in any way you like. Another example is the script "<code><a href="../scripts/hsl_named_colors">hsl_named_colors</a></code>" which takes the list of named colors found in ImageMagick and sorts them into a chart of those colors in HSL colorspace. You can see its output in <a href="../color_basics/#colors">Color Specification</a>. Other possibilities include...
          <ul>
            <li>Use any type of thumbnail (or other <a href="../thumbnails/#fluff">Fluff</a>), or just simply use a raw small thumbnail directly.
            </li>
            <li>Generate images so the first image is centered and the other images are arrange to the left and right under that first image, like a pyramid.</li>
            <li>Position images into Arcs, Circles and spirals, by placing them at specific X and Y coordinates relative to each other. For example: <a href="http://www.flickr.com/photos/dsevilla/2363002372">PhD Circle</a>, <a href="http://www.flickr.com/photos/krazydad/4994679">Sunset Flower</a>, <a href="http://www.flickr.com/photos/krazydad/4109739">Fibonacci Spiral</a>.
            </li>
            <li>Position images according to their color. For example: <a href="http://www.flickr.com/photos/davepattern/2954305171">Book Covers</a>.
            </li>
            <li>Position images by time of day or time submitted. For example: <a href="http://www.flickr.com/photos/krazydad/292081922">Year of Sunsets</a>
            </li>
          </ul>Basically you have complete freedom in the positioning of images on the virtual canvas, and can then simply leave IM to sort out the final size of the canvas needed to whole all the images. <a name="layer_pins" id="layer_pins"></a>
          <h3>Pins in a Map</h3>Here is a typical layering example, placing coloured pins in a map, at specific locations. <a href="../images/push_pin.png"><img src="../images/push_pin.png" width="50" height="43" align="left" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> To the left is a 'push pin' image. The end of the pin is at position <code>+18+41</code>. I also have an image of a <a href="../images/map_venice.jpg">Map of Venice</a>, and want to put a pin at various points on the map. For example 'Accademia' is locate at pixel position, <code>+160+283</code>. To align the push-pin with that position you need to subtract the location of the end of the pin from map position. This produces an offset of <code>+142+242</code> for our 'pin' image. Here is the result, using layered images
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick map_venice.jpg    -page +142+242 push_pin.png \
          -flatten  map_push_pin.jpg
</samp></pre>
                </td>
              </tr>
            </table><a href="map_push_pin.jpg"><img src="map_push_pin.jpg" width="466" height="350" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>This example was from an IM Forum Discussion, <a href="../forum_link.cgi?f=1&amp;t=20251">Layering Images with Convert</a>. <b>Lets automate this further.</b> We have a file listing the locations and colors for each of the pins we want to place in the map. The location name in the file is not used and is just a reference comment on the pixel location listed. <!-- <CODE EXECUTE>
  txt2gif map_venice_pins.txt
</CODE> -->
          <div align="center">
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="../images/map_venice_pins.txt"><img src="map_venice_pins.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[Data File]"></a>
                </td>
              </tr>
            </table>
          </div>Lets read this text file, to create 'pins' in a loop.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" random="" image="map_venice_pins.jpg">

  pin_x=18  pin_y=41

  cat map_venice_pins.txt |\
    while read x y color location; do

      [ "X$x" = "X#" ] &amp;& continue   # skip comments in data

      x=$(( x - pin_x ))    # magick x,y to pin image offsets
      y=$(( y - pin_y ))

      # magick 'color' to settings for color modulate (hue only)
      # assumes a pure 'red' color for the original push pin
      mod_args=$(
         magick xc:$color -colorspace HSL txt: |
           tr -sc '0-9\012' ' ' |\
             awk 'NR==1 { depth=$3 }
                  NR==2 { hue=$3;
                          print  "100,100,"  100+200*hue/depth
                        }'; )

      # re-color and position the push pin
      magick push_pin.png -repage +${x}+${y} -modulate $mod_args miff:-

    done |\
      # read pipeline of positioned images, and merge together
      magick map_venice.jpg  MIFF:-  -flatten  map_venice_pins.jpg

</code></pre>
                </td>
              </tr>
            </table><a href="map_venice_pins.jpg"><img src="map_venice_pins.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note it assumes the original pin color is red ( which has a hue of 0 ) and uses the <a href="../color_mods/#modulate">Modulate Operator</a> to re-color it to other colors, with the appropriate scaling calculations. Note that the modulate argument for a no-op hue change is 100, with it cycling over a value of 200 (a sort of pseudo-percentage value). <i>FUTURE: perspective distort map, adjust pin size for 'depth' on the map calculate change in pin position due to distortion, and 'pin' it to the distorted map.</i> The above used a method known as a <a href="../files/#miff_stream">MIFF Image Streaming</a>, with each image generated individually in a loop, then 'piped' into the 'layering' command to generate the final image. The alternative method (commonly using in PHP scripts) is to use a 'generated command' technique, that uses a shell script to generate a long "<code>magick</code>" command to be run. The scripts in <a href="../warping/#animations">Image Warping Animations</a> use this technique. Both methods avoid the need to generate temporary images. <a name="layer_shadow" id="layer_shadow"></a>
          <h3>Layers of Shadows</h3>Correctly handling semi-transparent shadow effects in a set of overlapping images is actually a lot more difficult than it seems. Just overlaying photos with shadows will cause the shadows to be applied twice. That is, two overlapping shadows become very dark, where in reality they do not overlay together in quite the same way that the overlaying images do. The various parts of the image should be simply shadowed or not shadowed. That is, shadows should be applied once only to any part of the image. You should not get darker areas, unless you have two separate light sources, and that can make things harder still. Tomas Zathurecky &lt; tom @ ksp.sk &gt; took up the challenge of handling shadow effects in layered images, and developed image accumulator technique, to handle the problem. Basically we need to add each image to the bottom of stack one at a time. As we add a new image the shadow of all the previous images needs to darken the new image, before it is added to the stack. However only the shadow falling on the new image, needs to be added. Shadows not falling on the new image needs to be ignored until later, when it falls on some other image, or the background (if any). Here is an example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( -clone 0   -background black -shadow 70x3+4+7 \
       -clone 1   -background black -compose DstATop -layers merge \
       -trim \) \
    \( -clone 2,0 -background none  -compose Over -layers merge \) \
    -delete 0--2 \
    \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \( -clone 0   -background black -shadow 70x3+4+7 \
       -clone 1   -background black -compose DstATop -layers merge \
       -trim \) \
    \( -clone 2,0 -background none  -compose Over -layers merge \) \
    -delete 0--2 \
    \
    \( +clone -background black -shadow 70x3+4+7 \) +swap \
    -background none -compose Over -layers merge +repage \
    layers_of_shadows.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layers_of_shadows.png"><img src="layers_of_shadows.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above program seems complex, but is actually quite straight forward. The first image is used to start an accumulating stack of images (image index #0). Note we could have actually started with a single transparent pixel ("<code>-size&nbsp;1x1&nbsp;xc:none</code>"), if you don't want to use that first image to initialize the stack. Now to add a new image to the bottom of the image stack, we apply the same set of operations, each time...
          <ul>
            <li>First the thumbnail image is read into memory, and any rotations, relative placements (may be negative), is applied. You could also do apply other thumbnailing operations to the image at this point if you want, though for his example that have already been performed. The new image forms image index #1.</li>
            <li>We now grab the previous stack of images (#0), generate a shadow with appropriate color, blur, offset, and ambient light percentage.</li>
            <li>This shadow is overlaid on the new image (#1) so only the shadow that falls '<code><a href="../compose/#atop">ATop</a></code>' the new image is kept. We also (optionally) apply a <a href="../crop/#trim">Trim Operation</a> the result to remove any extra space added from the shadowing operation, to form image #2.
            </li>
            <li>Now we simply add the new image (#2) to the accumulating stack of images (#0).</li>
            <li>and delete all the previous working images, except the last.</li>
          </ul>To add more images we basically just repeat the above block of operations. After all the images has been added to the stack, it is simply a matter of doing a normal shadowing operation on the accumulated stack of images. removing any remaining image offsets (which many web browsers hate). Using <a href="#merge">Merge</a> I can automatically handle virtual offsets, especially negative ones, allowing to to simply place images anywhere you like relative to the previous image placements. It also make applying shadows which can generate larger images with negative offsets properly.<br>
          Now the above handles multi-layered image shadows properly, but while the shadow is offset, it is actually offset equally for all the images! What really should happen is that the shadow should become more offset and also more blurry as it falls on images deeper and deeper in the stack. That is, an image at the top should case a very blurry shadow on the background, compared to the bottom-most image. This is actually harder to do as you not only need to keep a track of the stack of images, you also need to keep a track of how 'fuzzy' the shadow has become as the stack of images becomes larger. Thus you really need two accumulators. The image stack (as above), and the shadow accumulation, as we add more images. For example, here is the same set of images but with shadows that get more blurry with depth.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick xc:none xc:none \
    \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( -clone 1 -background black -shadow 70x0+0+0 \
       -clone 0 -background none -compose Over -layers merge \) \
    -delete 0-1 -trim +repage \
    layers_of_deep_shadows.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="layers_of_deep_shadows.png"><img src="layers_of_deep_shadows.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Look carefully at the result. The offset and blurriness of the shadow is different in different parts of the image. It is very thin between images in adjacent layers, but very thick when it falls on an image, or even the background much deeper down. Of course in this example, the shadow offset is probably too large, but the result seems very realistic giving a better sense of depth to the layers. Note how we split the operation of shadow into two steps. When applying the accumulated shadow (image index #1) to the new image (#2), we only add the ambient light percentage, without any blur, or offset ('<code>70x0+0+0</code>' in this case). The new image is then added to the accumulating stack of images (#0). But after adding new images (#2) shadow directly to the accumulated shadow (#1), again without blur or offset, only then do we blur and offset ALL the shadows, to form the new accumulated shadow image. In other words, the accumulated shadow image becomes more and more blurry and offset as the stack gets thicker and thicker. Only the shadow of deeper images has not accumulated the effect as much. This program essentually separates the application of the shadow, from the incremental shadow accumulator. This allows you control things like...
          <ul>
            <li>Realistic Shadow (as above): 70x0+0+0 and 100x2+4+7</li>
            <li>Constant Shadow (as basic example): 70x2+4+7 and 100x0+0+0</li>
            <li>constant blur, but cumulative offset: 70x2+0+0 and 100x0+4+7</li>
            <li>both constant and progressive offset: 60x0+4+7 and 100x0+1+1</li>
            <li>cumulative ambient light effect: 80x0+0+0 and and 95x2+4+7</li>
          </ul>Most of them are probably unrealistic, but may look good in another situations. Also setting the "<code>-background</code>" color before the "<code>-compose ATOP</code>" composition will let you define the color of the shadow (actually a colored ambient light). You can even even use a different color for the shadow that eventually falls on the final background layer (the last "<code>-background black</code>" setting), or leave it off entirely to make it look like the images are not above any background at all (that is floating in mid-air). It is highly versitile.<br>
          Tomas Zathurecky went on to develop another method of handling the shadows of layered images, by dealing with a list of layered images as a whole. Something I would not have considered posible myself. The advantage of this method is that you can deal with a whole list of images as a whole, rather than having to accumulate one image at a time, and repeating the same block of operations over and over. First lets again look at the simplier 'contant shadow' problem.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \
    -layers trim-bounds \
    \
    \( -clone 0--1 -dispose None -coalesce \
       -background black -shadow 70x2+4+7 \
       xc:none +insert null: +insert +insert xc:none \) \
    -layers trim-bounds -compose Atop -layers composite \
    \
    -fuzz 10% -trim \
    -reverse -background none -compose Over -layers merge +repage \
    coalesced_shadows.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="coalesced_shadows.png"><img src="coalesced_shadows.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The first block of opertors is just generating the list of layered images. It could be a separate programmed loop, as shown previously. The the operation starts with a "<code>-layers trim-bounds</code>", a <a href="../anim_mods/#trim">Bounds Trimming</a> operation that expands the virtual canvas of all images so as to contain all the images, and also ensure all offsets are positive. This is then cloned, <a href="#coalesce">Coalesced</a> and shadowed to create a separate progressing list of shadows. Now we can use <a href="#layer_composite">Layer Compostion</a> to merge the shadows and the original list of images together. The complication here is that before merging we need to not only add a special '<code>null:</code>' marker image to divide the two lists, but also add a special blank image '<code>xc:none</code>' so as to offset the shadow list. that way each shadow image will be overlaid '<code><a href="../compose/#atop">ATop</a></code>' the next image of the original list. All that is left is to merge the now correctly shadowed images from bottom to top (<a href="../basics/#reverse">Reverse</a>) order.<br>
          To handle 'deep shadows' requires <a href="#layer_calc">Layer Calculations</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \
    \( -clone 0--1 \
       -set page '+%[fx:page.x-4*t]+%[fx:page.y-7*t]' -layers merge \) \
    -layers trim-bounds +delete \
    \
    \( -clone 0--1 \
       -set page '+%[fx:page.x-4*t]+%[fx:page.y-7*t]' \
            -dispose None -coalesce \
       -set page '+%[fx:page.x+4*t]+%[fx:page.y+7*t]' \
            -background black -shadow 70x2+4+7 \
       xc:none +insert null: +insert +insert xc:none \) \
    -layers trim-bounds -compose Atop -layers composite \
    \
    -fuzz 10% -trim \
    -reverse -background none -compose Over -layers merge +repage \
    coalesced_deep_shadows.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="coalesced_deep_shadows.png"><img src="coalesced_deep_shadows.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can see the same set of blocks that was used previously, but with much more complicated caculations to set the initial <a href="../anim_mods/#trim">Bounds Trimming</a>, and later calculate the offsets needed for the 'progressive shadow list'. However the shadow currently does not become more blurry with depth.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The above will be a lot simplier using the IMv7 "magick" command, which would allow you to use 'fx calculations' directly the argument to "<code>-shadow</code>", that would let you not only calculate a larger offset for the shadow with depth, but also let you mak ethe shadow more blurry with depth.</i></font></td>
            </tr>
          </table><a name="layer_distort" id="layer_distort"></a> <a name="layer_distort_perspective" id="layer_distort_perspective"></a>
          <h3>Positioning Distorted Perspective Images</h3>Aligning distorted images can be tricky, and here I will look at aligning such images to match up at a very specific location. Here I have two images that highlight a specific point on each image. <!-- <CODE EXECUTE>
  magick -size 100x64 xc:SkyBlue -fill None \
          -draw 'stroke Blue  rectangle 0,0 99,63   fill Black  point 59,26
             stroke DodgerBlue
             path "M 53,26 56,26 M 62,26 65,26 M 59,20 59,23 M 59,29 59,32"' \
          align_blue.png
  magick -size 60x40 xc:LightPink -fill None \
          -draw 'stroke Tomato rectangle 0,0 59,39   fill Red point 35,14
             stroke Tomato
             path "M 31,10 33,12 M 37,16 39,18 M 31,18 33,16 M 37,12 39,10"' \
          -alpha set -channel A -evaluate set 65%  align_red.png
  magick -size 60x40 xc:LightPink -stroke Tomato -fill LightPink \
          -draw 'rectangle 0,0 59,39   fill Red point 35,14' \
</CODE> -->
          <div align="center">
            <a href="align_blue.png"><img src="align_blue.png" width="100" height="64" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a> <a href="align_red.png"><img src="align_red.png" width="60" height="40" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a>
          </div>The second image is 65% semi-transparent, which allow you to see though it when it is composed onto the blue image, so you can see if the marked points align. The marked control points themselves are at the coordinates <code>59,26</code> (blue) and <code>35,14</code> (red) respectively. If you are simply overlaying the two images, you can just subtract the offsets and 'compose' the two image on top of each other, producing an offset of <code>+24+12</code>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png align_red.png -geometry +24+12 \
          -composite align_composite.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_composite.png"><img src="align_composite.png" width="100" height="64" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that this offset could be negative! And that is something we will deal with shortly. This only works as the coordinates are integer pixel coordinates. If the matching coordinates are sub-pixel locations (as is typically the case in a photo montage), simple composition will not work. It will also not work well if any sort of distortion is involved (which is also common for real-life images). And this is the problem we will explore.<br>
          When distorting the image, you will want to ensure the two pixels remain aligned. The best way to do that would be to use the points you want to align as <a href="../distorts/#control_points">Distort Control Points</a>. This will ensure they are positioned properly.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort SRT '35.5,14.5  1 75  59.5,26.5' \
          \) -flatten  align_rotate.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_rotate.png"><img src="align_rotate.png" width="100" height="64" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As distort generates a 'layer image' with a 'canvas offset' you can not simply use <a href="../compose/#composite">Composite</a> to overlay the images (too low level), instead we need to use a <a href="#flatten">Flatten</a> operator, so that it will position them using the distort generated offset. Note how I also added a value of 0.5 to the 'pixel' coordinates. This is because pixels have area, while mathematical points do not, as such if you want to align the center of a pixel, you need to add 0.5 to the location of the center 'point' within the pixel. See <a href="../distorts/#control_coordinates">Image Coordinates vs Pixel Coordinates</a> for more information. The other problem with the above was that the overlaid image was 'clipped' by the blue background canvas image, just as the <a href="../compose/#composite">Composite Operator</a> does. That is, to say the 'blue' image provided the 'clipping viewport' for the result during the composition. To prevent this we use <a href="#merge">Layer Merge</a> instead which automatically calculates a 'viewport' canvas that is large enough contain hold all the images being composted together.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort SRT '35.5,14.5  1 75  59.5,26.5' \
          \) -background none -layers merge +repage  align_rotate_merge.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_rotate_merge.png"><img src="align_rotate_merge.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As the result of the 'merge' the image will have a 'negative' offset (so as to preserve layer positions of the images). To display the results I needed to junk that offset as many browsers do not handle negative offsets in images. I do this using "<code>+repage</code>" before saving the final image. If I was going to do further processing (without displaying the result on the web) I would keep that offset (remove the "<code>+repage</code>"), so the image positions remains in their correct and known position for later processing.<br>
          Now the same techniques as shown above would also apply if you were doing a more complex distortion such as <a href="../distorts/#perspective">Perspective</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '35.5,14.5  59.5,26.5
                       0,0 32,4    0,%h 14,36    %w,%h 72,53  ' \
          \) -background none -layers merge +repage  align_perspective.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_perspective.png"><img src="align_perspective.png" width="100" height="64" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The problem with this technique is that you position the perspective distortion using an internal control point. That is, one point in the inside of the image, and 3 points around the edge. That can make it hard to control the actual perspective shape, as a small movement of any control point can make the 'free corner' move wildly. This situation can be even worse if you are using a large list of 'registered points' to get a more exact 'least squares fit' to position images. In that case the point you are interested in be no wehere near one of the control 'registered' points used to distort the image. The alternative is to simply distort the image the way we need to, then figure out how we need to translate the resulting image to align the points we are interested in. To make this work we will need to know how the 'point of interest' moved as a result of the distortion. This is real problem with distorting and positioning images, especially real life images. For example, here I distort the image using all four corners to produce a specific (suposedally desired) distortion shape, but I will not try to align the control points at this point, just apply the distortion...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '0,0  10,12  0,%h 14,40
                               %w,0 68,6  %w,%h 63,48 ' \
          \) -background none -layers merge +repage  align_persp_shape.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_persp_shape.png"><img src="align_persp_shape.png" width="100" height="64" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see while the red image was distorted, the position of the red control point is no where near the blue control point we want to align. You can not just simply measure these two points as the red point is unlikely to be at an exact pixel position, but will have a sub-pixel offset involved. We will need to first calculate exactly where the red point is. To do that we can re-run the above distortion with verbose enabled to get the perspective forward mapping coefficients. These can then be used to calculate as described in <a href="../distorts/#perspective_projection">Perspective Projection Distortion</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="align_persp_verbose.txt">
  magick align_red.png  -define distort:viewport=1x1  -verbose \
          +distort Perspective '0,0  10,12  0,%h 14,40
                                %w,0 68,6  %w,%h 63,48 ' null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="align_persp_verbose.txt"><img src="align_persp_verbose.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>All we want is just the calculated coefficients used by the distortion. As such we don't need the destination image, so we just the output using a "<code>null:</code>" image file format. We also tell the distort that the new image it is generating is only one pixel is size using a <a href="../distorts/#distort_viewport">Distort Viewport</a>. That way it does the distortion preparation and verbose reporting, but then only distorts a single 'destination' pixel, which is then junked. This can save a lot of processing time. Actually if the distortion did not use source image meta-data (needed for the percent escapes '<code>%w</code>' and '<code>%h</code>') as part of its calculations, we would not even need the source image "<code>align_red.png</code>". In that case we could have used a single pixel "<code>null:</code>" image, for the input image too. We are also not really interested in the virtual pixels, backgrounds, or anything else for this information gathering step, so we don't need to worry about setting those features.<br>
          Now we can get the distort information, we need to extract the 8 perspective coefficients, from the 3rd and 4th line of the output. These can then be used to map the red control point to its new distorted position, and from there subtract it from the blue control point, so as to get the actual amount of translation that is needed, to align the marked red coordinate with the blue coordinate.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code script="" out="align_persp_coord.txt">
  bluex=59; bluey=26
  redx=35; redy=14

  magick align_red.png  -verbose \
             +distort Perspective '0,0  10,12  0,%h 14,40
                               %w,0 68,6  %w,%h 63,48 ' null: 2&gt;&amp;1 |\
    tr -d "',"  |\
      awk 'BEGIN   { redx='"$redx"'+0.5;   redy='"$redy"+0.5';
                     bluex='"$bluex"'+0.5; bluey='"$bluey"'+0.5; }
           NR == 3 { sx=$1; ry=$2;  tx=$3; rx=$4; }
           NR == 4 { sy=$1; ty=$2;  px=$3; py=$4; }
           END { div =  redx*px + redy*py + 1.0;
                 dx = ( redx*sx + redy*ry + tx ) / div;
                 dy = ( redx*rx + redy*sy + ty ) / div;
                 printf "red point now at %f,%f\n", dx, dy;
                 printf "translate shape by %+f %+f\n", bluex-dx, bluey-dy; }'
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="align_persp_coord.txt"><img src="align_persp_coord.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>The above used the "<code>tr</code>" text filter to remove extra quotes and commas from the output. It then uses the "<code>awk</code>" program to extract the coefficients, and do the floating point mathematics required to 'forward map' the red marker to match the blue marker. Note that I again added 0.5 to the 'pixel coordinates' of the control points to ensure that the center of the pixel is what is used for the calculations. See <a href="../distorts/#control_coordinates">Image Coordinates vs Pixel Coordinates</a>. Now we know the amount of translation needed by the distorted image, we have two ways you add that translation to the distortion. Either by modifying the coefficients of the perspective projection appropriately (not easy). Or we could just add the translation amounts to each of the destination coordinates of the original (very easy). Here is the result of the latter (add translations to destination coordinates)...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '0,0   31.408223,15.334305
                                   0,%h  35.408223,43.334305
                                   %w,0  89.408223, 9.334305
                                   %w,%h 84.408223,51.334305 ' \
          \) -background none -layers merge +repage  align_persp_move.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_persp_move.png"><img src="align_persp_move.png" width="100" height="64" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                To the right I have cropped and scaled the result around the control points to show they are perfectly aligned!
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick align_persp_shape.png -crop 19x19+50+17 +repage \
          -scale 500%   align_persp_shape_mag.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="align_persp_shape_mag.png"><img src="align_persp_shape_mag.png" width="95" height="95" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see we have a perfect alignment of the two pixels, without any sub-pixel overflow to any one side. Even the smallest miss-alignment would show as an asymmetrical coloring on either side of the central pixel. This scaling even shows a slight asymmetrical difference between left and right sides of the red cross due to the perspective distortion. That is, how accurate this pixel level view test is.<br>
          A similar but simpler problem is looked at in <a href="../annotating/#distort">Text Positioning using Distort</a>.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="evaluate-sequence" id="evaluate-sequence"></a>
          <h2>Evaluate-Sequence - Direct Mutli-Image Merging Methods</h2>The "<b><code><a href="../option_link.cgi?evaluate-sequence">-evaluate-sequence</a></code></b>" methods, are designed to merge multiple images of the <b>same size</b> together in very specific ways. In some ways it is a blend of the <a href="../transform/#evaluate">Evaluate and Function Operators</a> combined with multi-image <a href="#composite">Composition</a> techniques we have seen above. Many of the methods provided can even be performed using normal multi-image layering composition techniques, but not all.The operator uses the same methods as "<code><a href="../option_link.cgi?evaluate">-evaluate</a></code>" so you can get a list of them using "<code>-list Evaluate</code>". Though some of these (such as '<code>Mean</code>' and '<code>Medium</code>') are really only useful when used with this operator. <a name="average" id="average"></a> <a name="eval-seq_mean" id="eval-seq_mean"></a>
          <h3>Mean (Average) of multiple images</h3>Essentially both the older "<code>-evaluate-sequence mean</code>" and the newer "<code><a href="../option_link.cgi?evaluate-sequence">-evaluate-sequence</a> <b>mean</b></code>" will create an average of all the images provided. For example, here is an average of the rose image using all its <a href="../warping/#flip">Flipped and Flopped</a> versions.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence mean  average.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="average.png"><img src="average.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Averaging hundreds of images of the same fixed scene, can be used to remove most transient effects, such moving people, making them less important. However areas that get lots of transient effects may have a 'ghostly blur' left behind that may be very hard to remove. As video sequences are notoriously noisy when you look at the individual frames, you can average a number of consecutive, but unchanging, frames together to produce much better cleaner and sharper result. Matt Leigh, of the University of Arizona, reports that he has used this technique to improve the resolution of microscope images. He takes multiple images of the same 'target' then averages them all together to increase the signal/noise ratio of the results. He suggests others may also find it useful for this purpose. An alternative for averaging two images together is to use a "<code>composite -blend 50%</code>" image operation, which will work with two different sized images. See the example of <a href="../compose/#blend">Blend Two Images Together</a> for more detail. The <a href="../forum_link.cgi?f=1">IM Discussion Forum</a> had a discussion on <a href="../forum_link.cgi?f=1&amp;t=19945">Averaging a sequence 10 frames at a time</a>, so as to average thousands of images, without filling up the computers memory (making it very slow). Related to this, and containing relevent maths is the discussion <a href="../forum_link.cgi?f=1&amp;t=19855">Don't load all images at once</a>. Another alternative to using '<code>mean</code>' is to use the newer <a href="#poly">Poly Operator</a>, which can individually weight each image. <a name="eval-seq_min" id="eval-seq_min"></a> <a name="eval-seq_max" id="eval-seq_max"></a>
          <h3>Max/Min Value of multiple images</h3>The '<b><code>Max</code></b>' and '<b><code>Min</code></b>' methods will get the maximum (lighter) values and minimum (darker) values from a sequence of images. Again they are basically equivalent to using a <a href="../compose/#lighten">Lighten and Darken Composition Methods</a>, but with multiple images. With the right selection of background canvas color, you could use <a href="#flatten">Flatten Operator</a> with the equivelent compose method.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence max  max.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="max.png"><img src="max.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence min  min.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="min.png"><img src="min.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>WARNING: This is not a selection of pixels (by intensity), but a selection of values. That means the output image could result in the individule red, green and blue values from different images, resulting in a new color not found in any of the input images. If you need the pixels selected by their max/min by intensity, see the <a href="../compose/#lighten_intensity">Lighten by Intensity Compose Method</a>.<a name="eval-seq_median" id="eval-seq_median"></a>
          <h3>Median Pixel by Intensity</h3>The "<code><a href="../option_link.cgi?evaluate-sequence">-evaluate-sequence</a> <b>Median</b></code>" will look for the pixel which has an intensity of the middle pixel from all the images that are given. That is, for each position it collects and sorts the pixel intensity from each of the images. Then it will pick the pixel that falls in the middle of the sequence. It can also be used as an alternative to simply averaging the pixels of a collection of images. This could be used for example by combining an image with two upper and lower 'limiting' images. As the pixel will be the middle intensity you will either get the pixel from the original image, or a pixel from the 'limiting' images. In other words you can use this to 'clip' the intensity of the original image. Strange but true. For an even number of images, the pixel on the brighter side of the middle will be selected. As such with only two images, this operator will be equivalent to a pixel-wise "lighten by intensity". The key point is that each pixel will come completely from one image, and sorted by intensity. The exact color of each pixel will come completely from one of the given images, as such no new colors are generated. For example, here is pixels of median intensity of the rose image using all its <a href="../warping/#flip">Flipped and Flopped</a> versions. Note how it isn't as smooth, but could get sharp boundaries, as it is basied on intensities of the pixels.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence median  median.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="median.png"><img src="median.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="eval-seq_add" id="eval-seq_add"></a>
          <h3>Add Multiple Images</h3>The '<b><code>Add</code></b>' method is will of course simply add all the images together.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick ... -evaluate-sequence add ...
</samp></pre>
                </td>
              </tr>
            </table>
          </div>Which is a faster (more direct) version of using <a href="#flatten">Flatten</a> to <a href="../compose/#plus">Plus Compose</a> all the images together...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick ... -background black -compose plus -layers flatten ...
</samp></pre>
                </td>
              </tr>
            </table>
          </div>Be warned that adding images in this way can very easilly overflow the Quantum Range of the image, and as such it may get 'clipped', unless you use a <a href="../basics/#hdri">HDRI version of IM</a>. This is why an <a href="#eval-seq_mean">Average, or Mean</a> is generally used instead, as this will divide all images equally to ensure the resulting image is not clipped. Another alturnative is to use the newer <a href="#poly">Poly Operator</a>, which can individually weight each image. <a name="eval-seq_subtract" id="eval-seq_subtract"></a>
          <h3>Subtract Multiple Images</h3>The '<b><code>Subtract</code></b>' method subtracts each image from the first. Or at least that is what it should do. Internally it has arguments swapped and it is subtracting the previous results from the next image. Arrggggg! However by using a quirk of the <a href="../compose/#linearburn">Linear Burn Compose Method</a> you can subtract the second and later images from the first. Basically by <a href="../color_mods/#negate">Negating</a> all but the first image, and setting a '<code>white</code>' (negated zero) as a the starting background color you can then use <a href="../layering/#flatten">Flatten</a> to subtract all the images from the first.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick ...  \
         -negate \( -clone 0 -negate \) -swap 0 +delete \
         -compose LinearBurn -background white -flatten \
         ...
</samp></pre>
                </td>
              </tr>
            </table>
          </div><a name="eval-seq_multiply" id="eval-seq_multiply"></a>
          <h3>Multiple/Divide Multiple Images</h3>'<b>Multiply</b>' and '<b>Divide</b>' are accepted as methods by "<code><a href="../option_link.cgi?evaluate-sequence">-evaluate-sequence</a></code>" but they generate unexpected and odd results, as they are using the actual color value of the images rather than the normalised color value, just as "<code><a href="../option_link.cgi?evaluate">-evaluate</a></code>" does. As a result the scale of the multiply and divide is too large. This could be classed as a bug. In the meantime, you are better using the equivelent 'flatten' method for Multiply, which does work as expected.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick ... -background white -compose multiply -layers flatten ...
</samp></pre>
                </td>
              </tr>
            </table>
          </div><a name="poly" id="poly"></a>
          <h2>Poly - Merge Multiple Images Using a Polynomial</h2>Closely related to "<code><a href="../option_link.cgi?evaluate-sequence">-evaluate-sequence</a></code>" and specifically to the '<a href="#eval-seq_mean">mean</a>' method (image averaging), is the "<code><a href="../option_link.cgi?poly">-poly</a></code>" operator (added IM v6.8.0-5). This operator is given a list of two numbers for each image in memory, one to provide a multiplicative weight for each image, but also a power-of exponent to each image. This lets you merge a list of images as if each image was the variable input to a polynomial equation. The color values from each image is treated as if they were a normalized 0 to 1 value.With each pair of values the image color (normalized) is first powered by the second 'power-of' exponent, then it is weighted (multiplied) by the first number. If the exponent is '<code>1</code>' then the value is just multiplied by the given weighting. However if the exponent is '<code>0</code>' the weight becomes the final value, producing a normalized color constant addition (value from 0.0 to 1.0). A single pixel image can be provided in the current image sequence, and can be used to add a specific color, with a different normalized color value for each channel. (using a weight and exponent = 1.0). Or you can provide a "<code>NULL:</code>' image (or any other junk image), and use an exponent of 0.0. This will will only add the given weighting factor as constant. The final image is generated from the first image (and its size and other meta-data), just as it is with <a href="../transforms/#fx">FX DIY Operator</a>. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: granite: null: -poly '1,1 2,1 -1.0,0' poly_rose.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="poly_rose.png"><img src="poly_rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This takes a '<code>rose:</code>' (unmodified using a weight of 1 and power-of 1), adds to this twice the color values from the '<code>granite:</code>' image (weight=2), and finally subtracts a value of 1 using a '<code>null:</code>' image, using an exponent of 0 (ignore image input) and a weighting value of -1.0. The resulting image is equivalent to...
          <div align="center">
            <code>rose + 2.0*granite - 1.0</code>
          </div>or
          <div align="center">
            <code>rose + 2.0*(granite-0.5)</code>
          </div>In other words the rose image is given a noisy granite texture overlay (with a 50% grey bias). This is in fact exactly like a very strong '<code><a href="../compose/#hardlight">Hard_Light</a></code>' composition lighting effect but with very explicit weighting of the granite overlay. The key difference to this over other multi-image operations is the ability to weight each image individually, but perform all calculations in a single image processing operation without the need for extra intermediate images. This avoids any quantum rounding, clipping or other effects on the final results, in a non-<a href="../basics/#hdri">HDRI</a> version of ImagMagick. (See <a href="#../basics/#quantium_effects">Quantum Effects</a>). It can for example be used to perform a weighted average of large numbers of images, such as averaging smaller groups of images, then averaging those groups together.<br>
        </div>
        <hr>
        <!-- ---------------------------------------------------------------- -->
      </div>
    </div>
  </main>
  <footer class="magick-footer">
    <div class="container-fluid">
      Created: 3 January 2004<br>
      Updated: 19 April 2012<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://imagemagick.org/Usage/layers/</code>
    </div>
  </footer>
</body>
</html>
