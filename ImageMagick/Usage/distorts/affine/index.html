<html lang="en"><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../../assets/usage.css">
<TITLE>Affine Matrix Transforms -- ImageMagick Examples</TITLE>
<LINK REL="icon" HREF="../../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut icon" HREF="../../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical"
      HREF="https://imagemagick.org/Usage/distorts/affine/">
<!--[if gte IE 5.5000]><![if lt IE 7.0000]>
<script type="text/javascript" src="../../img_www/pngfix.js"></script>
<![endif]><![endif]-->
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick Examples -- <BR>
    <IMG SRC="../../img_www/space.gif" width=50 height=1>
    Affine Matrix Transforms</H1>

<div>

<DL>
<B>Index</B>
<DT><A HREF="../../"
    ><IMG SRC="../../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A><BR>
<DT><A HREF="#affine"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Affine Matrix Transforms</A>
<DT><A HREF="#affine_scale"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Scaling</A>
<DT><A HREF="#affine_flip"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Flips and Flops</A>
<DT><A HREF="#affine_shear"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Shearing</A>
<DT><A HREF="#affine_rot"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Rotations</A>
<DT><A HREF="#affine_pos"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Position of Affine Results</A>
<DT><A HREF="#affine_trans"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Translations</A>
<DT><A HREF="#affine_repos"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Result Re-Positioning</A>
<DT><A HREF="#affine_compound"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Compound Affine Translations</A>
<DT><A HREF="#affine_scripts"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Helper Scripts</A>
<DT><A HREF="#affine_other"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Other Affine Transform Methods</A>
<DT><A HREF="#affine_diy"
    ><IMG SRC="../../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Affine Transform DIY</A>
    <FONT SIZE=-1>(internal details)</FONT>
</DL></P>

The Affine Projection Matrix is not a simple distortion operator to
understand.  But it is very versatile and fast to distort an image using it.
In this section we take a look at how the affine matrix works, both in
ImageMagick and all other Image Processors. </P>

WARNING: See the first <IMG SRC="../../img_www/warning.gif"  WIDTH=28
HEIGHT=28 ALIGN=absmiddle> message below. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="affine"></A>
<H2>Affine Transformations</H2>

The Affine Transformation is a general rotation, shear, scale, and translation
distortion operator.  That is, it will modify an image to perform all four of
the given distortions all at the same time. </P>

These are all 'linear' distortions, by which I mean two straight parallel
lines present in an image will remain straight and parallel.  It is not a
perspective or trapezoidal transformation, which while lines remain straight,
they may not remain parallel. </P>

Confused. I'm not surprised. Both Affine and Perspective Transforms are such a
general technique that it is difficult to understand. So I'll try to start
slow with what you have seen, and advance to more difficult aspects as we go.
</P>

<BR>

The "<A HREF="../../option_link.cgi?affine" ><CODE>-affine</CODE></A>" option
is a setting that defines a set of 6 numbers which fully defines the way an
image is to be distorted. The "<A HREF="../../option_link.cgi?transform"
><CODE>-transform</CODE></A>" operator then performs this distortion. </P>

You can in fact apply affine transformation in a number of simpler ways using
the newer <A HREF="../#distort" >Generalised Distortion Operator</A> "<A
HREF="../../option_link.cgi?distort" ><CODE>-distort</CODE></A>", but I will
use the older "<A HREF="../../option_link.cgi?affine"
><CODE>-affine</CODE></A>" operator instead, as it has historically always
been available in IM. </P>

The two options "<A HREF="../../option_link.cgi?affine"
><CODE>-affine</CODE></A>" and "<A HREF="../../option_link.cgi?transform"
><CODE>-transform</CODE></A>", are separated as the "<A
HREF="../../option_link.cgi?affine" ><CODE>-affine</CODE></A>" setting is also
use as a vector mapping for the "<A HREF="../../option_link.cgi?draw"
><CODE>-draw</CODE></A>" command (see <A HREF="../../draw/#affine" >Warp the
Drawing Surface</A>).  As such, be careful about mixing these options. </P>

The arguments are supplied as a single comma separated string...
<PRE>     -affine  sx,rx,ry,sy,tx,ty</PRE>

These 6 numbers actually form a mathematical 'matrix' that translates a
position in the source image to a final position in the destination image, and
is expressed in terms of a 'matrix'...

<PRE>                                          | sx  rx  0 |
        | x', y', 1 |  =  | x, y, 1 |  *  | ry  sy  0 |
                                          | tx  ty  1 |</PRE>

This equates to the mathematical formula...

<PRE>   ( x', y' ) = ( x * sx + y * ry + tx,   x * rx + y * sy + ty  )</PRE>

This should be kept in mind, and we will re-visit it later. However for now
just note that this is the real meaning of a Affine transformation. </P>

As a starting point, if you use a  "<A HREF="../../option_link.cgi?affine"
><CODE>-affine</CODE></A>" matrix of '<CODE>1,0,0,1,0,0</CODE>', the above
formula will become...

<PRE>   ( x', y' ) = ( x, y )</PRE>

In other words, it will make <B>no changes</B> to the image, and is the best
point to start our exploration of Affine Transformations. </P>

Here we apply this transformation to our 'koala' image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,0,0,1,0,0 -transform +repage affine_null.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_null.png"
     ><IMG SRC="affine_null.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE ASSERT>
  [ `magick affine_null.png -shave 1x1 miff:- |\
       magick compare -metric PAE koala.gif - null: 2>&1 |\
         sed 's/ .*//'` -ne '0' ] &&  echo >&2 \
  "ASSERTION FAILURE: Affine did not reproduce the original image."
</CODE> -->

As you see nothing changed. </P>

But there are a few things you should note about the above command. </P>

The options "<CODE>-alpha set -virtual-pixel Transparent</CODE>" while not very
important in the above, will be very important later.  they basically tell IM
to add a alpha channel and make all pixels outside the input image
transparent. See <A HREF="../../misc/#transparent" >Transparent Virtual Pixel
Setting</A> for more detail.  </P>

Also the image has been slightly enlarged by 1 pixel on all sides which is is
to ensure that any semi-transparency effects along the edges of the image are
also preserved. </P>

I also used a "<CODE><A HREF="../../option_link.cgi?repage"
>+repage</A></CODE>" operator to reset the images position after performing
the affine transformation. This is important as raw affine transformations can
not only change an images size, but also an images position. In many cases
a negative position is created which often does not work well with images used
on a web page. </P>

This use of "<CODE><A HREF="../../option_link.cgi?repage" >+repage</A></CODE>"
with affine will be talked about in detail later, as a useful part of the
output from the affine transformation. But for now we will use it to ignore
any translation component in the result. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.4.2-8, the "<CODE><A HREF="../../option_link.cgi?affine"
  >-affine</A></CODE>" and "<CODE><A HREF="../../option_link.cgi?transform"
  >-transform</A></CODE>" combination, used the affine subroutine that was
  defined in the "<A HREF="../../option_link.cgi?draw"
  ><CODE>-draw</CODE></A>" operator.  This affine distortion routine works but
  causes sever <A HREF="../../resize/#aliasing" >aliasing</A> effects in the
  resulting image.  </P>

  After IM v6.4.2-8 the  "<CODE><A HREF="../../option_link.cgi?affine"
  >-affine</A></CODE>" and "<CODE><A HREF="../../option_link.cgi?transform"
  >-transform</A></CODE>" combination uses the new <A
  HREF="../#affine_projection" >General Distort, Affine Projection</A> method
  to do work, with the <A HREF="../#distort_bestfit" >Best-Fit</A> option.
  this produces much better results when strong scaling is applied.
  But is also means the various other <A HREF="../#distort_options"
  >Distort Options</A> can also be used. </P>

  As a result of this change the "<CODE><A HREF="../../option_link.cgi?affine"
  >-affine</A></CODE>" and "<CODE><A HREF="../../option_link.cgi?transform"
  >-transform</A></CODE>" options are obsolete, and users should
  directly use the equivalent "<CODE>+distort AffineProjection ...</CODE>"
  operator instead, with all its extra control settings and options. </P>

</I></FONT></TD></TR></TABLE></P>

Here is the same example again using the newer "<CODE><A HREF="../../option_link.cgi?distort" >+distort</A></CODE>" operator, and
producing the exact same result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          +distort AffineProjection 1,0,0,1,0,0  +repage affine_proj_null.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_proj_null.png"
     ><IMG SRC="affine_proj_null.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  [ `magick affine_proj_null.png -shave 1x1 miff:- |\
       magick compare -metric PAE koala.gif - null: 2>&1 |\
         sed 's/ .*//'` -ne '0' ] &&  echo >&2 \
  "ASSERTION FAILURE: AffineProjection did not reproduce the original image."
</CODE> -->

The rest of these example use the old method as they were written long before
the new "<CODE><A HREF="../../option_link.cgi?distort" >+distort</A></CODE>"
operator became available. </P>


<A NAME="affine_scale"></A>
<H3>Affine Scaling</H3>

The two '<CODE>1</CODE>' values in the last examples, or the '<CODE>sx</CODE>'
and '<CODE>sy</CODE>' arguments, are scaling factors, and modifying these will
enlarge or shrink the image.  The size of the resulting image will be adjusted
accordingly, so as to hold the complete result.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1.5,0,0,1.5,0,0 -transform +repage affine_expand.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1.0,0,0,0.5,0,0    -transform +repage affine_shrink.png
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_expand.png"
     ><IMG SRC="affine_expand.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shrink.png"
     ><IMG SRC="affine_shrink.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note that the image are scaled to produce a simular result as "<CODE><A
HREF="../../option_link.cgi?resize" >-resize</A></CODE>", but are not limited
to whole pixel boundaries.  That is, you can have semi-tranparent (fuzzy)
partial pixels along the edges of the image.  See <A
HREF="../../resize/#distort" >Resize Distort/Affine</A> for more details. </P>

<A NAME="affine_flip"></A>
<H3>Affine Flips and Flops</H3>

This may not seem exciting or interesting, but image scaling with a negative
will also produce "<CODE><A HREF="../../option_link.cgi?flip"
>-flip</A></CODE>" and "<CODE><A HREF="../../option_link.cgi?flop"
>-flop</A></CODE>" style of image transforms.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,0,0,-1,0,0   -transform  +repage  affine_flip.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine -1,0,0,1,0,0   -transform  +repage  affine_flop.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine -1,0,0,-1,0,0  -transform  +repage  affine_180.png
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_flip.png"
     ><IMG SRC="affine_flip.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_flop.png"
     ><IMG SRC="affine_flop.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_180.png"
     ><IMG SRC="affine_180.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="affine_shear"></A>
<H3>Affine Shearing</H3>

The middle two zero arguments, '<CODE>rx</CODE>' and '<CODE>ry</CODE>', will
shear the image in a similar way the "<CODE><A
HREF="../../option_link.cgi?shear" >-shear</A></CODE>" operator does.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,.3,0,1,0,0   -transform  +repage  affine_shear_x.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,-.3,0,1,0,0  -transform  +repage  affine_shear-x.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,0,.3,1,0,0   -transform  +repage  affine_shear_y.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,.3,.3,1,0,0  -transform  +repage  affine_shear_xy.png
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,-.3,.3,1,0,0 -transform  +repage  affine_shear_rot.png
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_shear_x.png"
     ><IMG SRC="affine_shear_x.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shear-x.png"
     ><IMG SRC="affine_shear-x.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shear_y.png"
     ><IMG SRC="affine_shear_y.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shear_xy.png"
     ><IMG SRC="affine_shear_xy.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shear_rot.png"
     ><IMG SRC="affine_shear_rot.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note how this is different to the 'simpler' <A HREF="../../warping/#shear"
>Shear Operator</A>, in that both the X and the Y shears are applied together,
rather than consecutively.  This allows the affine version of shear (with some
proportional scaling) to perform proper rotations of the image about the
origin point. </P>

The actual value use for the shear, is also not an angle, though is related
(see below).  That is, a shear value of '<CODE>1</CODE>' will result in a 45
degree shear, while a value of '<CODE>.5</CODE>' is an approximate 30 degree
shear.  This gets more complex however if some scaling or both X and Y shears
are also applied at the same time. </P>


<A NAME="affine_rot"></A>
<H3>Affine Rotations</H3>

You may have noticed in the last example above that you can rotate an image
just by using shears.  However when rotating an image by only using shears,
the image will become larger.  To fix this you also need to make the image
slightly smaller by adjusting the scaling of the image. For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine .9,-.1,.1,.9,0,0 -transform  +repage affine_rotate.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_rotate.png"
     ><IMG SRC="affine_rotate.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you want to calculate the correct affine matrix to do proper unscaled
rotation for any angle you can use the following formula...

<DIV ALIGN=center>
        sx =  cos(&alpha;); &nbsp;&nbsp; rx =  sin(&alpha;)
<BR>    ry = -sin(&alpha;); &nbsp;&nbsp; sy =  cos(&alpha;)
<BR>    where &alpha; is the angle to rotate in radians.
</DIV>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  angle=-75;   radians=`perl -e "print $angle * atan2(1,1)/45"`
    sx=`perl -e "print cos( $radians )"`
    rx=`perl -e "print sin( $radians )"`
    ry=`perl -e "print -($rx)"`
    sy="$sx"
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine $sx,$rx,$ry,$sy,0,0 -transform  +repage  affine_rotate2.png
</samp></pre></TD></TR></TABLE>
</TD><TD>
  <A HREF="affine_rotate2.png"
     ><IMG SRC="affine_rotate2.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

To make this calculation easier I created a simple perl script, "<CODE><A
HREF="../../scripts/affine_rotate" >affine_rotate</A></CODE>" to do these
calculations for you.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  affine_rotate 25  &gt; affine_rotate.txt
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine `affine_rotate 25` -transform +repage  affine_rotate3.png
</samp></pre></TD></TR></TABLE>
</TD><TD VALIGN=top ROWSPAN=2>
  <A HREF="affine_rotate3.png"
     ><IMG SRC="affine_rotate3.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="affine_rotate.txt"
     ><IMG SRC="affine_rotate.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE></P>

More on this <A HREF="#affine_scripts" >Affine Helper Script</A> later. </P>

<A NAME="affine_pos"></A>
<H3>Position of Affine Results</H3>

You will have noticed the use of "<CODE><A HREF="../../option_link.cgi?repage"
>+repage</A></CODE>" in just about all the above examples of using an affine
transformation.  This is because the transformed image is not always
a acceptable value for displaying images on web pages. </P>

So lets have a look at the raw canvas information generated by some of the
transformations we used above. </P>

Here I perform a affine flop, shear, and rotate of the example image and
output the resulting images information, but I will not display the images
produced as they are the same as the previous examples, just having some
'negative' offsets making them un-displayable directly on a web page.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE OUT=affine_raw_info.txt>
  magick koala.gif  -affine -1,0,0,1,0,0   -transform  info:
  magick koala.gif  -affine 1,-.3,0,1,0,0  -transform  info:
  magick koala.gif  -affine .9,-.1,.1,.9   -transform  info:
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="affine_raw_info.txt"
     ><IMG SRC="affine_raw_info.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

First ignore the size of the virtual canvas generated by the transformation.
This size is of little importance as it is not always possible for it to be a
sensible value, though IM tries to make it sensible in most cases. </P>

What is important is that the the final position of the images in all the
these cases have a negative value.  This is the true location of the image
after the "<CODE><A HREF="../../option_link.cgi?affine" >-affine</A></CODE>"
transformation has been performed, and shows the image being transformed
around the 'origin' or top-left corner of the image. </P>

<A NAME="affine_viewport"></A>

If we use a little extra processing of the transformed into a '<A
HREF="../../crop/#crop_viewport" >viewport image</A>', we can show how the image
was positioned relative to the images original origin or 0,0 position of the
original image.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          affine_null_view.gif
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine -1,0,0,1,0,0   -transform \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          affine_flop_view.gif
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,-.3,0,1,0,0  -transform \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          affine_shear_view.gif
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 0.1,-0.95,0.95,0.1   -transform \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          affine_rot_view.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_null_view.gif"
     ><IMG SRC="affine_null_view.gif"     WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="affine_flop_view.gif"
     ><IMG SRC="affine_flop_view.gif"     WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_shear_view.gif"
     ><IMG SRC="affine_shear_view.gif"    WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="affine_rot_view.gif"
     ><IMG SRC="affine_rot_view.gif"      WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Yes the above is complex, but adds a lot if information about the resulting
"<CODE><A HREF="../../option_link.cgi?affine" >-affine</A></CODE>"
transformation that is normally hard to see.  First it adds a blue border
around the actual image data result without effecting the virtual offset of
the resulting image.  This is then overlaid onto a viewport canvas, with the
origin or 0,0 point centered in the image. A red cross is draw at that point,
to show how the image relates to the origin of the original image after being
transformed. </P>

Notice how in all the above transformations, the actual image generate is
given a negative offset. That is, the position of the very top left corner of
the blue box is either above or to the left of the origin.   The Affine
transform does this as all the transformations performed leave the images
original origin (0,0 pixel) at the origin.  That is, this point does not move
when an image is purely scaled, rotated, or sheared. </P>

The only time the images original origin (or 0,0) point changes is if you also
give a translation component. </P>

This special handling of virtual canvas offsets by the "<CODE><A
HREF="../../option_link.cgi?transform" >-transform</A></CODE>" operator is
important so as to avoid loosing information about the results of the affine
transformation. </P>

It also means that we can use that offset to set this images location
correctly when it is combined with other images. </P>


<A NAME="affine_trans"></A>
<H3>Affine Translations</H3>

As a pure translation of an image (using an integer offset), only moves an
image to another location without distortion, the actual result of the
"<CODE><A HREF="../../option_link.cgi?affine" >-affine</A></CODE>"
transformation, is that the images page offset on the virtual page or canvas
is changed.  However IM will still process each and every pixel in the image,
even though there only a simple change in offset.  </P>

For example this shows that the image has been move on the larger virtual
canvas, so that the koala's nose (pixel <CODE>28,24</CODE>) is positioned at
the origin

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE OUT=koala_nose_info.txt>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine 1,0,0,1,-28,-24  -transform  -identify   koala_nose.png
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="koala_nose_info.txt"
     ><IMG SRC="koala_nose_info.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see from the identify output above, the image size was not changed,
though the offset of the image was changed. Unfortunately I can not display
the generated PNG image directly on this web page, as a negative offset can
cause undefined and often disastrous effects to the web browser output.  </P>

By taking a <A HREF="#affine_viewport" >viewport</A> image of the result, I
can remove that negative offset and show how the image was translated relative
to the images virtual canvas.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala_nose.png -virtual-pixel Transparent \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          koala_nose_vp.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_null_view.gif"
     ><IMG SRC="affine_null_view.gif"     WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_nose_vp.gif"
     ><IMG SRC="koala_nose_vp.gif"        WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note how the koala image itself was left unchanged.  Only its offset on the
virtual canvas was modified. However you should note that IM did still did the
calculations and processing needed for each and every pixel in the final
image.  </P>

In other words the result of a pure translation is that the image offset
changed, and that you can do more easily and directly using a "<CODE><A
HREF="../../option_link.cgi?repage" >-repage</A></CODE>" operation with
a '<CODE>!</CODE>' flag.  Of course if your affine matrix does more than just
translate the image, or translates the image a fraction of a pixel, then you
are better off doing the translation as part of the "<CODE><A
HREF="../../option_link.cgi?affine" >-affine</A></CODE>" matrix
transformation. </P>

Translation components is an important part of a general "<CODE><A
HREF="../../option_link.cgi?affine" >-affine</A></CODE>" transformation, as it
will allow you to rotate an image about any point on the image, or even
outside the image being transformed. </P>


<A NAME="affine_repos"></A>
<H3>Affine Result Re-Positioning</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that negative offsets are ignored by GIF image format, and will be
  saved as a zero offset, instead. On the other hand while the PNG file
  format will save negative offsets, many web browsers and image programs
  will not handle that situation, producing unexpected results.
</I></FONT></TD></TR></TABLE></P>

It is because of this I have avoided displayed any affine image results that
contain a negative offset.  Of course you can use negative offsets in PNG
images for later work, preserving the offset for later use. </P>

For example if you save a image with a negative value into a GIF format image
the negative values are replace by zero.  And while PNG images will correctly
save a negative position, it may have undefined consequences when displayed on
a web browser. For example some browsers have been known to generate extremely
large canvases for small PNG images with a negative offset.  Of course the
JPEG image format just ignores any position and canvas information that may be
present. </P>

So what can you do to correct the position of an image, so as to have a
positive offset. That depends on what you are trying to do. </P>

After applying a affine transformation, you would then usually apply one of
the following operations, to adjust the canvas and offset of the resulting
image.

<DL>
<DT><B>Reset the image position with +repage</B>
<DD>If you just want the resulting image, and don't care about the offset
    produced by the transformation, you can use "<CODE><A
    HREF="../../option_link.cgi?repage" >+repage</A></CODE>" to reset the page
    information, just as we do in the examples above.


<DT><B>Crop image to a new relative position</B>
<DD>Using a '<A HREF="../../crop/#crop_viewport" >viewport crop</A>' you can
    reposition the image and look at it as if you are viewing it though a
    window or viewport, onto the virtual canvas.   An example of this is given
    above in <A HREF="#affine_viewport">Position of Affine Results</A>. </P>


<DT><B>Post Re-position of the Image</B>
<DD>You can always just translate the position of the resulting image. This
    can be done by using an absolute "<CODE><A
    HREF="../../option_link.cgi?repage" >-repage</A></CODE>", a relative
    "<CODE><A HREF="../../option_link.cgi?repage" >-repage</A></CODE>"
    (with a '<CODE>!</CODE>' option), or even by adding a <B>Affine
    Translation</B> component to the translation matrix, to adjust the final
    position of the image. </P>

    For example, here is a correct flip affine transform, so that it is
    positioned correctly (other than the need to "<CODE><A
    HREF="../../option_link.cgi?shave" >-shave</A></CODE>" the extra edge
    pixels that were added as a precaution.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -affine 1,0,0,-1,0,75  -transform \
          -shave 1x1  affine_goodflip.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_goodflip.gif"
     ><IMG SRC="affine_goodflip.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

    Note that the translation component of an affine transformation is
    performed <B>after</B> the rotation and scaling has been completed.  This
    is what we will look at in the next section. </P>

</DL>

These are only some of the possibilities, and basically depends on just what you
want to do with the resulting image.  All you really need to do is decide
whether you need to keep the offsets of the transformation, or not. </P>

<A NAME="affine_compound"></A>
<H3>Compound Affine Translations</H3>

It is important to know that all the non-translation affine matrix methods
does not actually cause the 0,0 position of the image to move.  The only time
this point actually moves was when either the generated offset of the image
was reset (generally using  "<CODE><A HREF="../../option_link.cgi?repage"
>+repage</A></CODE>") or you also translated the resulting image, as part of
the affine matrix. </P>

However one of the most important uses of affine transformations is to rotate
images about a specific point, rather than the origin.  And it is here that
things start getting much more difficult. </P>

By re-positioning the image before the affine transformation, you can position
the point about which you want to rotate, at the origin.  This point should
not move under a non-translation affine transformation, so that point will
still be at the origin after the rotation has been performed.  You can then
move the image back to its original position, or some other position, in a
controlled way. </P>

For example, in the example above we translated the koala image so that its
nose (pixel 28,24) was at the origin.  Now lets rotate that image. and again
display a <A HREF="#affine_viewport" >viewport</A> image of it on the larger
virtual canvas.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -repage -28-24 -alpha set -virtual-pixel Transparent \
          -affine .5,-.866,.866,.5,0,0 -transform  koala_nose_rot.png
  magick koala_nose_rot.png \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          koala_nose_rot_vp.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="koala_nose_vp.gif"
     ><IMG SRC="koala_nose_vp.gif"        WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_nose_rot_vp.gif"
     ><IMG SRC="koala_nose_rot_vp.gif"    WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Notice that the rotation was around the origin, which due to the page offset,
is currently positioned on the koala's nose.  Now if you translate the image
back by the original translation, we will have rotated the image about its
nose, but without the nose changing position. </P>

That is, to properly rotate an image about a specific point you will need to
translate, rotate, and translate the image back again.  The last two parts
being easily performed simply a single matrix. </P>

Here is the complete process with the final translation also performed by
the affine matrix.  Study it carefully and you will see that the koalas
nose did not move on the virtual canvas, relative to the origin (red cross).

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -repage -28-24 -alpha set -virtual-pixel Transparent \
          -affine .5,-.866,.866,.5,28,24 -transform  koala_rot_nose.png
  magick koala_rot_nose.png \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          koala_rot_nose_vp.gif
</samp></pre></TD></TR></TABLE>
 <A HREF="affine_null_view.gif"
    ><IMG SRC="affine_null_view.gif"     WIDTH=160 HEIGHT=160
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
 <A HREF="koala_rot_nose_vp.gif"
    ><IMG SRC="koala_rot_nose_vp.gif"    WIDTH=160 HEIGHT=160
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Now affine matrices can of course do all three operations, all at the same
time, however calculating the affine matrix needed is not a trivial matter.
The following is the exact same operation, but with the appropriate,
all-in-one affine matrix.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine .5,-.866,.866,.5,-9.134,36.248 -transform  koala_complete.png
  magick koala_complete.png \
          -bordercolor blue -compose copy -border 1x1 -repage -1-1\! \
          -compose over -crop 160x160-80-80\! -background lightblue -flatten \
          -draw "fill red  path 'M 80,70 80,90  M 70,80 90,80'" \
          koala_complete_vp.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="affine_null_view.gif"
     ><IMG SRC="affine_null_view.gif"     WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_complete_vp.gif"
     ><IMG SRC="koala_complete_vp.gif"    WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note the position of the koala's nose relative to the origin has not changed,
even though the resulting image is now larger with a negative canvas offset.
</P>

To finish off lets repeat it again, but crop the image back to the images
original area, and flatten onto a white background.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine .5,-.866,.866,.5,-9.134,36.248 -transform \
          -crop 75x75+0+0\! -background white  -flatten   koala_rot_nose.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="../../images/koala.gif"
     ><IMG SRC="../../images/koala.gif"     WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_rot_nose.gif"
     ><IMG SRC="koala_rot_nose.gif"    WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A perfect rotate by 60 degrees about the koala's nose. </P>


<A NAME="affine_scripts"></A>
<H3>Affine Helper Scripts </H3>

As you can see in the examples above figuring out the affine matrix needed for
your transform is not always easy.  In fact it can be very difficult and may
require a deep understanding of how affine matrices, and matrix calculations
are performed to achieve the desired result. </P>

Because of this and to help in the creation of these examples I have created a
number of helper scripts to let you calculate the affine matrix you needed.
</P>

<H4>affine_rotate</H4>

The affine matrix in last example could be more simply calculated using the
"<CODE><A HREF="../../scripts/affine_distort" >affine_distort</A></CODE>"
script I introduced earlier.  If you supply this script with a extra argument
containing the point of rotation than it will calculate the correct affine
matrix to do it. </P>

For example, here we use the script to repeat the last example to rotate about
the koala's nose, but using a larger angle.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine `affine_rotate -110 28,24` -transform \
          -crop 75x75+0+0\! -background white -flatten koala_affine_rotate.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="koala_affine_rotate.gif"
     ><IMG SRC="koala_affine_rotate.gif"    WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you supply a second coordinate pair, the point of rotation (first
coordinate) will also be moved to the new position you give! For example lets
put the koala's nose of the last example near the bottom of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
          -affine `affine_rotate -110 28,24 28,72` -transform \
          -crop 75x75+0+0\! -background white -flatten koala_affine_rotate2.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="koala_affine_rotate2.gif"
     ><IMG SRC="koala_affine_rotate2.gif"    WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That is, you can take an image with a specific point, and rotate and
re-position the image using that 'handle'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  This can also be directly achieved much more efficiently and directly using
  the "<CODE><A HREF="../../option_link.cgi?distort" >+distort</A></CODE>"
  method '<CODE></A HREF="../#srt" >SRT</A></CODE>'.

</I></FONT></TD></TR></TABLE></P>


<H4>affine_distort</H4>

The script <CODE><A HREF="../../scripts/affine_distort"
>affine_distort</A></CODE>" is a similar script, but will also allow you to
scale or flip an image before it is rotated and translated to a new position.
The argument order is a little different, making it a little harder to use,
but it is much more versatile. </P>

For example lets repeat the last example, but also shrink the image, around
the repositioned 'handle'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
         -affine `affine_distort 28,24 .5,.5 -110 28,72` -transform \
         -crop 75x75+0+0\! -background white -flatten koala_affine_distort.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="koala_affine_distort.gif"
     ><IMG SRC="koala_affine_distort.gif"    WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The script however will not do any shearing of the image, but that is rarely
desired. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Again the '<CODE></A HREF="../#srt" >SRT</A></CODE>' distortion method can
  be used to do this much more efficiently. </P>
  
  In actual fact the '<CODE></A HREF="../#srt" >SRT</A></CODE>' method was
  directly developed from the "<CODE><A HREF="../../scripts/affine_distort"
  >affine_distort</A></CODE>" script into the <A HREF="../#distort"
  >Generalized Distort Operator</A>. </P>

</I></FONT></TD></TR></TABLE></P>


<H4>affine_transform</H4>

A affine transformation can be fully defined by the how a triangle of three
coordinates are translated. </P>

For example, here I define three coordinates, but then give the same three
coordinates in a 'flipped' arrangement.   The result is that the whole image
is flipped.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set -virtual-pixel Transparent \
       -affine "`affine_transform  75,0 0,0 0,75   75,75 0,75 0,0`" -transform \
       -crop 75x75+0+0\! -background white -flatten koala_affine_transform.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="koala_affine_transform.gif"
     ><IMG SRC="koala_affine_transform.gif"    WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By giving the "<CODE><A HREF="../../scripts/affine_transform"
>affine_transform</A></CODE>" script two sets of three coordinates, we can
magick the movement of these points, into the correct affine mapping to
transform the whole image to match that movement. </P>

Unlike the previous script this one can flip, scale and shear images, however
it is not so useful for rotating images, as you can not give it a direct angle
of rotation. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  This can also be directly achieved much more efficiently and directly using
  the 3 control point '<CODE><A HREF="../#affine" >Affine</A></CODE>'
  distortion method. </P>

  And just like before that distortion method was actually a direct
  development from that script into the <A HREF="../#distort" >Generalized
  Distort Operator</A>.  However since its implementtation, the coordinate
  entry has been reorder slightly differently.  See <A
  HREF="../#control_points" >Distortions Using Control Points</A>. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="affine_other"></A>
<H3>Other Affine Transform Methods </H3>

As I explained at the start of the previous section, an affine matrix is a
linear equation that maps a point on the original image to a new position on
the destination image. </P>

That is, given the affine matrix argument...

<PRE>     -affine  sx,rx,ry,sy,tx,ty</PRE>

Actually equates to the mathematical formula...

<PRE>   ( i, j ) = ( x * sx + y * ry + tx,   x * rx + y * sy + ty  )</PRE>

That is, given a point, <CODE>x,y</CODE> on the starting image, that point is
remapped to the position <CODE>i,j</CODE> on the destination image.  Quite
straight forward really. </P>

For example suppose we have this simple image of a stylized spaceship, drawn
using various lines form one point to the next.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:skyblue -fill red -stroke black \
          -draw 'path "M 15,5 20,35 25,5 Z M 10,25 30,25" ' \
          spaceship.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship.gif"
     ><IMG SRC="spaceship.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

This is basically a very simple '<A HREF="../../draw/#mvg" >vector graphic</A>',
and has very well defined points on the original image. </P>

The by using a relatively simple affine matrix such as "<CODE>-affine
'1,-1,1,1,15,55'</CODE>" we can map each of the coordinates for our space ship
to a new position. </P>

For example lets do the affine calculations to the first drawn coordinate of
the above spaceship.
<TABLE ALIGN=center><TR><TD>
<PRE>      x,y  =  15,5
      i,j  =   x*sx + y*ry + tx,   x*rx + y*sy + ty
           => 15*1 + 5*1  + 15,   15*-1 + 5*1  + 55     => 35,45  </PRE>
</TD></TR></TABLE>
That is, the coordinate <CODE>15,5</CODE> will be mapped by the affine
transform to position <CODE>35,45</CODE>. </P>

After converting each coordinate in out original vector image, we can now
now redraw the space ship in its new transformed position...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:skyblue -fill red -stroke black \
          -draw 'path "M 35,45 70,70 45,35 Z M 50,70 70,50" ' \
          spaceship_mapped.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship_mapped.gif"
     ><IMG SRC="spaceship_mapped.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

Actually IM can do this mapping of vector coordinates for you...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 80x80 xc:skyblue -fill red -stroke black \
          -draw 'affine 1,-1,1,1,15,55
                 path "M 15,5 20,35 25,5 z M 10,25 30,25" ' \
          spaceship_mapped_2.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship_mapped_2.gif"
     ><IMG SRC="spaceship_mapped_2.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

As the above shows, a vector image can be transformed very simply by just
mapping the coordinates of the various line segments and drawing the image in
a new position.  Not only that but it also automatically scaled the line
widths as appropriate, which we forgot to do in the hand calculated example.
</P>

See <A HREF="../../draw/#affine" >Affine Warping</A> for more information on
using an affine matrix with drawn vector images.  </P>

Now lets get IM transform the original raster image we originally created of
the spaceship.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick spaceship.gif   -affine 1,-1,1,1,15,55 -transform \
          -crop 80x80+0+0\! -background skyblue -flatten \
          spaceship_transformed.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship_transformed.gif"
     ><IMG SRC="spaceship_transformed.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

As you can see the result is not nearly as clean looking as a vector image
transformation, but then that is one of the major drawbacks of using raster
images. However other than that, the result of the transformation is correct.
</P>

What is not shown above, is what IM actually did internally to transform
a raster image. Which is the subject of the next section. </P>


<A NAME="affine_diy"></A>
<H3>Affine Transform DIY  <FONT SIZE=-1>(the internal details)</FONT></H3>

This is what IM actually goes thru internally to do an affine transformation.
</P>

First we need to figure out the where the transform is going to map the image,
so a new image can be created with the right size and offset.  Now due to the
transformation this final location is most likely nowhere near the same
position as the original source image. But it needs to be done so as to
preserve all parts of the image during the transformation, while using the
smallest image size posible to contain that result.  </P>

To calculate the size and offset of the destination, we first use the affine
transformation on each of the four corners of the source image, to find the
size and location of the destination image. </P>

Now our test image has no 'virtual canvas offset', so the coordinates of the
four corners are: quite simply <CODE>0,0</CODE>, <CODE>80,0</CODE>,
<CODE>0,80</CODE>, and <CODE>80,80</CODE>.   If our image did have a starting
offset, then we would just add the virtual offset to the actual width and
height of our image to calculate the actual location of the corners of the
source image. </P>

Processing these coordinates using the affine mapping we get...
<TABLE ALIGN=center CELLPADDING=0>
<TR><TH><FONT SIZE=-1>Source Corners <TH ROWSPAN=5> &nbsp;
    <IMG SRC="../../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
    &nbsp; <TH><FONT SIZE=-1>Transformed
<TR><TD ALIGN=center><FONT SIZE=-2> 0,0   <TD ALIGN=center><FONT SIZE=-2> 15,55
<TR><TD ALIGN=center><FONT SIZE=-2> 80,0  <TD ALIGN=center><FONT SIZE=-2> 95,-25
<TR><TD ALIGN=center><FONT SIZE=-2> 0,80  <TD ALIGN=center><FONT SIZE=-2> 95,135
<TR><TD ALIGN=center><FONT SIZE=-2> 80,80 <TD ALIGN=center><FONT SIZE=-2> 175,55
</TABLE></P>

Our destination image will thus need to be just large enough to hold each of
these four corners, with the results rounded up or down to the nearest whole
integer.  The 'virtual offset' will be the two smallest <CODE>x</CODE> and
<CODE>y</CODE> values or <CODE>+15-25</CODE>, while the width and height of
the destination image needs to be <CODE>160x160</CODE>.  Note that the size of
the resultin virtual canvas is irrelevant, and can be left to IM or the user
to determine, set, or ignore. </P>

In summary, our <CODE>80x80</CODE> image with a <CODE>+0+0</CODE> offset will
map completely into a <CODE>160x160</CODE> image with a <CODE>+15-25</CODE>
offset.  </P>

So we now know where the image will be after the transform we need to map the
pixels from the source to the destination image.  This however is not straight
forward, as it is explained in <A HREF="../#summary" >Distortion Summary</A>.
</P>

That is, rather than mapping each individual source pixel to the destination,
we lookup the color of each destination pixel in the source.  However to do
that we need to invert the affine transformation to map the destination to the
source image. </P>

But reversing a matrix is not simple and involves some very heavy mathematics.
Fortunately due to the nature of affine matrices, the inverse is also an
affine matrix, and the mathematics becomes greatly simplified. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD WIDTH=100%><FONT SIZE=-1><PRE><I
>From IM code "draw.c" here is a simple Affine Matrix Inverter</I>
  det = sx*sy - rx*ry;
  inverse_sx  =  sy/det;
  inverse_rx  = -rx/det;
  inverse_ry  = -ry/det;
  inverse_sy  =  sx/det;    # yes, the next bit uses the just calculated values
  inverse_tx  = -tx*inverse_sx - ty*inverse_ry;
  inverse_ty  = -tx*inverse_rx - ty*inverse_sy;</PRE
></FONT></TD></TR></TABLE></P>

As such the reverse of the affine matrix '<CODE>1,1,-1,1,15,55</CODE>' is
'<CODE>0.5,0.5,-0.5,0.5,20,-35</CODE>'.  Thus producing an "<A
HREF="../../option_link.cgi?fx" ><CODE>-fx</CODE></A>" expression of...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
              xx = 0.5*i -0.5*j +20; \
              yy = 0.5*i +0.5*j -35; \
</samp></pre></TD></TR></TABLE>
</DIV></P>

However the <CODE>i,j</CODE> pixel location used by "<A
HREF="../../option_link.cgi?fx" ><CODE>-fx</CODE></A>" does not take into account
the virtual offset we previously calculated for the destination image, or any
virtual offset that may be present in the source image.  As such the FX
variables <CODE>i,j</CODE> first needs to have the destination images offset
added to them, then transformed, and the source images offset
subtracted, to produce the source images <CODE>x,y</CODE> location. </P>

Here a complete DIY affine transformation.  Note how the destination image is
created separately to the source image, using the calculated size and offset
needed. Also that the source image is now the second or '<CODE>v</CODE>' image
in the FX expression for the pixel color lookup.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick spaceship.gif \
          -size 160x160 -page +15-25  xc:  +swap \
          -alpha set -virtual-pixel transparent -channel RGBA \
          -fx 'ii = i + 15;   jj = j - 25;
               xx = 0.5*ii -0.5*jj +20;
               yy = 0.5*ii +0.5*jj -35;
               xx = xx - 0;   yy = yy - 0;   v.p{xx,yy}' \
          spaceship_diy.png
</samp></pre></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As the resulting image has a negative offset I needed to use the PNG
  format to preserve that offset, as well as the semi-transparent edge
  pixels.  Also I have not shown the results of the above transform
  directly, as many browsers get confused by a PNG images containing a
  negative offset.
</I></FONT></TD></TR></TABLE></P>

As we can't directly display the results, here is the result if we do a
standard <A HREF="../../crop/#crop_viewport" >viewport crop</A> of the
transformed image using just the area of our original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick spaceship_diy.png \
          -crop 80x80+0+0\! -background none  -flatten \
          spaceship_diy_port.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship_diy_port.png"
     ><IMG SRC="spaceship_diy_port.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE>

And so you can see the total result of the transformation, here is a larger
overview <A HREF="../../crop/#crop_viewport" >viewport crop</A> of the virtual
canvas surrounding our resulting image.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick spaceship_diy.png \
          -compose copy -bordercolor blue -border 1x1 -repage -1-1\! \
          -compose over -crop 200x200-10-50\! -background none -flatten \
          -draw " fill none  stroke red path 'M 0,50 20,50 M 10,40 10,60' \
                 stroke green path 'M 9,49 9,130 90,130 90,49 Z'" \
          -trim +repage  spaceship_diy_view.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="spaceship_diy_view.gif"
     ><IMG SRC="spaceship_diy_view.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

To show the relative positions of the result, I added a blue border around the
result, and a red cross marking the <CODE>0,0</CODE> origin of the virtual
canvas.  I also drew a green box around the location of the original source
image before it was transformed. This box is typically the normal area in
which a <A HREF="../../crop/#crop_viewport" >viewport crop</A> is taken (see
previous example directly using the builtin affine transformation), rather
than the larger overview of the virtual canvas exampled here.  </P>

As you can see none of the image data was lost by this transformation,
including the images final size and location on a larger 'virtual canvas'.
</P>

Actually both of the pre- and post- image offsets can be merged into the
affine matrix translation component.  The source image offset can be just
directly subtracted, though the destination image component will need to be
translated before it is added to the final affine matrix transformation
expression.

<PRE>
       tx =  sx * dest_off.x + ry * dest_off.y + tx  - src_off.x
       ty =  rx * dest_off.x + sy * dest_off.y + ty  - src_off.y
</PRE>

In our case
<PRE>
       tx =  .5 * +15  -.5 * -25  +20 - 0   =>  40
       ty =  .5 * +15  +.5 * -25  -35 - 0   => -40
</PRE>
The result is a simplified and more direct image to image affine
transformation, with the images virtual offsets included as part of the
transform, as well as a standard crop to original image view.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 WIDTH=100% bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 160x160 -page +15-25  xc: +page  spaceship.gif \
          -alpha set -virtual-pixel transparent -channel RGBA \
          -fx 'xx = 0.5*i -0.5*j +40;
               yy = 0.5*i +0.5*j -40; v.p{xx,yy}' \
          spaceship_diy_2.png

  magick spaceship_diy_2.png \
          -crop 80x80+0+0\! -background none  -flatten \
          spaceship_diy_2_port.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="spaceship_diy_2_port.png"
     ><IMG SRC="spaceship_diy_2_port.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 1 July 2007 (from distortion page above) <BR>
Updated: 10 October 2009 <BR>
Author: <A HREF="http://www.ict.griffith.edu.au/anthony/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/distorts/affine/</CODE>
</ADDRESS></BODY></HTML>
