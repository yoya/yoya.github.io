<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Distorting -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/distorts/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Distorting Images</h1>
        <div>
          <b>Index</b><br>
          <table cellspacing="0">
            <tr valign="top">
              <td colspan="2">
                <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
              </td>
            </tr>
            <tr valign="top">
              <td>
                <dl>
                  <dd>
                    <a href="#summary"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> General Distortion Techniques</a>
                    <ul>
                      <li>
                        <a href="#forward_mapping">Forward or Direct Pixel Mapping</a>
                      </li>
                      <li>
                        <a href="#mapping">Reversed Pixel Mapping</a>
                      </li>
                      <li>
                        <a href="#lookup">Interpolated Pixel Lookup</a>
                      </li>
                      <li>
                        <a href="#super_sample">Super-Sampling, Improved Results</a>
                      </li>
                      <li>
                        <a href="#area_resample">Area Resampling, the next step</a>
                      </li>
                      <li>
                        <a href="#area_vs_super">Area Sampling vs Super Sampling</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>&nbsp;</dd>
                  <dd>
                    <a href="affine/"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Affine Matrix Transforms</a> (separate sub-directory)
                  </dd>
                  <dd>&nbsp;</dd>
                  <dd>
                    <a href="#distort"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Generalized Distortion Operator</a>
                    <ul>
                      <li>
                        <a href="#distort_options">Distort Options, Controls, and Settings</a>
                      </li>
                      <li>
                        <a href="#distort_bestfit">Best Fit (+distort) Option</a>
                      </li>
                      <li>
                        <a href="#distort_filter">Image Filters and Color Determination</a>
                        <dl>
                          <dd><font size="-1"><a href="#distort_virtual">Virtual Pixels and Tiling</a><br>
                          <a href="#distort_invalid">Invalid Distortion Pixels</a><br>
                          <a href="#distort_ewa">EWA Resampling and Filters</a><br>
                          <a href="#distort_failure">Resampling Failure</a><br>
                          <a href="#distort_interpolate">Interpolated Color Lookup</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#distort_verbose">Verbose Distortion Summary</a>
                        <dl>
                          <dd><font size="-1"><a href="#distort_noop">No-Op Distortions</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#distort_viewport">Viewport, Where Distort Looks</a>
                        <dl>
                          <dd><font size="-1"><a href="#centered_square">Centered Square Crop</a><br>
                          <a href="#aspect_ratio_crop">Aspect Ratio Crop</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#distort_scale">Output Scaling, and Super-Sampling</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>&nbsp;</dd>
                  <dd>
                    <a href="#methods"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Introduction to Distortion Methods</a><br>
                    &nbsp;
                    <ul>
                      <li>
                        <a href="#srt"><b>SRT</b> Distortion</a> <font size="-1">(scale,rotate,translate)</font><br>
                        &nbsp;
                      </li>
                      <li>
                        <a href="#rotate_methods">Methods of Rotating Images</a>
                      </li>
                      <li>
                        <a href="#control_points">Distortions Using Control Points</a>
                      </li>
                      <li>
                        <a href="#control_coordinates">Image Coordinates vs Pixel Coordinates</a>
                      </li>
                      <li>
                        <a href="#control_escapes">Control Points using Percent Escapes</a>
                      </li>
                      <li>
                        <a href="#control_leastsq">Control Point Least Squares Fit</a>
                      </li>
                      <li>
                        <a href="#control_files">Control Point Files</a> <!--<LI><A HREF="#image_registration"
        >Image Registration</A> -->
                      </li>
                    </ul>
                  </dd>
                </dl>
              </td>
              <td>
                <dl>
                  <dd>
                    <a href="#affine"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Affine (Three Point) Distortion Methods</a>
                    <ul>
                      <li>
                        <a href="#affine"><b>Affine</b> Distortion</a>
                      </li>
                      <li>
                        <a href="#affine_projection"><b>Affine Projection</b> Distortion</a>
                      </li>
                      <li>
                        <a href="#affine_examples">Affine Distortion Examples</a>
                        <dl>
                          <dd><font size="-1"><a href="#affine_tile">Affine Tiling</a><br>
                          <a href="#cube3d">3D Cubes, using Affine Layering</a><br>
                          <a href="#shadow3d">3D Shadows, using Affine Shears</a><br>
                          <a href="#shadow3d_var">3D Shadows, using Perspective</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#resize"><b>Resize</b> Distortion</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#perspective"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Four Point Distortion Methods</a>
                    <ul>
                      <li>
                        <a href="#perspective"><b>Perspective</b> Distortion</a>
                        <dl>
                          <dd><font size="-1"><a href="#horizon">Viewing Distant Horizons</a><br>
                          <a href="#box3d">3D Boxes, using Perspective Layering</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#perspective_projection"><b>Perspective Projection</b> Distortion</a>
                      </li>
                      <li>
                        <a href="#perspective_internals">Perspective Internals</a>
                      </li>
                      <li>
                        <a href="#bilinear">Bilinear Distortion Metjods</a>
                        <dl>
                          <dd><font size="-1"><a href="#bilinear_forward"><b>BilinearForward</b></a><br>
                          <a href="#bilinear_reverse"><b>BilinearReverse</b></a><br>
                          <a href="#bilinear_tiling">Bilinear Tiling</a><br>
                          <a href="#bilinear_internals">Bilinear Internals</a></font></dd>
                        </dl>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#polynomial"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> <b>Polynomial</b> Distortion</a>
                  </dd>
                  <dd>
                    <a href="#circular_distorts"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Circular and Radial Distortion Methods</a>
                    <ul>
                      <li>
                        <a href="#arc"><b>Arc</b> Distortion</a> <font size="-1">(images in circular arcs)</font>
                        <dl>
                          <dd><font size="-1"><a href="#arc_rings">Arc into Full Circle Rings</a><br>
                          <a href="#arc_examples">Arc Distortion Examples</a><br>
                          <a href="#arc_center">Arc, Center Point Placement</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#polar"><b>Polar</b> Distortion</a> <font size="-1">(full circle distort)</font>
                      </li>
                      <li>
                        <a href="#depolar"><b>DePolar</b> Distortion</a> <font size="-1">(polar to cartesian)</font>
                      </li>
                      <li>
                        <a href="#polar_tricks">Depolar-Polar&nbsp; Cycle Technique</a>
                        <dl>
                          <dd><font size="-1"><a href="#polar_problems">Depolar-Polar&nbsp;Problem</a><br>
                          <a href="#polar_rotation">Polar&nbsp;Rotation</a><br>
                          <a href="#rotation_blur">Rotational&nbsp;Blur</a><br>
                          <a href="#radial_streaks">Radial&nbsp;Streaks</a></font></dd>
                        </dl>
                      </li>
                      <li>
                        <a href="#barrel"><b>Barrel</b> Distortion</a> <font size="-1">(lens correction)</font>
                      </li>
                      <li>
                        <a href="#barrelinverse"><b>BarrelInverse</b> Distortion</a> <font size="-1">(alternative barrel)</font>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#projective_distorts"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Projective Distortions</a>
                    <ul>
                      <li>
                        <a href="#cylinder2plane">Cylinder 2 Plane</a>
                      </li>
                      <li>
                        <a href="#plane2cylinder">Plane 2 Cylinder</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#freeform_distorts"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Multi-Point and Freeform Distorts</a>
                    <ul>
                      <li>
                        <a href="#shepards"><b>Shepards</b> Distortion</a> <font size="-1">(taffy pulling!)</font>
                        <dl>
                          <dd><font size="-1"><a href="#shepards_rotation">Shepards and Image Rotations</a><br>
                          <a href="#shepards_power">Shedard's Power Factor</a><br>
                          <a href="#shepards_summary">Shepards Summary</a></font></dd>
                        </dl>
                      </li>
                    </ul>
                  </dd>
                </dl>
              </td>
            </tr>
          </table>Having looked at the simple set of built-in image wrapping and distortion operators IM has provided since its early days, here we go deeper and look at the internal mechanics and more complex mathematical distortions of images. From this deeper understanding, we then looks at a more generalize image distortion operator. This includes distortions, from complex rotations, scaling and shearing, to perspective or 3D distortions, to warping to and from circular arcs, camera lens distortions, and finally to more general morph-like distortions.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="summary" id="summary"></a>
          <h2>General Distortion Techniques</h2>Now that we have been introduce to the simple distortion operators that IM provides, lets take a step back and look at the nitty-gritty, and see how image distortions actually work, and how you can improve the way you use them. Later we'll go forward to much more complex ways of distortion images, including methods that are not directly built into ImageMagick. There are only a few basic ways an image processor can distort images. The <a href="../warping/#simple">Simple Distortion</a> operators for example are achieved by <b>Pixel Swapping</b>. That is, individual pixels or even whole rows and columns of pixels are just swapped around to <a href="../warping/#flip">Flip</a>, <a href="../warping/#roll">Roll</a>, <a href="../warping/#transpose">Transpose</a> and even <a href="../warping/#rect_rotate">Rectangular Rotates</a> of images. No color changes are made, and the number of pixels remains the same. The next method of distorting images is by <b>Shifting or Shearing</b> the columns and rows of pixels either horizontally or vertically, such as what IM does with <a href="../warping/#shear">Image Shearing</a> and the <a href="../warping/#wave">Wave Distortion</a> above. The shears in turn providing one method to <a href="../warping/#rotate">Rotate Images</a> by any given angle, in a manner that should be quite fast. However pixel shifting methods are limited to those basic distortions. It can not scale an image to a different size for example. You also have very little control over the handling of areas in the resulting image that was not covered by the original source image. In the above mentioned functions IM just sets the missing areas to the current background color. To be able to distort images in a much more general way you need to use a more general distortion technique known as <b><a href="#mapping">Reverse Pixel Mapping</a></b>. For example this method is used by the more complex <a href="../warping/#circular">Circular Distortions</a> such as <a href="../warping/#implode">Imploding</a> and <a href="../warping/#swirl">Swirling</a> images. <a name="forward_mapping" id="forward_mapping"></a>
          <h3>Forward or Direct Pixel Mapping</h3>The first thing people think of when attempting to distort an image is to just take each pixel in the source image and move it directly to its new location in the destination image. In fact this is sort of what actually happens for <a href="../warping/#simple">Simple Distorts</a>, <a href="../crop/#crop">Image Cropping</a> and even for distorting Vector Images. Each pixel (or coordinate) is is just moved to its new position in the final image. Unfortunately this has problems when you try to do this for anything but a simple distortion. For example, here I take an Enumerated Pixel list of a small image, and just change the location of each pixel, so as to rotate it to its new location.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="" image="koala_rotated_direct.gif" err="/dev/null">
  # Rotate by 17 degrees -- get the Sine and Cosine of this angle
  sin=`magick xc: -format "%[fx:sin( 17 *pi/180)]" info:`
  cos=`magick xc: -format "%[fx:cos( 17 *pi/180)]" info:`

  # For each Pixel, rotate that pixels coordinates
  magick koala.gif  txt:- |  sed '2,$ s/,/:/' |\
    gawk -F: 'NR == 1 { print }
              NR &gt; 1 {  x = $1-32;    y = $2-32;
                        nx = int( c*x - s*y + 32 );
                        ny = int( s*x + c*y + 32 );
                        printf( "%d,%d: %s\n", nx, ny, $3 );
              }' s=$sin c=$cos - |\
      magick -background black  txt:-   koala_rotated_direct.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_rotated_direct.gif"><img src="koala_rotated_direct.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The distortion is a simple rotation of just 17 degrees, but the results are not very nice at all. First of all each new pixel location is a floating point value, but pixels can only exist in an integer grid, so the above simply junks the non-integer fraction of the results. The second problem is that the result is full of holes where no pixel landed. Which brings up the third problem. You many not see it but for every hole in the resulting image, you would also find another location where two pixels were placed. That is, you have multiple pixels at the same location. What pixel value should you use? In the above IM just used the last pixel defined for a location. In other words the resulting image is incomplete, where each pixel in the destination is not exactly where it should be, and could have multiple pixels, or no pixel at all. These are serious problems, and one that cannot be easily solved when forward mapping pixels from the source image directly to the destination image. That is, not to say that it cannot work, and many research papers talk about using a technique known as '<b>splatting</b>'. Basically they take each input pixel, transform its location, and then draw it with appropriate spreading and mixing of pixel colors in the new location. This technique is especially useful when dealing with 3-D digitization of real world objects. Here you have a 'cloud' of known color surface points. Any point visible to the user is simple 'splatted' onto the screen so as to make a final image. Have enough points and the image will look complete. With interactive 3D controls, it works very well, and is very fast. Splatting 3-dimensional points however is beyond IM's scope of handling 2-D raster images. <a name="mapping" id="mapping"></a>
          <h3>Reverse Pixel Mapping</h3>Rather than trying to map pixels into the final image, you can map the coordinate of each pixel in the destination image to the corresponding location in the source image, and from the source image lookup the color that pixel should contain. This is known as a <i>Reverse Pixel Mapping</i> and is what just about every image distortion program does. As each and every destination image pixel is processed, we can be sure that every pixel in the destination gets one and only one color. So as long as we can figure out the 'source' location for each destination pixel, we can distort a source image to the destination image using any mathematical formula you can imagine.
          <div align="center"><img src="../img_diagrams/mapping.gif" width="335" height="136" align="middle" vspace="2" hspace="5" alt="[Diagram]"></div>In Summary, a distortion mapping (reverse mapping) does the following.
          <table align="center">
            <tr>
              <td>
                <pre>
For each pixel (I,J) in the destination or output image
   Map the I,J pixel position to a X,Y pixel position in the original image
   Look up the Color of the original image at position X,Y
       Using color interpolation, work out the appropriate color.
       Or the virtual-pixel setting, if it misses the actual source image.
   Set the destination images color for pixel I,J
</pre>
              </td>
            </tr>
          </table>Note that I used the variable names '<code>I,J</code>' and '<code>X,Y</code>' in the above as these variables map into the variables name that you would typically use in the <a href="../transform/#fx">FX DIY Operator</a>. For example, here I simulate the same 17 degree rotation I attempted before, but this time use the "<code><a href="../option_link.cgi?fx">-fx</a></code>" operator to look up the nearest pixel to that location in the source image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="" image="koala_rotated_fx.gif">
  # Rotate by 17 degrees -- get the Sine and Cosine of this angle
  sin=`magick xc: -format "%[fx:sin( 17 *pi/180)]" info:`
  cos=`magick xc: -format "%[fx:cos( 17 *pi/180)]" info:`
  cx=37; cy=37;   # center of rotation

  magick -size 75x75 xc:       koala.gif  \
          -virtual-pixel Black  -interpolate NearestNeighbor \
          -fx "ii = i - $cx;   jj = j - $cy;
               xx =  $cos*ii +$sin*jj + $cx;
               yy = -$sin*ii +$cos*jj + $cy;
               v.p{xx,yy}" \
          koala_rotated_fx.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_rotated_fx.gif"><img src="koala_rotated_fx.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can get more detail about the above DIY example in the sub-section on <a href="affine/#affine_diy">DIY Affine Distortion Mapping</a>. As you can see we no longer have 'holes' in our image as a color is looked up for each and every pixel in the destination. It still does not look very good, but that is a matter of adjusting exactly what color should be placed into each pixel. That is, Reverse Pixel Mapping does not generate either holes, or overlapping pixels. Each pixel has a properly defined color producing a complete image.<br>
          The distinction between forward and reverse mapping is important as most mathematical transformations are defined as forward mappings, mapping a single source (X,Y) position to a destination (I,J) position. And indeed a 'forward mapping' works well for vector graphics, and drawing lines where you can just map the ends of the line and draw it. This is especially true for any linear transformation, such as rotations, where lines remain straight. It is in fact what is done for all vector based languages such as such as postscript and SVG. But for a general raster image, you must use a 'reverse mapping' to distort the image, so that you can be certain that you 'fill in' all the pixels of the destination image. For example if you look the mathematics that was used to map the coordinates in the above two cases, you will find they look almost exactly the same. The reverse mapping of a 'rotate' is another 'rotate', just in the opposite direction. If you look closely you will see that the 'sin' constant is negated to the forward mapped version, and that is enough to reverse the direction of rotation. This detail is important and critical. The problem is not all forward mapping transforms, work well as a reversed transform. Some forward mappings in fact have no simple direct reverse mappings. This is not to say it can't be done, just not simply. On the other hand some image transformations work very well as a reverse mapping, but do not have simple forward mappings. So using reverse mapping method is both good and bad in mathematical terms.<br>
          As an FYI here is the faster equivalent to the above using a <a href="#SRT">General Distortion, SRT</a> method that does the exact same rotation of the image as was done above, and producing the exact same result, just faster. Again the color lookup is restricted to just the color of the closest pixel to the mapped position by using 'point' interpolation. This means that no new colors are added to the image (other than when we 'missed' the source image), but you also get severe aliasing effects.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -virtual-pixel Black  -interpolate NearestNeighbor \
          -filter point    -distort SRT 17    koala_rotated_srt.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_rotated_srt.gif"><img src="koala_rotated_srt.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE koala_rotated_fx.gif \
                          koala_rotated_srt.gif null: 2>&1 |
        sed 's/ .*//'`" -gt '0' ] && echo >&2 \
    "ASSERTION FAILURE: FX and SRT equivalent methods, did not match"
</CODE> -->
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>For an alternative discussion of distortion transforms, see <a href="http://www.leptonica.com/affine.html#AFFINE-IMPLEMENTATION">Leptonica, Affine Implementation</a> and specifically its discussion of 'point-wise' method. The other method, 'sequential', is essentially how IM used to implement its <a href="../warping/#rotate">Rotate</a> and <a href="../warping/#shear">Shear</a> distortion operators.</i></font></td>
            </tr>
          </table><a href="names"></a> <b>What's in a name?</b> During my study I found that there is no real clear naming of this image processing method. The actual algorithmic process is known a '<i>Reverse Pixel Mapping</i>', while the use of mathematical equations is known as a '<i>Geometric Transformation</i>'. If the distortion is controlled by the movement of various control points, it often known a '<i>Image Warping</i>' or '<i>Rubber Sheeting</i>'. The process of defining specific points, usually to find equivalent points between two or more images is known as '<i>Image Registration</i>'. Images can also be subdivided into smaller simpler units which are individually distorted using a technique called '<i>Gridding</i>' (quadrilaterals) and '<i>Triangular Meshing</i>' (triangles). By using small incremental distortions with blending of colors from two images you can generate animated '<i>Image Morphs</i>' such as you see in movies and music videos. If a pre-prepared mapping image is used rather than a, on the fly, mathematical lookup, you get '<i>Absolute Distortion Mapping</i>' if the lookup is a relative displacement (50% gray being no displacement or change of the lookup coordinate) you get '<i>Displacement Mapping</i>'. If the mapping just slightly modifies color (shading) rather than lookup distortions, you get the related but different '<i>Bump Surface Mapping</i>'. In the 3d modeling, and in 3d computer games, the same techniques are also used to give some type of colored pattern to flat and curved surfaces in a method known as '<i>Texture Mapping</i>'. This can involve sub-dividing images into grids and meshes that approach a single pixel. Then you have viewing of an object that is defined in terms of millions of single points using a technique called '<i>Point Splatting</i>', though that is typically applied using a forward mapping distortion. All the above are very closely related, and most basically involve the look up of a pixels color based on mapping a final destination coordinate, to the source image (or object). In other words mapping <i>Destination to Source</i>. What term should be used... Take your pick. <a name="lookup" id="lookup"></a>
          <h3>Pixel Color Lookup</h3>There are still a few problems with the above <a href="#mapping">Reverse Pixel Mapping</a> technique. First of all is that when mapping a pixel from a fixed integer position in the destination, you can end up with a non-integer position in the source image. That is, a location that falls somewhere between the individual pixels on the source image. To determine what color should be returned a process called <a href="../misc/#interpolation">Interpolation</a> is used to determine the final color for that real position by mixing the colors of the surrounding pixels. The <a href="../misc/#interpolation">Interpolation</a> setting will also handle the case when a part of a distorted image becomes 'stretched out' so that a single source pixel becomes smeared over a large area of the destination image. However the opposite is not handled very well by a simple interpolation method. And that requires other techniques which we will look at below. For example, here we again rotate our koala, but this time use a "<code><a href="../option_link.cgi?interpolate">-interpolate</a> <a href="../misc/#mesh">Mesh</a></code>" setting to mix the four nearby pixels so as to produce a better, more correct, color from the lookup.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -virtual-pixel Black  -interpolate Mesh \
          -filter point    -distort SRT 17    koala_rotated_mesh.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_rotated_mesh.gif"><img src="koala_rotated_mesh.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see by using a simple merger of just the closest neighboring colors surrounding the non-integer lookup point, you can greatly improve the look of the distorted image. But there are other problems involved... For example what do you do when the mapped position 'misses' the source image completely. In this case, what color should be returned is determined by the <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting. This setting will pick a color, such as the nearest edge of the source image, pretend the source image is infinitely tiled (or mirror tiled) across the plain, or use some specific color such as 'white', 'black', or 'transparent' or the user defined background color. There is also the possibility that there is no mathematically valid coordinate for a specific destination position being mapped. For example the pixel looks into the 'sky' of a perspective 'plane' (See <a href="#horizon">Viewing Distant Horizons</a>), and thus does not even see the 'plane' in which the source image lies. In this case a <a href="../misc/#virtual-pixel">Virtual Pixel</a> is useless as it does 'hit' the source image plane in a N-dimensional space, and as such the destination pixel is completely invalid! In this case IM uses the current "<code><a href="../option_link.cgi?alpha">-alpha set</a></code>" setting for the pixel color. If it is a 'near-miss' IM will anti-alias this invalid color with a neighbouring colors of the image plane, if it knows how. It does for perspective distortions. <a name="super_sample" id="super_sample"></a>
          <h3>Super Sampling</h3>Interpolation works well for simple image distortions. But if part of the source image gets compressed into a much smaller area, each destination pixel could actually require a merging of a much larger area of the source image. Remember pixels are not really points, but represent a rectangular area of a real image. This means in some cases we really should be trying to compress a large area of the source image into a single destination pixel. When this happens a simple <a href="#lookup">Pixel Lookup</a> will fail, as it only looks up the color at a single 'point' in the source image (using the surrounding pixel neighbourhood), and does not merge and combine all the colors of the input image that may have to be compressed into that single pixel. The result of this is that a destination pixel could end up with an essentially random color from the source image, rather than an average of all the colors involved. This is not in itself bad, but when all the pixels in an area doe this you get images with seemingly random, isolated pixels, Moire effects, and aliased 'stair-casing' effects. Thin lines also start to look more like dotted and dashed lines (see examples for the <a href="../resize/#sample">Sample Operator</a>), or could disappear entirely. All these effects are known collectively as <a href="../filter/#aliasing">Aliasing Artefacts</a>. One solution to this to more color lookups from the source image, for each and every pixel in the destination, so as to try and determine a more correct color for each pixel in the destination image. The simplest solution is generally known as <b>super-sampling</b>, or <b>over-sampling</b>. See the <a href="http://en.wikipedia.org/wiki/Super-sampling">Wikipedia Entry on Super-Sampling</a>. By taking more samples from the source image, over the area that will map onto each destination pixel, the final color of that pixel will become a more accurate representation of distorted image at that point. The more color samples you make, the more accurate the final color will be, and a smoother more realistic look will be generated, though the slower the distortion becomes. Remember this technique only really improves the general look of the destination in areas where the source image becomes compressed by more than 50%. In areas where the distortion magnifies the source image, or keeps it about the same scale, a single <a href="../misc/#interpolation">Interpolated Look Up</a> of the source image look up will generally produce a good result with just one single lookup. In the <a href="../warping/#implode">Imploding Images</a> warping examples (and many other examples throughout IM Examples), I touched briefly on the simplest method of 'super-sampling'. Basically enlarging the size of the output image (or in this case simply by enlarging the input image), and then performing the distortion. After the distortion is complete we then resize the image back to its normal size again, which merges all the extra 'samples' that was generated. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 94x94 xc:red -bordercolor white -border 3 \
          -virtual-pixel tile                -implode 4 \
          implode_tiled_box.gif
  magick -size 94x94 xc:red -bordercolor white -border 3 \
          -virtual-pixel tile  -resize 400%  -implode 4 -resize 25% \
          implode_tiled_ss.gif
</samp></pre>
                </td>
              </tr>
            </table>
            <table cellspacing="0" cellpadding="5" width="90%">
              <tr valign="top">
                <td align="center">
                  <a href="implode_tiled_box.gif"><img src="implode_tiled_box.gif" width="100" height="100" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a><br>
                  Normal Implosion of a Box Image
                </td>
                <td align="center">
                  <a href="implode_tiled_ss.gif"><img src="implode_tiled_ss.gif" width="100" height="100" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a><br>
                  Super Sampled Implosion
                </td>
              </tr>
            </table>
          </div>Of course rather than enlarging the input image, you could start with a higher quality (larger) source image, or generate one during some previous processing step. If one is available. This is especially useful when rotating text, which often has very fine detail that needs to be uniformly preserved to ensure a good high quality look in the final image. For examples of this see the <a href="../transform/#polaroid">Polaroid Transform</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As of IM v6.4.2-6, the <a href="#distort">General Distortion Operator</a>, can directly generate an enlarged output image, which you can scale (or resize) back down so as to merge and super-sample the resulting pixels. See <a href="#distort_scale">Distortion Scale Setting</a>, as well as the next example.</i></font></td>
            </tr>
          </table>This is only one method of <i>super sampling</i> (known as the 'grid' method), there are however many other variations on this method. Eventually these methods may be implemented more directly in ImageMagick, but for now simple enlargement and scaling of images work quite well, without any additional coding need. One final word of warning. Super-sampling is limited by the number of samples that was used for each pixel in the final image, and thus the amount of scaling used in the final resize. This determines the final 'quality' of the distorted image. But by using larger scaling factors, the distorted image will of course be much much slower to generate. But have even higher quality, has its limits. In the extreme, super-sampling will not handle any image distortion that involves infinities (such as in the center of an imploded image). In such cases a completely different technique is needed, such as one that is provided by <a href="#area_resample">Area Resampling</a> (see below). In summary, super-sampling can improve the look of images with only minor distortions, such as rotations, shears, affine, and simple perspective. But it has limits to the types of distortions that it can improve. <b>Adaptive Super-Sampling</b> The super-sampling technique can be expanded further. Rather than just using a fixed number of color lookups for each pixel, a check is made on either the distance between the lookups in the source image, or on how close the colors returned from a low level sampling, to see it should make more samples for that specific pixel. That is, the amount of super-sampling could be made responsive to needs of the distortion, without knowing anything about the specifics of the distortion itself. This is known as <i>Adaptive Super-Sampling</i>. This technique is actually very common in Ray Tracers, where it is next to impossible to determine just how complex the resulting image is at any specific point. In this case it is often restricted to the use of 'color differences' around the specific location, to determine when more samples are needed. if a pixel is very different to its neighbours, then more samples are used in that area to refine what is probably the edge of some 3 dimentional object.IM does not currently support adaptive super-sampling at this time. Though it is quite possible to add alternative sampling methods into the <a href="#distort">General Distortion Operator</a> (see below). It will require some functional rearrangement of the code, so may not be added anytime soon. <b>Super-Sampling Summary</b> The difficulty with super-sampling is in determining just how many 'point samples' is needed, and how those samples should be arranged with the sub-pixel bounds. Also what sort of 'weighting' should be applied. See the <a href="http://en.wikipedia.org/wiki/Super-sampling">Wikipedia Entry on Super-Sampling</a>. <a name="area_resample" id="area_resample"></a>
          <h3>Area Resampling, for better Distortions</h3>One of the best alternatives to super-sampling methods is <b>Area Re-sampling</b>. Rather than distorting a larger image and averaging the results by resizing, which is just taking and averaging more samples from the image, we actually determine exactly how many pixels from the source image should be merged together (based on the 'scale' of the distortion at that point) to generate each specific output pixel. That is, figure out a rough 'area' within the source image, each output pixel represents, and merge (filter) all the pixels in that area according to a resampling filter. In fact this is exactly what the ImageMagick <a href="../resize/">Resize Operator</a> (in reality a very specific type of image distortion) does to generate such good results. However for resize, you only need to calculate the scale of the area needing to be sampled for each pixel, once for the whole image. The area it needs to 'sample' is fixed size rectange (window) in the source image, making the re-sampling process easy, and providing a short-cut in the distortion process. When area re-sampling a distorted image, the area of pixel (window) to get samples from will not only change position, but also will change size. As such one pixel in the destination may only need to merge a few source image colors, or even just one single interpolated color lookup (such as in enlargments). While another pixel elsewhere in the destination image, may need to sample a very very large number of pixels to generate the correct final color. Close to infinities it may even have to incluce all the pixels in the source image as part of the the sampling process. Also the area that a destination pixel represents in the source image, may not be a simple square, circle, or even ellipse but may actually be a highly distorted shape, according to the distortion being used. Calculating and handling such awkward shapes can be very time consuming, or near impossible to achieve. <img src="../img_diagrams/ewa_mapping.gif" width="309" height="384" align="right" vspace="0" hspace="5" border="1" alt="[Diagram]"> Using an elliptical area of the source image to calculate colors for each destination pixel, is a method known as Elliptical Weighted Average (EWA) Re-sampling, and was outlined in the PDF research paper "<a href="http://www.cs.cmu.edu/~ph/texfund/texfund.pdf">Fundamentals of Texture Mapping and Image Warping</a>" by <i>Paul Heckbert</i> (who also wrote the 'zoom' program from which practically all image resize algorithms are derived). This was then used to define the new <a href="#distort">Generalized Distortion Operator</a> (see below). An ellipse is the perfect shape for either <a href="#affine">Affine Distortions</a> or <a href="#perspective">Perspective Distortions</a>. It is especially good for extreme scale reductions (see example below). And while not perfect for other distortions, it is generally a reasonable fit for many other distortions, such as <a href="#arc">Arc and Polar Distortions</a> (but not their reverse), as well a radial distortions like the <a href="barrel">Barrel Distortion</a>. But it is a poor fit for non-linear distortion mappings such as <a href="#depolar">De-Polar</a> and <a href="shepards">Shepards Distortion</a>, as such it is not used for these distortions. Super Sample does not have this shape problem as each 'sample' is reverse mapped onto the destination. So it becomes the better sampling method in such cases. But as mentioned it may not sample all the pixels needed, or even sample too many pixels. <a name="area_vs_super" id="area_vs_super"></a>
          <h3>Area Sampling vs Super Sampling</h3>Here are all three sampling methods IM currently provides, when applied to an extreme infinitely tiled perspective image. See <a href="#horizon">Viewing Distant Horizons</a> below for details, of this distortion.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  # input image:  special checkerboard with a gold outline.
  magick -size 90x90 pattern:checkerboard -normalize -fill none \
          -stroke gold -strokewidth 3 -draw 'rectangle 0,0 89,89' \
          -fill red        -draw 'color 20,20 floodfill' \
          -fill lime       -draw 'color 40,70 floodfill' \
          -fill dodgerblue -draw 'color 70,40 floodfill' \
          checks.png

  # Using Interpolated Lookup
  magick checks.png -filter point \
          -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile_point.png

  # Using Grid Super Sampling
  magick checks.png  -filter point  -set option:distort:scale 10 \
          -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          -scale 10%    horizon_tile_super.png

  # Using Area Resampling (default)
  magick checks.png       -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile.png
</samp></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5">
              <tr valign="top">
                <td align="center"><font size="-1"><a href="checks.png"><img src="checks.png" width="90" height="90" align="middle" vspace="0" hspace="20" border="1" alt="[IM Output]"></a><br>
                Check Image</font></td>
                <td><img src="../img_www/right.gif" width="20" height="20" vspace="45" alt="==&gt;"></td>
                <td align="center"><font size="-1"><a href="horizon_tile_point.png"><img src="horizon_tile_point.png" width="90" height="90" align="middle" vspace="0" hspace="20" border="1" alt="[IM Output]"></a><br>
                Interpolated<br>
                Lookup</font></td>
                <td align="center"><font size="-1"><a href="horizon_tile_super.png"><img src="horizon_tile_super.png" width="90" height="90" align="middle" vspace="0" hspace="20" border="1" alt="[IM Output]"></a><br>
                Super Sampling<br>
                x10</font></td>
                <td align="center"><font size="-1"><a href="horizon_tile.png"><img src="horizon_tile.png" width="90" height="90" align="middle" vspace="0" hspace="20" border="1" alt="[IM Output]"></a><br>
                Elliptical Weighted Area<br>
                (EWA) Resampling</font></td>
              </tr>
            </table>
          </div>All the images are exactly the same distortion, just using different 're-sampling' techniques. The last image in the above used the default EWA settings of the <a href="#distort">Generalized Distortion Operator</a>, and as you can see it produced an extremely high quality result. However it took 4.6 seconds to generate this image, Which is not too bad if a little slow (due to the unusual extremes involved). The first image has the default EWA resampling turned off by using a "<code><a href="../option_link.cgi?filter">-filter</a> point</code>" setting. This forces it to use <a href="#lookup">Direct Interpolated Lookup</a> for each pixel. As such this image was generated extremely fast in comparison (.51 seconds), but as you can see produces a horible result as 'minification' (downsampling) increases with 'distance'. The middle image is as the first image but with the distorted output image being enlarged by a factor of 10, before being scaled back (grid resampling) to match the other images. That is, more than 100 pixels were looked up and averaged together for each destination pixel, so as to <a href="#super_sample">Super Sample</a> the result. It is quite fast to generate (1.2 seconds), and while it improves the quality of the image in general, that improvement is limited. The ×10 used in the above example is very heavy, far exceeding the more typical 3 or 4 times scaling used for most super-sampling usage. The biggest difference between the results is that super-sampling only does a general improvement in quality uniformly over the whole image. As the distortion gets more sever it starts to break down. The result is the highly visible <a href="../filter/#artifacts">Resampling Artifacts</a> in the middle ground, and more specifically a line of server moire effects just before the horizon. The moire effect is caused when when the 10 samples across per pixel nearly matches the checker board pattern of the image, producing distorted color effects. On the other hand area-resampling concentrates more on the problem pixels closer to the horizon (where it spends almost all of its time), than on foreground pixels, where it does actually out perform super-sampling. Basically the above is a very extreme distortion, and the time EWA lookup takes is commensurate. More commonly it generates much better results than a single interpolated lookup, as it efficentally looks are every pixel involved, while not using too many samples is areas that don't need it, as super-sampling does. <b>In Summary...</b>Using a simple ellipse (EWA resampling) or a rectangle (Resize), to do 'area resampling' does produce good results, as all the source pixels involved in scaled, affine or perspective distortions, will be merged to produce the final color of an individual destination pixel. In cases of very non-linear distortions, such as in <a href="#depolar">DePolar Distorts</a>, or indeterminanate distortions, such as <a href="#shepards">Shepard's Distortion</a> or even ray-tracing, finding the correct 'Area' to resample all the source pixels needed, becomes prohibitive, and super-sampling is the best method to improve results. But for straight tiling, enlargements, and unscaled rotations, a very fast single 'point' interpolated lookup is probably all that is required, and may even be recommended to ensure perfect no-op (no change) distortions (see below). Remember however all resampling techniques are just methods for determining the color of each individual pixel. It is not actually part of the how an image is distorted, except with regard to the mapping of locations between destination and source (or visa-versa if posible).
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="distort" id="distort"></a>
          <h2>Generalized Distortion Operator</h2>With the generation of these examples, the ensuing discussions in the <a href="forum_link.cgi?f=1">IM Forums</a>, and multiple requests from users for easier and faster ways to do perspective and other distortions, a new operator was added to IM v6.3.5-1 to allow us to more easily add image distortions, of many different types. This <i>Generalized Distortion Operator</i> is called "<code><a href="../option_link.cgi?distort">-distort</a></code>", and you can see what distortion methods it has available on your IM version using "<code><a href="../option_link.cgi?list">-list</a> Distort</code>".
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -list distort
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The "<code><a href="../option_link.cgi?distort">-distort</a></code>" operator takes two arguments, one of the distortion <i>methods</i> as given by the above, and a second string argument consisting of comma or space separated list of floating point values, that is used to control the specific distortion method.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick ... -distort  {<i>method</i>} <!--
       --> "{<i>list_of_floating_point_values</i>}" ...
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The number floating point values given is however highly dependant on the distortion method being used, and their meanings also depend not only on the <i>method</i> chosen, but can also depend on the exact number of control points or attributes needed for a particular method. This is especially the case for the '<code><a href="#srt">Scale-Rotate-Translate</a></code>' (or '<code><a href="#srt">SRT</a></code>' for short) distortion, which really combines three separate '<code><a href="#affine">Affine</a></code>' distortions into a single distortion. Many distortion <i>methods</i> take a list of control points (in <a href="#control_coordinates">Image Coordinates</a>), and typically these are given as <i>pairs of coordinates</i> which control how the distortion is to modify the image. These pairs of coordinates are detailed more fully later in <a href="#control_points">Distortions Using Control Points</a>. <a name="distort_options" id="distort_options"></a>
          <h3>Distortion Options, Controls and Settings</h3><a name="distort_bestfit" id="distort_bestfit"></a>
          <h3>Best Fit +Distort Flag</h3>By default "<code><a href="../option_link.cgi?distort">-distort</a></code>" will usually distort the source image(s) into an image that is the same size as the original image. There are exceptions to this, such as the '<code><a href="#arc">Arc</a></code>' distortion (a polar mapping variant) where the input source image size really does not have much meaning in the distorted form of the image (see <a href="#arc">Arc Distortion</a> below for details). The other form of the operator, "<code><a href="../option_link.cgi?distort">+distort</a></code>" (Added to IM v6.3.5-7), will attempt resize the distorted image so it will contain the whole of the input image (if possible), much like what the older <a href="#rot_n_shear">Rotate and Shearing</a> operators do. However this particular 'mode' of operation also goes further and also sets the <a href="../basics/#page">Virtual Canvas Offset (page)</a> of the resulting image. This way you can later <a href="../layers/#merge">Layers Merge</a> this image onto another image, at the correct position according to your control points, using the appropriate <a href="../compose/">Alpha Composition</a> (see <a href="#cube3d">3d Cubes, using Affine Layering</a> as a basic example. Also (depending on the distortion method) a "<code><a href="../option_link.cgi?distort">+distort</a></code>" will attempt to take into account any existing <a href="../basics/#page">Virtual Canvas Offset</a> that may be present in the source image, and use it as part of the distortion process. See the notes about the individual disortion methods. As such you may need to make judicious use of the "<code><a href="../option_link.cgi?repage">+repage</a></code>" attribute setting operator to clear or adjust that offset <i>before</i> using the 'best-fit' "<code><a href="../option_link.cgi?distort">+distort</a></code>" form of the General Distortion Operator. You also may need to use it <i>after</i> if the virtual canvas and offset is not required. See also <a href="../crop/#crop_repage">Removing Canvas/Page Geometry</a>. The normal "<code><a href="../option_link.cgi?distort">-distort</a></code>" will just ignore any existing offset present in the source image in terms of the distortion itself, but will copy that offset unchanged to the distorted image. In Summary... Use "<code><a href="../option_link.cgi?distort">-distort</a></code>" to have results mapped into an image of the same size. And use "<code><a href="../option_link.cgi?distort">+distort</a></code>" to try and automatically set the output image size, BUT also use and generate Virtual Canvas Offsets (page attributes). Also see <a href="#distort_viewport">Distort Viewport</a> (below) if you want to override this general viewport selection, and exactly control of what size and what part of the distorted image you want to see in your results.<br>
          Note... The best-fit viewport generated by "<code><a href="../option_link.cgi?distort">+distort</a></code>" is 2 pixels larger than what users would typically expect. The reason is that these pixels contain semi-transparent pixels that result from the area resampling filter, and these pixels are vital to correct 'edge joining' and overlaying of the distorted image. Technically the number of pixels added should depend on the output scaling of <a href="../filter/#support">Resampling Filter Support</a>. That is, how much a pixel's area could 'spread' due to the resampling filter. However as the scaling of each pixel can be variable, calculation of the absolutely correct number of additional pixels needed is a very tricky matter, and usually not worth the effort. The 2 pixel added is thus a 'fudge', as distortions rarely enlarge images which causes pixels to 'spread' more. Also as most standard resampling filters has a support of 2 units, the addition of 2 pixels a reasonable one. Also as this addition is 'fixed' it allows users the option to simply <a href="../crop/">Crop Image Size</a> (in various ways), if that is their wish. The 2 pixel 'fudge' does become obviously too small when doing enlargments of images. But those are fairly rare distortions, and users can define there own <a href="#distort_viewport">Viewport</a> (see below) if this is a problem. The virtual offset of the distorted image on the virtual canvas, is adjusted to account for these 2 extra pixels, so the distorted image is correct for overlaying, though not for simple composition. But be warned that while <a href="../crop/#crop">Crop</a>, <a href="../crop/#trim">Trim</a> will preserve the layered image location, <a href="../crop/#shave">Shave</a>, and <a href="../crop/#chop">Chop</a>, will shift the layer image, relative to this offset.<br>
          <a name="distort_filter" id="distort_filter"></a>
          <h3>Distort Pixel Color Determination</h3>As discussed above in <a href="#mapping">Reversed Pixel Mapping</a> above, each point in the resulting image is determined by first mapping that pixels location in the destination image, to the equivalent (reverse distorted) location in the source image, according to the distortion method chosen. However the final color of the pixel is not so simple to determine, as it is effected by a large number of factors. <a name="distort_virtual" id="distort_virtual"></a>
          <h4>Virtual Pixels and Tiling</h4>The distortion mapped point may not hit the actual source image, but somewhere beside it, or even a lot way from the actual image. The solution to this is to pretend the source image surrounded by an 'infinite' or 'virtual' surface, which is defined by the current "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" setting. For details and examples of the effect of this setting see <a href="../misc/#virtual-pixel">Virtual Pixel</a> examples. This can be very useful for generating distorted, or even undistorted tile patterns of the source image. Techniques for this are shown in the <a href="../misc/#virtual-pixel">Virtual Pixel</a> section itself (undistorted) and in <a href="#affine_tile">Affine Tiling</a> and <a href="#horizon">View Distant Horizons</a> below. <a name="distort_invalid" id="distort_invalid"></a>
          <h4>Invalid Distortion Pixels</h4>Sometimes the distortion of a destination pixel does not even 'hit' the vitrual tiled image! This generally happens when you distort the image using some type of 3-dimensional space distortion method and the pixel 'vector' does not even hit the source plane in which the image lies. Basically the the result of the distortion becomes 'undefined' mathematically. In that case the color will be determined from the "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" setting. For example when you see 'sky' in a <a href="#perspective">Perspective Distortion</a> (for example see <a href="#horizon">View Distant Horizons</a>), the mathematics for determining the source image location became 'undefined' (actually it is defined, but it is not valid from an users forward viewing perspective). As such the "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" is output for the 'sky'. Actually the perspective distortion algorithm also manages to include some 'anti-aliasing' information for pixels close to the horizon, though that is uncommon for such situations. <a name="distort_ewa" id="distort_ewa"></a>
          <h4>EWA Resampling and Filters</h4>Once you know where a destination pixel 'hits' the source image, you need to determine the color to make the destination pixel, using the pixels near the 'hit' point in the source image. Normally the <a href="#distort">Distort Operator</a> will use the <a href="#area_resample">Area Resampling</a> method EWA (Elliptical Weighted Average) to average out a larger area of the source image to work out the right color of for this pixel. You can change the filter using by EWA resampling using the "<code><a href="../option_link.cgi?resize">-filter</a></code>" setting. See <a href="../filter/#filter">Resampling Filters</a>, and more specifically <a href="../filter/#cylindrical">Cylindrical Filters</a> for more details. Originally a <a href="../filter/#cyl_gaussian">Cylindrical Gaussian</a> filter was used for EWA resampling, as this was what was defined in the original research paper for EWA resampling. But this tends to produce very blurry result, though it also does not produce aliasing effects. This used to be the default filter, along with an implementation bug that caused extreme blurriness before that version (now fixed) From IM v6.6.5-0 after major discussions with Nicolas Robidoux, Professor of Mathematics at Laurentian University, the default filter for image distortions was replaced with the '<code><b>Robidoux</b></code>' filter, which is a very 'Mitchell-like' cubic filter, designed specifically for EWA resampling. See <a href="../filter/#cylindrical">Cylindrical Filters</a>, for information on this and other cylindrical filters. Note however that any underlying Windowed Sinc filter function is replaced by the more circular Windowed Jinc filter function. As such selecting a 'Lanczos' filter will return a "Jinc windowed Jinc" filter, rather than a "Sinc windowed Sinc" filter. See <a href="../filter/#jinc">Windowed Jinc Cylindrical Filters</a> for more details. ASIDE: '<code>Sinc</code>' functions are NOT really usable as a cylindrical function, as the function interaction with radial disances on a grid, causes the filter weights into form that tends to cancel itself out (zero weight sum) whenever an even number of 'lobes' are used. This in turn causes it to try and generate near infinite colors when used with a pixel-level checkerboard 'hash' pattern. Basically EWA uses resampling filters, much like the <a href="../resize/#resize">Resize Operator</a>, and as such you can also modify the filters using the special <a href="../filter/#options">Expert Filter Options</a>. The blurriness of the a '<code>Gaussian</code>' and Gaussian-like filters for example can be controlled by the <a href="../filter/#blur">Filter Blur Setting</a>. Similarly you can use the <a href="../filter/#lobes">Lobes Support Setting</a>, to control the size and power of the Windowed Jinc Filters, such as a '<code>Lanczos</code>' filter.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>There are number of extreme distortion methods, which automatically turn off EWA re-sampling, and only use the more direct <a href="../misc/#interpolate">Interpolated Lookup</a>.<br>
              <br>
              For example the <a href="#depolar">Depolar</a> distortion, produces resampling areas in the shape of circular arcs that do not fit 'elliptical' (EWA) resampling very well. Other distortions such as <a href="#shepards">Shepards</a> make the calculation of 'scaling factors' extremely difficult, though a future improvement of the distort operator could make it possible).<br>
              <br>
              A <a href="#super_sample">Super Sampling</a> technique is recommended for these distortion methods to prevent generating severe <a href="../filter/#aliasing">Aliasing Artefacts</a> in areas of image compression (down sampling) in the results.<br>
              <br></i></font></td>
            </tr>
          </table><a name="distort_failure" id="distort_failure"></a>
          <h4>Resampling Failure</h4>In some special situations the EWA resampling Ellipse may fail to actually 'hit' any real pixel for it to create a weighted average. Basically the ellipse is so small, or so thin, that it falls completely between every pixel in the image. And without any pixel colors, it can not generate a color for the output image at that point. This is an extreme situation, and generally is imposible to achieve unless you are playing with <a href="../filter/#options">Expert Filter Settings</a>. But in the unlikely event that no pixels are hit, or the filter weights add up to zero, the resampling will fail. In that case IM will fall back to using a simple direct interpolated lookup, just like you would get if you turn of EWA filtering (see next). If you want to check if this is happening you can use the special <a href="../misc/#background_ic">Background Interpolation</a> with an unusual background color (like 'red') so as to highlight any such resampling failures. For example, here I purposfully set the support of a box filter too small, and thus making the resampling ellipse so small. I also greatly enlarge the image so you can see what parts 'hit a pixel' and which didn't.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box -define filter:support=0.4 \
          +distort SRT 30,0  bad_box_distort.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="bad_box_distort.png"><img src="bad_box_distort.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>In the greatly enlarged image, the resampling circle will either hit only one pixel (producing an aliased cicle of solid color. Or it will fail to match any pixel as the circular sampling area falls completely between the pixels, and thus the filter will fall back to an interpolated gradient of color (<a href="../misc/#bilinear">Bilinear Interpolation</a> by default), to get at least some reasonably valid color for the resulting image. Here is the same example, but replacing the interpolation method with the special (and normally useless) <a href="../misc/#background_ic">Background Interpolation</a> (just return the background color, which was set to 'gray').
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box -define filter:support=0.4 \
          -interpolate background -background Gray \
          +distort SRT 30,0   bad_box_distort_gray.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="bad_box_distort_gray.png"><img src="bad_box_distort_gray.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>For complete coverage (so it always finds at least one pixel) a cylindrical resampling filter needs a 'support' of at least about 0.707 (sqrt(2)/2) (default for a box filter). All filters are typically much larger than this minimal support size. For examples of this see the section on <a href="../filter/#cyl_interpolated">Cylindrical Filters</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The small colored dots in the corners is caused by a resampling optimization for virtual pixels (aborting an expensive EWA resampling when sampling VP areas of solid color). They will disappear or change with a different selection of the "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" setting.<br>
              <br>
              Normally this is not a problem, and only seen here because distort uses a '<a href="#distort_bestfit">Best Fit Viewport</a>' that is slightly larger than the original image, and thus includes a few extra pixels around the edge which in this case samples vitural pixel.<br>
              <br></i></font></td>
            </tr>
          </table><a name="distort_interpolate" id="distort_interpolate"></a>
          <h4>Interpolated, or Direct Color Lookup</h4><b>You can use "<code><a href="../option_link.cgi?filter">-filter</a> point</code>", to turn off filtering, and hence EWA resampling.</b>When this is done Imagemagick will switch color lookups to use fast and simplier <a href="../misc/#interpolate">Pixel Interpolation</a>. That is, it will look up a color using only a 'single point' referance to the source image without any 'resampling area'. The color of the resulting pixels will use an interpolated color based only on nearest neighbours to point.
          <div align="center">
            <b>Interpolation will generally cause sever aliasing effects<br>
            when any form of minification or down-sampling of the image occurs.</b>
          </div>But it does work extremely well for images containing minimal distortions such as rotations, tiling, or for <i>image enlargement</i> (magnification or up-sampling). A <a href="#super_sample">Super Sampling</a> technique can be combined with interpolation, to improve the results in areas of strong compression, minification or down-sampling. See <a href="#polar_problems">Depolar-Polar Cycle Problems</a> (a distort that can not use EWA resampling) for an example of using super-sampling to resolve interpolated aliasing.<br>
          <a name="distort_verbose" id="distort_verbose"></a>
          <h3>Verbose Distortion Summery</h3>By setting "<code><a href="../option_link.cgi?verbose">-verbose</a></code>" before running "<code><a href="../option_link.cgi?distort">-distort</a></code>" (use "<code><a href="../option_link.cgi?verbose">+verbose</a></code>" to turn off again), distort will output to the standard error channel, information on the algorithm and internal coefficients it calculates, and uses when distorting the given image, in the way specified. You can use this information to look at and understand how the distortion works and is applied. It is also a debugging tool we can use to figure out what is going wrong, and as part of the implementation process for new distortions.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="distort_verbose.txt">
  magick koala.gif -verbose -distort SRT 0 +verbose  koala_noop.gif
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td>
                  <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
                <td><img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"></td>
                <td>
                  <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <a href="distort_verbose.txt"><img src="distort_verbose.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                      </td>
                    </tr>
                  </table>
                </td>
                <td><img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"></td>
                <td>
                  <a href="koala_noop.gif"><img src="koala_noop.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
          </div><!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE koala.gif koala_noop.gif null: 2>&1 |
        sed 's/ .*//'`" -gt '9600' ] && echo >&2 \
    "ASSERTION FAILURE: Distort SRT no-op is VERY different\!"
</CODE> -->
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>NOTE: The resulting image is almost but not quite exactly the same as the input image (see "no-op distortions" next).</i></font></td>
            </tr>
          </table>The verbose output details the two alternative distortion techniques for the given distortion. One is an '<code><a href="#affineprojection">AffineProjection</a></code>' distortion, while the other shows a <a href="../transform/#fx">DIY FX Operator</a> alternative detailing exactly how it maps a given pixel in the output image (i,j) to an interpolated lookup in the input image (xx,yy), so as to transform the image. It does the resampling ellipse calculates which uses complex mathemathics (eigan values) to figure out, It only calculates the un-scaled interpolated lookup point in source image from which to determine the color of the (i,j) pixel. Both give information on the distortion process and can be used to extract extra information for use in other distortions of the same type. For a more complex example of using this information see <a href="#perspective_internals">Perspective Internals</a> and <a href="#bilinear_internals">Bilinear Internals</a> below. Also for an example of using an FX command for image distortion see <a href="../transform/#fx_resize">FX Image Resizing</a>. The extra '<code>0.5</code>' additions and subtractions in the above is needed to magick 'pixel coordinates' into 'image coordinates', and is required for correct mathematical handling of image distortions. See <a href="#control_coordinates">Image vs Pixel Coordinates</a> below. <a name="distort_noop" id="distort_noop"></a>
          <h4>No-Op Distortions</h4>The above example shows the results of doing a no-op distort. That is, running an image through distort (for some secondary effect) but without any actual distort involved (just a 1 to 1 mapping of pixels). The EWA resampling filter will not reproduce the exactly the same colors as the original, but will blur the individual pixels very slightly with its neighbours. This is due to the 2 dimensional filter being used, and while the color blurring is minimal it can never be eliminated. As such to do a true 'no-op' we must also turn off EWA filtering and use <a href="#distort_interpolate">Interpolated, or Direct Color Lookup</a> (see above).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -filter point -distort SRT 0  koala_noop_perfect.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_noop_perfect.gif"><img src="koala_noop_perfect.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Almost all the <a href="../misc/#interpolate">Interpolative Settings</a> will generally extract an exact copy of the source pixel when it is exactly referenced. However as a precaution, you can also specify <a href="../misc/#nearest-neighbor">Nearest-Neighbor</a> interpolation, for speed and assurance that only an exact color match is returned, regardless of any floating-point errors that distort may produce.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif   -filter point  -interpolate nearest \
          -distort SRT 0  koala_noop_perfect_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_noop_perfect_2.gif"><img src="koala_noop_perfect_2.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This may seem counter-productive, but it can be a very useful method of enlarging an images area, or tiling images (using <a href="../misc/#virtual">Virtual Pixel Methods</a>), without actually resizing the original image data. See <a href="../canvas/#tile_distort">Tiling using Virtual Pixels via Distort</a> for examples of this.That is, using the <a href="#distort">Distort Operator</a> for its secondary effects, such as multi-image virtual pixel tiling, image size enlarging or cropping, adding borders, or even translation (by integer or even sub-pixel amounts). None of which actually requires the image to be 'distorted' just 'modified' in some 'programmed' way.<br>
          <a name="distort_viewport" id="distort_viewport"></a>
          <h3>Viewport, Where Distort Looks</h3>As mentioned above using "<code><a href="../option_link.cgi?distort">-distort</a></code>" or "<code><a href="../option_link.cgi?distort">+distort</a></code>" changes what the resulting size and location of the 'destination image' to either be: the same as the source image (ignoring any virtual canvas settings), or, a best fit calculation for the distorted source image (if possible), respectively. These two things basically define what part of the resulting 'distorted space' that the destination image is seeing. Another way to think of it is that the destination image is a 'window' looking at the resulting distorted image, or, a 'viewport' into the distorted space. The "<code>distort:viewport</code>" setting overrides both of these defaults, and allow you directly specify what part of the distorted space you want to see...
          <blockquote>
            <pre><a href="../option_link.cgi?define">-define</a> distort:viewport=WxH+X+Y
<a href="../option_link.cgi?set">-set</a> option:distort:viewport WxH+X+Y</pre>
          </blockquote>These were added in IM v6.3.6-1. It does not enlarge or scale the distorted image, just specify the location and area being viewed (the viewport) in the distorted image space.This can be used to create a destination image of a specific size, or shift the view to a specific area in the distorted image space. It is very similar to using '<a href="../crop/#crop_viewport">Viewport Crop</a>', of an infinitely sized (virtual pixel defined) distorted image. For example, here we crop the output to just the koala head (with a no-op distortion). In other words just a direct 'viewport crop' of the original un-distorted image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -define distort:viewport=44x44+15+0 \
          -filter point -distort SRT 0  +repage koala_viewport.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_viewport.gif"><img src="koala_viewport.gif" width="44" height="44" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                And here we expand the view, to look at the extra space surrounding the distorted image, and showing the effects the <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting has on the infinite space surrounding the original source image.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -define distort:viewport=125x125-25-25 \
          -filter point -distort SRT 0  +repage koala_viewport_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_viewport_2.gif"><img src="koala_viewport_2.gif" width="125" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>In this case it is more like using the <a href="../crop/#extent">Extent Operator</a> to enlarge the image. However instead of simply filling with the background color, distort fills the added area with the <a href="../misc/#virtual">Virtual Pixel Setting</a>. In this case using the default '<code><a href="../misc/#edge">Edge</a></code>' virtual pixel setting, which results in the horizontal and vertical lines of pixels, replicated from the pixels along the edge of the original image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                You may like to make a better choice for the <a href="../misc/#virtual">Virtual Pixel Setting</a>. For example using a '<code><a href="../misc/#background">Background</a></code>' setting will make this no-op distort work pretty much exactly like the <a href="../crop/#extent">Extent Operator</a>. For this image '<code><a href="../misc/#white">White</a></code>' Virtual Pixel setting would probably be a better choice.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -define distort:viewport=125x125-25-25 \
          -virtual-pixel White -distort SRT 0  +repage koala_viewport_3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_viewport_3.gif"><img src="koala_viewport_3.gif" width="125" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The final "<code><a href="../option_link.cgi?repage">+repage</a></code>" in the previous examples is needed to remove the viewport's virtual canvas offset that "<code><a href="../option_link.cgi?distort">-distort</a></code>" will leave in place when the viewport setting is used. This information is just not wanted in this case. In other cases, such as when layering distorted images, you would want that offset information.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The viewport option is particularly useful with a '<code><a href="../misc/#tile">Tile</a></code>' or even a '<code><a href="../misc/#mirror">Mirror</a></code>' virtual pixel setting, allowing you generate tiled, image of any size and in different styles. You can even use distort to distort those tiled images, such as exampled in <a href="#affine_tile">Affine Tiling</a> below.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -define distort:viewport=125x125-25-25 \
          -virtual-pixel Mirror -distort SRT 0  +repage koala_viewport_4.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_viewport_4.gif"><img src="koala_viewport_4.gif" width="125" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="centered_square" id="centered_square"></a>
          <h4>Centered Square Crop</h4>If you use the "<code><a href="../option_link.cgi?set">-set</a></code>" option to set the 'viewport' of the resulting image, you can include <a href="../basics/#arg_escape">Percent Escapes</a> in the assigned value. More specifically you can include <a href="../transform/#fx_escapes">FX Percent Escapes</a> that can do mathematical calculations. This means the 'viewport' can be calculated, while making use of the attributes of say the size of the current image in memory, to specify the final size of the resulting image. What does that mean? Well it means the 'viewport' can be used to generate special types of <a href="../crop/#crop">Crop</a> that normally requires one or more pre-reads, of an image, (or a more advanced API programming interface), and external calculations to achieve. For example you can crop out a 'center square' of an image without needing to know the original images size or orientation, before hand. This is complex, so I placed the viewport expression in variables so as to make it easier to read, code, and debug, though it is really just a constant (fixed) expression.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="viewport_square.gif">
  size='%[fx: w&gt;h ? h : w ]'
  offset_x='%[fx: w&gt;h ? (w-h)/2 : 0 ]'
  offset_y='%[fx: w&gt;h ? 0 : (h-w)/2 ]'
  viewport="${size}x${size}+${offset_x}+${offset_y}"

  magick worldmap_sm.jpg  -set option:distort:viewport "$viewport" \
          -filter point -distort SRT 0  +repage   viewport_square.gif
</code></pre>
                </td>
              </tr>
            </table><a href="../img_photos/worldmap_sm.jpg"><img src="../img_photos/worldmap_sm.jpg" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="viewport_square.gif"><img src="viewport_square.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>The resulting image is the largest centered square that can be extracted from any input source image, regardless of that images size. The distort itself does not actually distort the image, only copy the area covered by the viewport. Note that ALL four numbers needs to be calculated to produce a "centered square crop" as all values are dependant on the images orientation. As such each expression uses a 'image orientation' test of the form '<code>w&gt;h ? ... : ...</code>', so the resulting value depends on the images orientation.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                This is an alternative form using "min()" and "max()" functions, instead of image orientation tests.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick worldmap_sm.jpg  -set option:distort:viewport \
    "%[fx:min(w,h)]x%[fx:min(w,h)]+%[fx:max((w-h)/2,0)]+%[fx:max((h-w)/2,0)]" \
    -filter point -distort SRT 0  +repage  viewport_square_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="viewport_square_2.gif"><img src="viewport_square_2.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Courtesy of <a href="http://www.fmwconcepts.com/imagemagick/tidbits/image.php#pad_crop_square">Fred Weinhaus's Tidbits Page</a>. A technique using multiple image processing techniques for doing the same thing is shown in <a href="../thumbnails/#square">Thumbnails, Square Padding and Cropping</a>. <a name="aspect_ratio_crop" id="aspect_ratio_crop"></a>
          <h4>Aspect Ratio Crop</h4>This technique can be expanded so you center crop an image to fit a given aspect ratio. Also see Forum Discussion <a href="../forum_link.cgi?t=33448">Crop to Aspect Ratio</a>. <a name="viewport_other" id="viewport_other"></a>
          <h4>Other Viewport Examples</h4>Also see <a href="#rotate_methods">Methods of Rotating Images</a> below for other examples of using a viewport to control what part of the distorted space is visible in the results. <a name="distort_scale" id="distort_scale"></a>
          <h3>Output Scaling, and Super-Sampling</h3>
          <blockquote>
            <pre><a href="../option_link.cgi?define">-define</a> distort:scale=N
<a href="../option_link.cgi?set">-set</a> option:distort:scale N</pre>
          </blockquote>Was added in IM v6.4.2-6, as a general output image scaling factor. This enlarges the output image by the factor given and thus the "<code><a href="../option_link.cgi?distort">-distort</a></code>" will need to generate <code>N<sup>2</sup></code> more distorted lookup 'samples'. The number is usually an integer, but can be a floating point enlargement factor. Note that many distortions also allow you to 'scale' the size of resulting distorted image, however the resulting image size would be unaffected by that scaling (unless a 'best-fit' "<code><a href="../option_link.cgi?distort">+distort</a></code>" was used). This 'scale' setting however does not change the contents of resulting image at all, just enlarges or shrinks the resulting output image. This can be used for example with an appropriate 'viewport' to produce an image that you can easily "<code><a href="../option_link.cgi?resize">-resize</a></code>" to a specific size, allowing you generate a controlled 'zoom' into the distorted image, without loss of quality.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                For example, we 'zoom' in on the head of the koala.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -set option:distort:scale 2.5 \
          -set option:distort:viewport 44x44+15+0 \
          -distort SRT 0  +repage koala_zoom.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_zoom.gif"><img src="koala_zoom.gif" width="110" height="110" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that while the viewport was requested to be <code>44x44</code> pixels, the actual output image has been scaled to <code>110x110</code> pixels. More commonly, it is used as a simple means of '<a href="#super_sample">Super Sampling</a>' (see above) the distortion operation. For this an integer 'super-sampling' scale factor is used, and after distorting the image is scaled back to its original size, to merge the extra samples together, and produce a higher quality result.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -filter point -set option:distort:scale 10 \
          -distort SRT 0  -scale 10%   koala_super.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_super.gif"><img src="koala_super.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Also as '<a href="#area_resample">Area Re-Sampling</a>' is not needed when using '<a href="#super_sample">Super Sampling</a>' for improving image quality (it only slows it down), it is typically turned off by using a "<code><a href="../option_link.cgi?filter">-filter</a> point</code>" option (see previous section).
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="methods" id="methods"></a>
          <h2>Introduction to Distortion Methods</h2><a name="srt" id="srt"></a>
          <h3>Scale-Rotate-Translate (SRT) Distortion</h3>One of the simplest distortion, but probably one of the most versatile, is the '<code>SRT</code> or '<code>Scale-Rotate-Translate</code>' distortion. (SRT is just a quick short-hand) You have already seen the 'no-op' example of this distortion in the above examples, where the image is processed without any actual distortion being applied to the image, though it will still be filtered which can induce some very minor blurring. Here is a repeat the results of the above 'no-op' distort...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif    -distort SRT 0    koala_noop.gif
</samp></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td>
                  <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
                <td><img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"></td>
                <td>
                  <a href="koala_noop.gif"><img src="koala_noop.gif" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Note that the image will be blurred very slightly as consequence of using <a href="#area_resample">Area Resampling</a>. However IM resampling filters have been purposefully designed to minimise this blurring for the No-Op distortion, and is needed for normal use.<br>
              <br>
              If you want perfect 'no-op' distort for special purposes, then turn off EWA resampling. That is, specify the 'no-op' filter "<code>-filter Point</code>" to the above before the distort operator.<br>
              <br></i></font></td>
            </tr>
          </table>The '<code>SRT</code> distortion is actually three separate, distortions in a single distortion method, which is why it is called a '<code>Scale-Rotate-Translate</code>' distortion. All arguments, except the <i>angle</i> rotation, are optional and this makes the arguments highly variable, depending on exactly how many comma or space separated arguments you give, up to the maximum of 7 floating point numbers.
          <table align="center" border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td rowspan="7"><code><b>-distort SRT "</b>&nbsp;</code></td>
              <td>
                <pre><font size="-1">                  Angle </font></pre>
              </td>
              <td rowspan="7"><code>&nbsp;<b>"</b></code></td>
              <td>&nbsp; -&gt; centered rotate</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">        Scale     Angle </font></pre>
              </td>
              <td>&nbsp; -&gt; centered scale and rotate</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">X,Y               Angle </font></pre>
              </td>
              <td>&nbsp; -&gt; rotate about given coordinate</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">X,Y     Scale     Angle </font></pre>
              </td>
              <td>&nbsp; -&gt; scale and rotate about coordinate</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">X,Y ScaleX,ScaleY Angle </font></pre>
              </td>
              <td>&nbsp; -&gt; ditto</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">X,Y     Scale     Angle  NewX,NewY</font></pre>
              </td>
              <td>&nbsp; -&gt; scale, rotate and translate coord</td>
            </tr>
            <tr>
              <td>
                <pre><font size="-1">X,Y ScaleX,ScaleY Angle  NewX,NewY</font></pre>
              </td>
              <td>&nbsp; -&gt; ditto</td>
            </tr>
          </table>What this does is take an image in which you have selected, and an optional control point. If no control point is given, the exact center of the input source image is used. Around that point the distortion will, in sequence... <b>Scale</b> the image, <b>Rotate</b> it, then <b>Translate</b> or move the selected control point to a new position. Hence the name of this distortion. The argument order shown above reflects the order of operations that are actually applied to the image. <b>X,Y</b> to translate the 'center' of the transformations to the origin, <b>ScaleX,ScaleY</b> the image, <b>Angle</b> rotate the image, then <b>NewX,NewY</b> translate the 'center' to these coordinates. That is, the operator really represents 4 internal distortion operations all applied simultaneously as a single distortion. Though to us humans only 3 distinct distortions are involved. So lets take a simple example using the 'koala' image... One argument is just a simple rotation about the images center, basically producing a similar result to the older <a href="../warping/#rotate">Rotate Operator</a>, but without any image size increase.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -background skyblue  -virtual-pixel background \
          -distort ScaleRotateTranslate -110 koala_srt_rotate.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_srt_rotate.png"><img src="koala_srt_rotate.png" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that by default the size of the input image us also used for the output image, as such the rotated image may be clipped. It is also perfectly centered regardless of if the image has an odd or even number of pixels. Using the 'plus' form of "<a href="../option_link.cgi?distort"><code>+distort</code></a>", and a clean up of resulting virtual canvas offsets, we can generate something very similar to the normal <a href="../warping/#rotate">Rotate Operator</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -background skyblue  -virtual-pixel background \
          +distort ScaleRotateTranslate -110 +repage koala_srt_rotate2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_srt_rotate2.png"><img src="koala_srt_rotate2.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="img_www/warning.gif" width="28" height="28"><img src="img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As of IM 6.7.3-4 the <a href="../warping/#rotate">Rotate Operator</a> is now using Distort SRT Distortion. Before this it was using <a href="./warping/#shear">Shear Operations</a>, whcih did not produce a good a result.</i></font></td>
            </tr>
          </table>Lets shrink it by 30% as well, but use a transparent background.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -alpha set -virtual-pixel transparent \
          +distort ScaleRotateTranslate '.7,-110' +repage koala_srt_scale.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_srt_scale.png"><img src="koala_srt_scale.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The next set of arguments will specify the 'center' around which the image is rotated and scaled. This point is called a 'control point' or 'handle' in the image which is a location used to control the distortion. As we are using a specific point for this distortion, lets not use the 'best-fit' mode to avoid the complications of 'virtual offsets'. For example lets rotate and scale the koala around its 'nose', which is located at <code>28,24</code> in the source image. While we are at it lets distort the X and Y scales different.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -background skyblue -virtual-pixel background \
          -distort ScaleRotateTranslate '28,24  .4,.8  -110' \
          koala_srt_center.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_srt_center.png"><img src="koala_srt_center.png" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>And as a final example, lets also move the 'nose' to near the bottom of the image, and set background to a matching white background.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -virtual-pixel white \
          -distort ScaleRotateTranslate '28,24  .4,.8  -110  37.5,60' \
          koala_srt_trans.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="koala_srt_trans.png"><img src="koala_srt_trans.png" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that the final position is also a floating point value. In fact all the arguments can be floating point values and the distortion will do the right thing. Remember each of the operations, Scale, Rotate, and Translate are performed in that order. As you can see this distortion is very versatile, and while you can think of it as distorting the image using three different methods in sequence, in reality it is applying all three distortions simultaneously to produce the shown result. This makes it faster than doing multiple individual operators, and generally produces a better final result. The above also demonstrates the use of different <a href="../misc/#virtual-pixel">Virtual Pixel</a> settings to define the color used for the areas referenced outside the actual source image. To see the effect of <a href="../misc/#interpolation">Interpolation</a> on rotations see <a href="../misc/#interpolate_line">Interpolation of a Rotated Line and Edge</a>. This distortion specifically designed to take an image and generate an animation based on the movements and rotation of that object. For example, here I create a stylized space ship, which I then animate in a very rough way. The ship sits on its base at <code>20,75</code> (for the initial 'hunker-down' scaling) while the normal 'handle' for movement and rotations is the ships center which is located at <code>20,60</code> in the original image. These points represent control points by which the object can then be animated in simple terms.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:skyblue -fill yellow -stroke black \
          -draw 'path "M 15,75 20,45 25,75 Z  M 10,55 30,55" ' \
          spaceship.gif
  magick spaceship.gif \
          \( -clone 0  -distort SRT '20,75  1.0,0.6  0' \) \
          \( -clone 0  -distort SRT '20,60     1     0  20,49' \) \
          \( -clone 0  -distort SRT '20,60    0.9   20  27,35' \) \
          \( -clone 0  -distort SRT '20,60    0.8   45  40,23' \) \
          \( -clone 0  -distort SRT '20,60    0.5   70  55,15' \) \
          \( -clone 0  -distort SRT '20,60    0.3   75  72,11' \) \
          \( -clone 0  -distort SRT '20,60    0.1   80  100,8' \) \
          -set delay 50  -loop 0  spaceship_launch.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="spaceship.gif"><img src="spaceship.gif" width="80" height="80" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="spaceship_launch.gif"><img src="spaceship_launch.gif" width="80" height="80" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
          </div>Of course it is a very rough example of how you can use a '<code><a href="#srt">SRT</a></code>' distortion to animated a static image, but you should get the idea. You can add more frames, and perhaps some flames and smoke to improve it further (submissions welcome and best result will be added here with your name). <a name="rotate_methods" id="rotate_methods"></a>
          <h3>Methods of Rotating Images</h3>Images can be rotated in many ways. But just simple rotations may not be what you are looking for.Rotate image without changing size...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel black -distort SRT '20'  rotate_normal.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rotate_normal.png"><img src="rotate_normal.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Or rotate so as not to clip any of the rotated image...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel black +distort SRT '20'  rotate_noclip.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rotate_noclip.png"><img src="rotate_noclip.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However typically you do not want to see the 'black' <a href="../misc/#virtual-pixel">Virtual_Pixel</a> (or whatever other non-image color) surrounding the image proper. One solution is to crop the image (using a <a href="#distort_viewport">Distort Viewport Setting</a>) to the largest rectangle of the same aspect ratio, such that it only contains real image pixels resulting from the rotation. However calculating this rectangle is rather tricky, and was heavily discussion on the <a href="../forum_link.cgi?t=18862&amp;p=73079">ImageMagick Forum</a> using some equations found on the <a href="http://www.mathhelpforum.com/math-help/f13/finding-scale-rectangle-inside-larger-rotated-rectangle-102791.html">Math Help Forum</a>. Here we rotate and do an internal crop at as close to the original aspect ratio as possible.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="">
  angle=20
  ratio=`magick rose: -format \
     "%[fx:aa=$angle*pi/180; min(w,h)/(w*abs(sin(aa))+h*abs(cos(aa)))]" \
     info:`
  crop="%[fx:floor(w*$ratio)]x%[fx:floor(h*$ratio)]"
  crop="$crop+%[fx:ceil((w-w*$ratio)/2)]+%[fx:ceil((h-h*$ratio)/2)]"
  magick rose: -set option:distort:viewport "$crop" \
          +distort SRT $angle +repage   rotate_internal.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rotate_internal.png"><img src="rotate_internal.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This looks complex but that is because it actually has to calculate 4 separate values to define <a href="#distort_viewport">Viewport Setting</a>, Width, Height, and offset in the original image. Another alternative is to not only rotate, but also scale the image slightly larger so as to 'fill' the original images bounds.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="">
  angle=20
  magick rose: -distort SRT \
     "%[fx:aa=$angle*pi/180;(w*abs(sin(aa))+h*abs(cos(aa)))/min(w,h)], $angle" \
     rotate_correction.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rotate_correction.png"><img src="rotate_correction.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This last is ideal for a <a href="../photos/#rotation">Minor Rotation Correction of Photos</a>, so as to preserve the images original size. The only reason this method is simpler, is because only one 'scale' value needs to be calculated, and as such can be done 'in-line'. <a name="control_points" id="control_points"></a>
          <h3>Distortions Using Control Points</h3>While the '<code><a href="#srt">SRT</a></code>' distortion method is defined by specifying rotation angles and scaling factors, most distortions are defined by moving 'points' on the source image, and moving them to a new position in the resulting image. This is a bit like the movement of the 'center' point when defining a '<code><a href="#srt">SRT</a></code>' translation. These points are called control points, and are more usually defined by giving 4 floating point values (2 pairs of coordinates) for each single control point. So often a distortion is defined in terms of multiple sets of 4 values. For example....
          <div align="center">
            <code>X<sub>1</sub>,Y<sub>1</sub> I<sub>1</sub>,J<sub>1</sub> &nbsp; &nbsp; X<sub>2</sub>,Y<sub>2</sub> I<sub>2</sub>,J<sub>2</sub> &nbsp; &nbsp; X<sub>3</sub>,Y<sub>3</sub> I<sub>3</sub>,J<sub>3</sub> &nbsp; &nbsp; X<sub>4</sub>,Y<sub>4</sub> I<sub>4</sub>,J<sub>4</sub> . . . .</code>
          </div>Where the control point X<sub>i</sub>,X<sub>i</sub> in the source image (relative it its virtual canvas), is mapped to I<sub>i</sub>,J<sub>i</sub> on the distorted destination image.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>However as the <a href="#distort">Distort Operator</a> is actually mapping destination coordinates to source coordinates (see <a href="#mapping">Reverse Pixel Mapping</a>), the internal use of the above is to map I,J coordinates to X,Y coordinates. The result however should be the same, just a different way of thinking.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Before IM version 6.3.6-0 when the <a href="#distort">Distort Operator</a> operator was first introduced, the coordinate ordering for control points was defined as all the source coordinates, followed by all the destination coordinates. This however made it very hard to determine which source and destination coordinates corresponded to each other, and did not allow for the simple appending of more control points to further refine a distortion.</i></font></td>
            </tr>
          </table>It is defined in this way so that the movement of each individual control point is kept together in the comma (or space) separated list of floating point values. It also allows for the future use of external 'control point files'. The simplest distortion using control points is the '<code><a href="#affine">Affine</a></code>' distortion, though this as you will see later is usually defined in terms of three points, you can use just one or two control point movements. In actual fact '<code><a href="#srt">SRT</a></code>' is simply a two or one point sub-set of a '<code><a href="#affine">Affine</a></code>' distortion. For example, here we move the 'nose' of our koala image at '<code>28,24</code>' to the new position '<code>45,40</code>' (as indicated by the red arrow), which results in a simple 'translation' of the image location. <!-- <CODE EXECUTE>
  magick koala.gif -fill none -stroke red \
            -draw 'path "M 28,24 45,40  M 41,32 45,40 36,37 ' \
          koala_arrow.png
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -virtual-pixel white \
          -distort Affine '28,24 45,40'   koala_one_point.png
</samp></pre>
                </td>
              </tr>
            </table><a href="koala_arrow.png"><img src="koala_arrow.png" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_one_point.png"><img src="koala_one_point.png" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>With two points, the '<code><a href="#affine">Affine</a></code>' distortion can not only translate an image but scale and rotate it as well (the full range of a '<code><a href="#srt">SRT</a></code>' distortion. For example, here I map the 'ears' to the koala (the red line from '<code>30,11</code>' and '<code>48,29</code>'), to a larger horizontal position (a blue line from '<code>15,15</code>' to '<code>60,15</code>'), requiring the image to be scaled, rotated and translated so the control points are moved to this new position. <!-- <CODE EXECUTE>
  magick koala.gif -fill none \
            -draw 'stroke red  line 30,11  48,29' \
            -draw 'stroke blue line 15,15  60,15' \
          koala_lines.png
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  -virtual-pixel white \
          -distort Affine '30,11 15,15  48,29 60,15'   koala_two_point.png
</samp></pre>
                </td>
              </tr>
            </table>Of course a '<code><a href="#srt">SRT</a></code>' distortion could have reproduced the above two point '<code><a href="#affine">Affine</a></code>' distortion, except that here we defined the distortion in a different way. Which form you should use is up to you, depending on what you are trying to achieve. <a name="control_coordinates" id="control_coordinates"></a>
            <h3>Image Coordinates vs Pixel Coordinates</h3>The use of control points in the general case is straight forward, but becomes more difficult when you need to align a distorted image, with another image or drawn constructions. The reason is that while most operators in IM handle coordinates in terms of a '<i>Pixel Positions</i>' (for example when <a href="../crop/#crop">Cropping</a>, <a href="../draw/#draw">Drawing</a>, etc) distortions deal with coordinates in mathematical '<i>Image Coordinates</i>'. What you need to remember is that pixels in an image are not a 'point' but actually an 'area', 1 pixel unit in size. That is, a pixel located at <code>10,10</code>defines a square area of color, going from <code>10</code>units down/across to <code>11</code>units down and across. In terms of <i>image coordinates</i>the 'pixel' center is actually located at <code>10.5,10.5</code>. That is, 0.5 needs to be added when you are distorting an image to move the center of a 'pixel' to a specific location. So to re-position the corner 'pixels' of an image you would thus need to move the image in terms of the pixels located at <code>0.5,0,5</code>and <code><i>Width</i>-0.5,<i>Height</i>-0.5</code>. On the other hand to reposition the image in terms of the actual 'edges' of the image you would simply use the coordinates <code>0.0,0,0</code>and <code><i>Width</i>,<i>Height</i></code>. You just need to think about what you actually wanting to position, the center of an images 'pixels' or the 'edges' of the image. Or if it actually even matters for your particular problem. Remember that if you want to <a href="../draw/#draw">draw</a>other elements onto your distorted image, you will need to give draw positions in terms of '<i>Pixel Positions</i>'. And yes the "<a href="../option_link.cgi?draw"><code>-draw</code></a>" operator can draw lines, circles, and other shapes using floating point values. Similarly the stroke width and/or radii of the objects can also be given as floating point values.
            <table>
              <tr>
                <td>
                  <a href="koala_lines.png"><img src="koala_lines.png" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_two_point.png"><img src="koala_two_point.png" width="75" height="75" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>A draw stroke width of less than 1.0 does not work well, (See <a href="../draw/#strokewidth">Drawing Lines</a>). Also the area fill adds an extra 0.5 (matching the stroke width addition) to the edges of the fill area (See <a href="../draw/#bounds">Draw Fill Bounds</a>). This is done regardless of the actual strokewidth used.<br>
                <br>
                For more information see <a href="../draw/#bounds">Draw Fill Bounds</a>. Something I regard as a bug.</i></font></td>
              </tr>
            </table><a name="control_escapes" id="control_escapes"></a>
            <h3>Control Points using Percent Escapes</h3>You can also use <a href="../basics/#arg_percent">Percent Escapes</a> within the distort arguments. For example you can extract image attributes for one image, then use them to resize another image to match the first image. Here I grab the size of the "<code>rose:</code>" built-in image, then use a '<code><a href="#affine">Affine</a></code>' distortion to resize the larger "<code>logo:</code>" image to the same size (without preserving the aspect ratio).
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
   magick rose: -set option:rw %w -set option:rh %h +delete \
           logo: -alpha set -virtual-pixel transparent \
           +distort Affine '0,0 0,0     %w,0 %[rw],0   0,%h  0,%[rh]' \
           +repage logo_sized_as_rose.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="logo_sized_as_rose.png"><img src="logo_sized_as_rose.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that distort will generate slightly larger 'layered image' on a virtual canvas, (including a negative offset) which is why I needed to include a "<code><a href="../option_link.cgi?repage">+repage</a></code>" in the above example. It also will have fuzzy edges too, as distort is generating an exact or true distortion of the image, and not a sanitised orthogonal <a href="../resize/#resize">Resized Image</a>. For a more advance examples on using the <a href="#distort">Distort Operator</a> to resize images, exactly as the <a href="../resize/#resize">Resize Operator</a> does, see <a href="../resize/#distort_resize">Distort vs Resize</a>, as well as the <a href="#resize">Distort Resize Method</a> below. You can also use percent escapes to calculate distortions based on an images position within the current image list. Examples of this are given in <a href="../anim_mods/#distort">Animated Distorts</a>. <a name="control_leastsq" id="control_leastsq"></a>
            <h3>Control Point Least Squares Fit</h3>If you supply more than 3 control points for '<code><a href="#affine">Affine</a></code>' distortion, or more than 4 points for '<code><a href="#perspective">Perspective</a></code>' or the '<code><a href="#bilinear">Bilinear</a></code>' distortions, ImageMagick will perform an least squares average over all the given points to find an 'average' representation for those distortions. This means if you are trying to match up one image with another image (a technique known as '<i>Image Registration</i>'), you can define more than the minimum number of points needed so that the result will be a more precise distortion. Of course if one or more of those points do not 'fit' well with the other points, then the result will be skewed by the 'odd' point, as IM tries to find the best fit using all the control points given, including the bad one. Some check to find and remove 'bad coodinate pairs' may be needed for some situations. <a name="control_files" id="control_files"></a>
            <h3>Control Point from Files</h3>The list of numbers (arguments) to a distortion can also be read from a file by using a '<code>@filename</code>' syntax, just as you can input text for things like "<code><a href="../option_link.cgi?annotate">-annotate</a></code>" and "<code><a href="../text/#label">label:</a></code>" (see <a href="../text/#escape_chars">Escape Characters in Text Arguments</a>). For example you can specify a distortion like this...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick input.png  -distort Perspective '@file_of_coords.txt' output.png
</samp></pre>
                  </td>
                </tr>
              </table>
            </div>The filename can be just a '<code>@-</code>' to mean read the file from standard input. The file itself will be read in as a string and treated as the list of coordinates (arguments) needed by the distortion involved. As numbers can be either comma or white-space separated, that means the coordinate pairs can be cleanly ordered as one pair of coordinates per line in the form...
            <div align="center">
              <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre>
   X<sub>1</sub>   Y<sub>1</sub>   I<sub>1</sub>   J<sub>1</sub>
   X<sub>2</sub>   Y<sub>2</sub>   I<sub>2</sub>   J<sub>2</sub>
   X<sub>3</sub>   Y<sub>3</sub>   I<sub>3</sub>   J<sub>3</sub>
   X<sub>4</sub>   Y<sub>4</sub>   I<sub>4</sub>   J<sub>4</sub>
   ....
</pre>
                  </td>
                </tr>
              </table>
            </div>That with the <a href="#control_leastsq">Least Squares Fitting</a> makes the use of image registration very practical. As the file is just a list of four numbers per line, you can use other text processing scripting tools such as "<code>cut</code>", "<code>paste</code>", "<code>column</code>", and more advanced text processing scripting tools such as "<code>sed</code>", "<code>awk</code>", "<code>perl</code>", etc to manipulate the coordinates. The use of coordinate and distortion argument files will become more important with more advanced distortions, such as '<code><a href="#shepards">Shepards</a></code>' distortion, and the planned future distortions of '<code>Grid</code>' and "<code>Mesh</code>' where hundreds of coordinate pairs may be involved. <!--
<A NAME="image_registration"></A>
<H3>Image Registration <FONT SIZE=-1>(Using more control points)</H3>

<BR>
-->
            <br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="affine" id="affine"></a>
            <h2>Affine (Three Point) Distortion Methods</h2>
            <h3>Affine Distortion</h3>Both the '<code><a href="#srt">SRT</a></code>' distortion, and the one and two point forms of the '<code>Affine</code>' distortion shown above are actually simplifications of a full 3 point form of the '<code>Affine</code>' distortion. In fact if you study the "<a href="../option_link.cgi?verbose"><code>-verbose</code></a>" output of any '<code><a href="#srt">SRT</a></code>' distortion (see <a href="#distort_verbose">verbose distort setting</a> for an example) you will find that internally it really is a '<code><a href="#affine_projection">AffineProjection</a></code>' distortion (see below). The only distortion effect that the above methods could not handle fully was 'shears' similar to what the <a href="../warping/#shear">Shear Operator</a> would provide. For that you need to use a three point affine distortion. You can think of this as being a three point distortion, by imagining the first coordinate mapping as a 'origin' with the other two coordinate mappings as vectors from that origin. For example, here I draw some text, and overlay a red and blue 'vector' to define the three control points relative to that text. Now by moving the coordinates (as <a href="#control_coordinates">Image Coordinates</a> of those two lines, we can translate, rotate, scale and shear that text image, to fit the new location of those lines.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" script="">
  magick -background lightblue -fill Gray -font Candice \
      -size 100x100 -gravity center label:Affine\! \
      -draw 'fill blue stroke blue path "M 3,60 32,60 M 27,58 27,62 32,60 Z"' \
      -draw 'fill red  stroke red  path "M 3,60  3,30 M  1,35  5,35  3,30 Z"' \
      label_axis.png
  magick label_axis.png \
          -distort Affine ' 3.5,60.5   3.5,60.5
                           32.5,60.5  32.5,60.5
                            3.5,30.5  33.5,20.5' label_axis_distort_shear.png
  magick label_axis.png \
          -distort Affine ' 3.5,60.5   3.5,60.5
                           32.5,60.5  27.5,85.5
                            3.5,30.5  27.5,35.5' label_axis_distort_rotate.png
  magick label_axis.png \
          -distort Affine ' 3.5,60.5  30.5,50.5
                           32.5,60.5  60.5,80.5
                            3.5,30.5  30.5,5.5' label_axis_distort_affine.png
</code></pre>
                  </td>
                </tr>
              </table><a href="label_axis.png"><img src="label_axis.png" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="label_axis_distort_shear.png"><img src="label_axis_distort_shear.png" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="label_axis_distort_rotate.png"><img src="label_axis_distort_rotate.png" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="label_axis_distort_affine.png"><img src="label_axis_distort_affine.png" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>In the first example only the third coordinate (for the vertical red line) was modified causing the image to be sheared, and stretched along the Y axis. Of course it does not have to be limited to just the Y axis. Later examples make more radical changes to the image, including rotations, and translations. Of course the <a href="../text/#annotate">Annotate Text</a> operator can also skew actual text in this same way, though only with changes to the angle. That operator will not scale or enlarge the text in some particular direction. That is, to say it can rotate a 'vector' but it can not stretch it longer or shorter. See <a href="../misc/#annotate">Annotate Argument Usage</a> for a table of examples. Affine distortion can do this type of distortion for any image, and not just drawn text. <b>Affine using less or more that three coordinate pairs</b> If only 1 or 2 control point pairs are provided, IM will use a more limited form of affine distortion to match the movement of those fewer points. For example with only 1 coordinate pair, it limits itself to unscaled translations of the image. With 2 points it will limit itself to a '<code><a href="#srt">Scale-Rotate-Translation</a></code>' distortions (no shears). See the previous discussion on <a href="#control_points">Distortions Using Control Points</a> for examples. If more than 3 control points is given to an '<code><a href="#affine">Affine</a></code>' distortion, then IM will use <a href="#control_leastsq">Least Squares Fitting</a> to find the best '3 point' affine distortion matching <i>all</i> the coordinate pairs given. That means the source image control points may not map exactly to destination image control points, but a best-fit 'average' of all the points given. <?P>
             For example if you have a scan of a document, you could locate and map all 4 corners of the document for an affine distortion to correct for rotation and scaling of the document. In this way you can get a better 'average' fit based of 4 points rather than 3 points. Note that while more coordinates can produce a better and more accurate distortion, if one coordinate pair is very bad, then the least squares fit may not produce a very good fit at all. Some check to eliminate 'bad coordinate pairs' may be needed. <code>Future: Add some code to IM to report how 'accurate' each input coordinate pair is relative to the others to help determine what 'bad points' should be eliminated by the user.</code> <a name="affine_projection" id="affine_projection"></a>
            <h3>Affine Projection Distortion</h3>As I have already mentioned, the various arguments of an '<code><a href="#srt">SRT</a></code>' distortion and the control points of an '<code><a href="#affine">Affine</a></code>' distortion, are mathematically transformed into 6 special numbers which represent the 'coefficients' of an '<code>Affine Projection</code>'. These numbers in an Affine Projection is the coefficients used for the <a href="#forward_mapping">Forward Mapping</a> of points in the source image to the destination image. That is, they are the mathematical values used to map a source image <code>x,y</code> to a destination image <code>i,j</code>. The 6 floating point arguments are (in the order to be given)...
            <div align="center">
              <code>s<sub>x</sub>, r<sub>x</sub>, r<sub>y</sub>, s<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub></code>
            </div>These in turn form the distortion expressions..
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td rowspan="3"><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>s<sub>x</sub>*X<sub>s</sub> + r<sub>y</sub>*Y<sub>s</sub> + t<sub>x</sub></code></td>
                <td rowspan="3">&nbsp; , &nbsp; &nbsp; &nbsp;</td>
                <td rowspan="3"><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>r<sub>x</sub>*X<sub>s</sub> + s<sub>y</sub>*Y<sub>s</sub> + t<sub>y</sub></code></td>
                <td></td>
              </tr>
            </table>Where "<code>X<sub>s</sub>,Y<sub>s</sub></code>" are source image coordinates and "<code>X<sub>d</sub>,Y<sub>d</sub></code>" are destination image coordinates. Internally ImageMagick Distort will reverse the above equations so as to do the appropriate <a href="#mapping">Pixel Mapping</a> to map "<code>X<sub>d</sub>,Y<sub>d</sub></code>" coordinates to lookup the color at "<code>X<sub>s</sub>,Y<sub>s</sub></code>" in the source image. For more information on how the various Affine Projection Matrix values effect the image see the <a href="affine/">Affine Matrix Transforms</a> sub-page. If you already have these coefficients pre-calculated (say extracted from the <a href="#distort_verbose">Verbose Output</a> of distort, or calculated them yourself using other methods from other forms of input arguments, then you can directly supply them to IM to distort the image. For example, here I 'shear' the image but using an angle to calculate the coefficients, rather than the movement of control points.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="koala_affine_proj.png">
   angle=-20
   tan=`magick xc: -format "%[fx:tan( $angle *pi/180)]" info:`
   magick koala.gif -alpha set -virtual-pixel Transparent \
           +distort AffineProjection "1,$tan,0,1,0,0" +repage \
           koala_affine_proj.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="koala_affine_proj.png"><img src="koala_affine_proj.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The older way of doing this distortion in ImageMagick was to use the "<a href="../option_link.cgi?affine"><code>-affine</code></a>" and "<a href="../option_link.cgi?transform"><code>-transform</code></a>" operational pair. However as of IM v6.4.2-8 this is just a simple call to '<code>AffineProjection</code>' using the 'plus' or 'bestfit' form of the <a href="#distort">Distort Operator</a>. See the <a href="affine/">Affine Matrix Transforms</a> sub-page for more details. <a name="affine_examples" id="affine_examples"></a>
            <h3>Affine Distortion Examples</h3><a name="affine_tile" id="affine_tile"></a>
            <h4>Affine Tiling</h4>All three of the above affine-like distortion methods we have looked at so far, also provides interesting ways to generate various tiling patterns, based on a distorted image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png    -alpha set    -virtual-pixel tile \
          -distort  ScaleRotateTranslate  '20,20  .5  30' \
          checks_srt_tile.png
  magick checks.png    -alpha set    -virtual-pixel tile \
          -distort  Affine  '0,0 10,10   0,89 10,50   89,0 50,0' \
          checks_affine_tile.png
  magick checks.png    -alpha set    -virtual-pixel tile \
          -distort  AffineProjection  '0.9,0.3,-0.2,0.7,20,15' \
          checks_amatrix_tile.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="checks.png"><img src="checks.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="checks_srt_tile.png"><img src="checks_srt_tile.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <a href="checks_affine_tile.png"><img src="checks_affine_tile.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <a href="checks_amatrix_tile.png"><img src="checks_amatrix_tile.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
            </div>Using a distortion mapping in this way is actually how 'texture mapping' works in 3D graphic libraries and games. The only difference is that they map 3 dimensional coordinates of surfaces, back to a two dimensional image. Even the 'no-op' distortion ("<code>-distort SRT 0</code>"), with an appropriate <a href="#distort_viewport">Distort Viewport</a> provides a useful way of tiling whole sequence of images such as <a href="../anim_mods/#glitter_tiles">Animated Glitter Tiles</a>.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick glitter_blue.gif -virtual-pixel tile \
          -filter point -set option:distort:viewport 100x100 -distort SRT 0 \
          glitter_blue_tiled.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="../images/glitter_blue.gif"><img src="../images/glitter_blue.gif" width="48" height="48" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="glitter_blue_tiled.gif"><img src="glitter_blue_tiled.gif" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
            </div>Note that I also used a "<code><a href="../option_link.cgi?filter">-filter</a> point</code>" to turn off <a href="#distort_ewa">EWA Resampling</a>, so as speed up the operation, as well as ensure a perfect (unsampled) copy of the source image pixels. The <a href="#distort_viewport">Distort Viewport</a> can also specify an offset, so as to 'roll' the tiled images on the resulting image. <a name="cube3d" id="cube3d"></a>
            <h4>3d Cubes, using Affine Layering</h4>The '<code><a href="#affine">Affine</a></code>' distortion, with its control points is ideal for generating Orthographic, and Isometric Cubes (see Wikipedia, <a href="http://en.wikipedia.org/wiki/Orthographic_projection">Orthographic Projection</a> and <a href="http://en.wikipedia.org/wiki/Isometric_projection">Isometric Projection</a> for definitions), from three images. All that you need to do is figure out four control points on a destination image. As we will be using a <a href="../layers/#merge">Image Layering Technique</a> the points can even have negative values, and allows IM to adjust the final image size accordingly to the generated warped images. For this example I'll choose the control points '<code>0,0</code>' for the center of the cube, and three points equally spaced around that central point, at '<code>-87,-50</code>', '<code>87,-50</code>', and '<code>0,100</code>'. All that I then need to to is map the appropriate corners of three (preferably square) images to these control points.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="isometric_cube.png">
  magick \
     \( lena_orig.png -alpha set -virtual-pixel transparent \
        +distort Affine '0,512 0,0   0,0 -87,-50  512,512 87,-50' \) \
     \( mandrill_orig.png -alpha set -virtual-pixel transparent \
        +distort Affine '512,0 0,0   0,0 -87,-50  512,512 0,100' \) \
     \( pagoda_sm.jpg -alpha set -virtual-pixel transparent \
        +distort Affine '  0,0 0,0   0,320 0,100    320,0 87,-50' \) \
     \
     -background none -compose plus -layers merge +repage \
     -bordercolor black -compose over -border 5x2     isometric_cube.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="isometric_cube.png"><img src="isometric_cube.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that I used the <a href="#control_coordinates">Coordinates</a> of the actual edges of the image when distorting the image This means in mathematical terms the images should fit exactly together. Also note that I did not simply 'compose' (using the default <a href="../compose/#over">Over Alpha Composition</a>) the images together. If you did that you will get slightly transparent 'gaps' between the images. The correct way (as shown) is to use <a href="../compose/#plus">Plus Alpha Composition</a> to join 'edge connected' pieces, which will result in a perfect join without transparent gaps. For more information see <a href="../masking/#aligning">Aligning Two Masked Images</a>. Afterwards I added an extra border, and removed all transparency. It is not required, and you could easily use any background (or "<code>none</code>") but doing so will highlight any 'gap' you may have in your images.<br>
            <!-- <CODE EXECUTE>
  magick isometric_cube.png -crop 20x20+150+55\! -scale 500% \
          isometric_cube_zoom.png
</CODE> -->
             <a href="isometric_cube_zoom.png"><img src="isometric_cube_zoom.png" width="100" height="100" align="right" vspace="0" hspace="2" border="1" alt="[IM Output]"></a> Shown to the right is an enlargement of one such join in the image, showing the lack of any 'black-filled' gap along the join. For an alternative method of creating an isometric cube, without using "<a href="../option_link.cgi?distort"><code>-distort</code></a>", is given in <a href="../warping/#sheared_cube">Isometric Cube using Shears</a>. However this technique does not allow you use sub-pixel coordinates (not that I used any in the above, but I could have), but is restricted to positioning images using whole pixel (integers) coordinates. <a name="shadow3d" id="shadow3d"></a>
            <h4>3d Shadows, using Affine Shears</h4>The same layering methods used above can also be used to generate cool 3-dimensional shadows of odd shapes. That add a shadow of any 'flat' shape that is standing upright. For example lets create a shape with a flat base, so it could possibly stand upright.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -background None -virtual-pixel Transparent -fill DodgerBlue \
          -pointsize 72 -font Ravie  label:A   -trim +repage \
          -gravity South -chop 0x5  standing_shape.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="standing_shape.png"><img src="standing_shape.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the 'shape' has a flat base which is also the last row of the image. This is important as we will distort the shape along that row, so that the shadow will connect to standing shape alone that row. Here is the command to generate the 3-D shadow from this 'standing shape'
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick standing_shape.png   -flip +distort SRT '0,0 1,-1 0' \
          \( +clone -background Black -shadow 60x5+0+0 \
             -virtual-pixel Transparent \
             +distort Affine '0,0 0,0  100,0 100,0  0,100 100,50' \
          \) +swap -background white -layers merge \
          -fuzz 2% -trim +repage   standing_shadow.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="standing_shadow.jpg"><img src="standing_shadow.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The above does quite a few steps to achieve the result shown. The trickiest however is that first line. This flips the image then does a 'distort flip' back again. The result of this is that the bottom row is now located so that it has a value of Y=0 on the virtual canvas. That is, the whole image was given a negative offset to position it so that the bottom row passes through the origin of the virtual canvas. By doing this 'trick' we can use a very simple 'affine shear' on the extracted 'shadow' to distort it. We thus do not need to know the size of the shape image to distort the shadow, but still manage to keep everything 'lined up', as they all remain in-sync along the bottom (Y=0) row of the original image. You can adjust the direction the shadow falls and its length simply by adjusting the final coordinate ('<code>100,50</code>') of the 'affine shear'. The first two 'coordinate pairs' should not be modified as these 'lock' the shadow to the original image along the bottom row. Note however that right up until the last step all the images will contain negative virtual canvas offsets, so caution is advised if you plan to view or save the intermediate processing images. The only problem with this shadowing effect is that it is a 'universal blur'. That is, the shadow is not realistic. In reality the shadow should be sharp where it joins the 'standing shape' and getting more blurry as the shadow gets further way. This however can be done using a <a href="../mapping/#blur">Variable Blur Mapping</a>, such as used in <a href="../fonts/#var_blur">Distance Blurred Shadow Font</a>. <a name="shadow3d_var" id="shadow3d_var"></a>
            <h4>3D Shadow, using Perspective Compression</h4>This is another way to add variable blur to the shadow, though I don't actually recommend it, it is fairly simple to implement. This example was developed before <a href="../mapping/#blur">Variable Blur Mapping</a> was added to ImageMagick. Basically you first distort the initial shadow shape using a <a href="#perspective">Perspective Distortions</a> (which is looked at in detail below), so as to heavily compress the 'distant part' of the shadow, blurring it, then expanding that compression by distorting it to its final 'Affine Shear' position that we used above.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick standing_shape.png   -flip +distort SRT '0,0 1,-1 0' \
          \( +clone   -virtual-pixel Transparent -mattecolor None \
             +distort Perspective \
                '0,0 0,0  100,0 100,0   0,-100 45,-100   100,-100 60,-100' \
             -fuzz 2% -trim   -background Black -shadow 60x3+0+0 \
             +distort Perspective \
                '0,0 0,0  100,0 100,0   45,-100 -100,-50   60,-100 0,-50' \
          \) +swap -background white -layers merge \
          -fuzz 2% -trim +repage     standing_shadow_var.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="standing_shadow_var.jpg"><img src="standing_shadow_var.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This is almost exactly the same as the original <a href="#shadow3d">3D Shadowing Example</a>, but with some extra steps. The original shape is first distorted into a trapezoid, then any excess space is trimmed to speed up the next step. We then extract a blurred shadow from the distorted shape. Once the shadow image has been created from the distorted image, the same control points are used to un-distort the shadow image, and move it to its position as an Affine Shear. The key is that the shadow blurring happens to a distorted image, which is then un-distorted (and in this case Affine Sheared, at the same time). As a result the blur is also distorted and expanded so as to blur more around the top part of the shadow, and much less along the base line. As a result of the perspective blurring, we get a variable blur that should peak at about 100 pixels away from the ground base-line. As defined by the initial perspective blur control points. <a name="resize" id="resize"></a>
            <h3>Resize Images using Distort</h3>Both <a href="#distort">Distort</a> and <a href="../resize/">Resize</a> are actually very similar in many aspects. They are both image distortion operators, and both use <a href="#mapping">Reverse Pixel Mapping</a> to create the resulting image. They also both make use of the "<code><a href="../option_link.cgi?resize">-filter</a></code>" setting and its expert controls, for color determination, though they do so in a very different way. The <a href="../resize/">Resize</a> is a simplified (and much more common) image distortion operation, allowing you to make many optimizations. It is orthogonally aligned, allowing you to use a 2 pass orthogonal image filtering method in resize. That is, to say it first sizes in one dimension, then in the other, using an intermediate temporary image. Also as the scaling factor is constant over the whole destination image, with edges aligned to a whole pixel (integer) dimension, the algorithm can greatly simplify its processing and the caching requirements of the filter it uses. All these limitations allow for various optimizations that make it very fast in comparison to the work distort needs to do. Distort can also <a href="../resize/">Resize Images</a>, but does so in a single pass, that directly converts from the original image to the resulting new image. It does not need to align the edges to integer pixel positions, and could rotate, and scale each pixel position. In other words it is a much more general operator that requires it to do lot of extra processing for each pixel in the final result, with fewer places for optimization. To make <a href="#distort">Distort</a> generate an equivalent image as <a href="../resize/">Resize</a>, it needs to follow the exact same limitations, and use some complex image processing trickery. This was discussed on the IM forums, in <a href="../forum_link.cgi?p=68362">Correct Resize (using distorts)</a>, and resulted in an equivalent distort resize technique based on the use of the <a href="#affine">Affine Distortion Method</a>.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  The resulting '<b><code>Resize</code></b>' distortion method was added to ImageMagick version 6.6.9-2. The command line interface (CLI) version of this distortion will accept and magick the exact same <a href="../basics/#arg_geometry">Geometry Argument</a> as <a href="../resize/">Resize</a> does, including the slight discrepancy in scaling factors for the two dimensions, making this a direct resize alternative.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick logo:  -distort Resize 150x  logo_resized.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="logo_resized.png"><img src="logo_resized.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Other API interfaces to the '<b><code>Resize</code></b>' distortion method, will only accept two numbers as arguments, which are treated as the final integer size for the resulting image. At this time they will not accept an actual geometry argument with its various resize control flags, that modify the final image size. That is, flags such as percentage, only resize larger/smaller, or even aspect ratio preservation is not available.<br>
                <br>
                It is left to maintainers of those API's to add such support for this special image distortion method.</i></font></td>
              </tr>
            </table>The real difference between the above <a href="#resize">Distort Resize</a> and the normal <a href="../resize/">Resize Operator</a>, is that the distort version uses a much slower single pass <a href="../filter/#cylindrical">Cylindrical (elliptical) Filter</a>, for determining the final color of each and every pixel. In other words it provides a direct comparision of 2 pass orthogonal filters (resize), verses, an one pass but 2 dimentional cylindrical filters (distort resize). See <a href="../resize/#distort_resize">Distort vs Resize</a> for one just such comparison. <a name="resize_internals" id="resize_internals"></a>
            <h4>Distort Resize Internals</h4>The following is the equivalent operations that the above <a href="#resize">Distort Resize</a> performed internally.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code do_not_executed="">
  magick logo:  -alpha set -virtual-pixel transparent \
          +distort Affine '0,0 0,0   %w,0 150,0   0,%h 0,113' \
          -alpha off  -crop 150x113+0+0 +repage   distort_resize.png
</code></pre>
                  </td>
                </tr>
              </table>
            </div>The values '<code>150</code>' and '<code>113</code>' (used in two places) is the desired size of the final image to the nearest integer. It was calculated to try and best preserve the image aspect ratio, while keeping to the final integer size limitation. They are normally calculated by ImageMagick from the given resize <a href="../basics/#arg_geometry">Geometry Argument</a>, using a separate API function. It then enables transparency and transparent <a href="../misc/#virtual">Virtual Pixels</a>, so that external 'virtual pixels' do not take part in the calculation of the final pixel color. When the distortion is complete the transparency is again removed (turned off), and the 'buffer' pixels added by distort, is removed using a <a href="../crop/#crop">Image Crop</a>. Because of the use of transparent pixels, the above command will only work correctly for images that do not contain any transparency, such as the "<code>logo:</code>" built in image exampled above. This is the much more complex version, that is required to separate the effects of <a href="../misc/#virtual">Virtual Pixels</a> from any possible existing transparency in the image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code do_not_execute="" executed="">
  magick logo: -alpha set -virtual-pixel transparent \
          \( +clone -alpha extract -alpha opaque \) \
          +distort Affine '0,0 0,0   %w,0 150,0   0,%h 0,113' \
          -alpha off -crop 150x113+0+0 +repage \
          -compose CopyOpacity -composite      distort_resize_trans.png
</code></pre>
                  </td>
                </tr>
              </table>
            </div>This does two distorts: first to distort the image and then to distort the alpha (transparency) channel separately, in each case using transparent to remove virtual-pixel effects. As a result it is at least twice as slow as the one when no transparency is present in the original image. Both the these techniques are implemented internally by the <a href="#resize">Distort Resize Method</a>. As such this 'method' is really a convenience 'macro' for users, an not actually a real distortion method, which is an 'affine' distortion.<br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="perspective" id="perspective"></a>
            <h2>Four Point Distortion Methods</h2>
            <h3>Perspective Distortion</h3>Probably the most common requested type of distortion, has been for a fast perspective distortion operation. This is a 4 point distortion, so requires at least 4 sets of control point pairs, or 16 floating point values. For example, here I have an image building. From this image I manually discovered the location of 4 points (red). I also defined the final location to which I those points transformed to in the final image (blue), so as to 'straighten' or 'rectify' the face of the building.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick building.jpg \
          -draw 'fill none stroke red polygon 7,40 4,124, 85,122, 85,2' \
          building_before.jpg
  magick building.jpg \
          -draw 'fill none stroke blue polygon 4,30 4,123, 100,123, 100,30' \
          building_after.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/building.jpg"><img src="../img_photos/building.jpg" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="building_before.jpg"><img src="building_before.jpg" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <a href="building_after.jpg"><img src="building_after.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>To do the actual image distortion, you only need to feed those coordinates into the '<code>perspective</code>' method of "<a href="../option_link.cgi?distort"><code>-distort</code></a>".
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick building.jpg -alpha set -virtual-pixel transparent \
         -distort Perspective \
              '7,40 4,30   4,124 4,123   85,122 100,123   85,2 100,30' \
          building_pers.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/building.jpg"><img src="../img_photos/building.jpg" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="building_pers.png"><img src="building_pers.png" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a>
            </div>Notice the blank area on the top right, where the distortion 'missed' the pixel data in the source image. What IM does in this situation is controlled by the "<a href="../option_link.cgi?virtual-pixel"><code>-virtual-pixel</code></a>" setting (see <a href="../misc/#virtual-pixel">Virtual Pixel</a>). What is less noticeable is that a small amount of the left-most edge of the original image is also 'lost' for the same reason. As a matter of interest lets also reverse the distortion, by swapping the coordinates of each mapping pair. This lets us see just how much of the image is degraded by the distortion.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick building_pers.png  -alpha set -virtual-pixel transparent \
         -distort Perspective \
              '4,30 7,40   4,123 4,124   100,123 85,122   100,30 85,2' \
          building_pers_rev.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/building.jpg"><img src="../img_photos/building.jpg" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="building_pers.png"><img src="building_pers.png" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="building_pers_rev.png"><img src="building_pers_rev.png" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a>
            </div>Not bad. A lot of 'fuzziness' is present, but that can't be helped. Notice that the 'fuzziness' is worse on the right side of the image where it was compressed the most. All distorts suffer from this compression problem, as such you should always try to distort from an original image, rather than distorting an already distorted image. Here is another example, of using this transform, using the special checkerboard test image we created above, which we distort then reverse the distortion.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png        -alpha set    -virtual-pixel transparent \
          -distort Perspective '0,0,0,0  0,90,0,90  90,0,90,25  90,90,90,65' \
          checks_pers.png
  magick checks_pers.png   -alpha set    -virtual-pixel transparent \
          -distort Perspective '0,0,0,0  0,90,0,90  90,25,90,0  90,65,90,90' \
          checks_pers_rev.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="checks.png"><img src="checks.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="checks_pers.png"><img src="checks_pers.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="checks_pers_rev.png"><img src="checks_pers_rev.png" width="90" height="90" align="middle" vspace="5" hspace="25" border="0" alt="[IM Output]"></a>
            </div>You can see the slight fuzziness caused by image compression, but the image is basically restored. What actually happens is that IM uses all the control point pairs given to calculate the appropriate coefficients for a '<code><a href="#perspectiveprojection">Perspective Projection</a></code>' (see next). If you include a <a href="#distort_verbose">Verbose</a> setting, you can see both the coefficients, and the <a href="../transform/#fx">DIY FX Equivalent</a> that is being used internally by IM to perform this distortion. If only 3 or less control point pairs are provided, IM will automatically fall back to the simpler '<code><a href="#affine">Affine</a></code>' distortion. While more that 4 points (for '<i>Image Registration</i>') will be <a href="#control_leastsq">Least Squares Fitted</a> to find the best fitting distortion for all the given control points. <i>FUTURE: Alternative. The four coordinates could also represent a triangle and center point. You can fix the triangle and move the center point, or fix that center and move the other three coordinates, to generate the perspective view.</i> If you like to see more detail of how the distortion works, look at the <a href="#perspective_internals">Perspective Internals</a> below. You can also look at a Postscript implementation that was presented in a PDF paper <a href="http://www.fho-emden.de/~hoffmann/persprect13052005.pdf">Perspective Rectification</a>, by <i>Gernot Hoffmann</i>. Also have a look at <a href="http://www.leptonica.com/affine.html">Leptonica Affine and Perspective Transforms</a>.<br>
            <a name="horizon" id="horizon"></a>
            <h3>Viewing Distant Horizons</h3>You can produce some very unusual effects using <a href="#perspective">Perspective Distortions</a> if you adjust the coordinates to produce a 'vanishing point' within the boundaries of the image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png -mattecolor DodgerBlue \
          -virtual-pixel background -background Green \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          checks_horizon.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="checks_horizon.png"><img src="checks_horizon.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Well we used '<code>Green</code>' for the virtual pixels that 'surround' the original image image, which we enabled using <a href="../misc/#background">Virtual Pixel Background Settings</a>. But what is more interesting is the appearance of the 'blue' color that was defined using the "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" setting. This 'blue' color represents an area where the pixels generated by the distortion is <i>invalid</i>, and in such areas the "<a href="../option_link.cgi?distort"><code>-distort</code></a>" operator will just output the "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" setting. For a <a href="#perspective">Perspective Distortion</a>, any pixel ending up in the 'sky' of the resulting image will be classed as invalid. Also it defines the 'sky' as being the side of the 'horizon' on which the source image will not appear. The 'sky' will only appear in perspective distorted images when the resulting image is highly foreshortened by the distortion. If you don't want a 'sky' in your final image result then the best idea is to set both "<code><a href="../option_link.cgi?background">-background</a></code>" and "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" to use the same color. The <a href="#perspective">Perspective Distortion</a> gets more interesting when one of the special infinite tiling <a href="../misc/#virtual-pixel">Virtual Pixel</a> settings are used. For example, here we used a '<code><a href="../misc/#tile">tile</a></code>' setting to generate an infinitely tiled plane.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png  -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="horizon_tile.png"><img src="horizon_tile.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>A word of warning about this image. Asking for an infinitely tiled image is <i>very slow</i> to generate. The larger the image the slower it gets. You can monitor the progress of the "<code><a href="../option_link.cgi?distort">-distort</a></code>" (or any other slow image processing task) using the "<code><a href="../option_link.cgi?monitor">-monitor</a></code>" <a href="../basics/#controls">Operational Control Setting</a>. Basically for a single pixel that is close to the horizon, ImageMagick will need to average a huge number of pixels from the original image to figure out the appropriate color. This can take a very long time. ImageMagick does try to limit the amount of time it uses to handle these near-horizon pixels, by caching information, and using some in-built knowledge of various <a href="../misc/#virtual-pixel">Virtual Pixel</a> settings, but it can still take a long time. For more details of this method see <a href="#area_resample">Area Resampling</a> above. Another infinitely tiled perspective image can be generated by using a <a href="../misc/#random">Random Virtual Pixel Setting</a>...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick checks.png  -virtual-pixel random -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_random.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="horizon_random.png"><img src="horizon_random.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>What is happening is that all virtual pixels surrounding the image are just random picks of any pixel within the image itself. The result is a ground consisting of random noise that gets smoother and more blurred as you look toward the horizon of the image. It gives a natural feeling of depth, without any specific repeating pattern. Here I repeated the above but with a pure black and white source image. However I am not interested in the actual distorted image, only the <a href="../misc/#virtual-pixel">Virtual Pixel</a> '<code>random</code>' pattern that was generated, so I changed what part of the 'distorted image space' I am looking at, by using a special '<code>-set&nbsp;option:distort:viewport</code>' setting. This setting overrides the normal size and location of the area of distorted space being viewed. In this case an area only containing virtual pixels, and not the distorted image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 90x90 pattern:gray50 -alpha set \
       -virtual-pixel random -mattecolor none \
       -set option:distort:viewport 120x120+100-15 \
       -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
       +repage -size 120x50 gradient:dodgerblue-tomato \
       -compose DstOver -composite    sunset_horizon.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sunset_horizon.png"><img src="sunset_horizon.png" width="120" height="120" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>To complete the image I removed the viewport offset (using "<code><a href="../option_link.cgi?repage">+repage</a></code>" ), and <a href="../compose/#dstover">Underlaid or DstOver</a> a gradient of sunset colors into the transparent 'sky' (set using "<code><a href="../option_link.cgi?mattecolor">alpha setmattecolor</a></code>") . A very interesting image that could be used as a backdrop for some other image processing work. You can adjust the distortion parameters to adjust the height and slope of the horizon.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Here is a more traditional test of a tiled perspective distortion.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:checkerboard -scale 120x120 -normalize \
          -virtual-pixel tile  -distort Perspective \
             '0,0 10,61   119,0 60,60   0,119 5,114   119,119 125,110' \
          checkered_plain.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="checkered_plain.gif"><img src="checkered_plain.gif" width="120" height="120" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>In my studies I found the above test to be misleading, as it gives no real indication of the quality of the area resampling technique for near unity scales of an image (foreground area, rather than distant areas). That is a close look at the resampling problems such as described in <a href="../filter/#artifacts">Resampling Artefacts</a>. This last image also shows a 'cutoff' point close to the horizon where ImageMagick decided that it was not worth attempting to determine the appropriate color for a pixel (with consideration of the current virtual pixel setting), but short-circuit the EWA algorithm and use the average color of the whole image. It is only visible in this image because of the large scale diagonal pattern of color that is present in the image. The average color of an image is only calculated once per distortion operation, and only when first needed. By using it ImageMagick saves a huge amount of time calculating colors close to the horizon when typically the result will be the images average color. This happens when either the ellipse become so elongated as to exceed floating point limits, or the number of sampling pixels (bounding parallelogram of elipse) becomes 4 times larger than the input source image. This is currently not user setable.<br>
            <a name="box3d" id="box3d"></a>
            <h3>3d Boxes, Perspective Layering</h3>The 'plus' form of "<a href="../option_link.cgi?distort"><code>+distort</code></a>" which ensures the whole distorted image is preserved in a correctly positioned layer (or 'virtual-canvas') is designed so that if the same 'control points' used to distort images, those point will line up in 'virtual-space'. This means that if the images are <a href="../layers/#merge/">Layer Merged</a> together, those images will also line-up according to the control points. For example, here we generate two images, a 'front' and a 'spine' image, so that two edge control points are lined with each other, to form the spine of a box.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  # Generate a Spine Image
  magick -size 200x40 xc:skyblue \
    -pointsize 20 -gravity north -annotate +5+0 'IM Examples' \
    -pointsize 10 -gravity south -annotate +0+0 'ImageMagick' \
    -stroke blue -strokewidth 2 -draw 'line 30,0 30,40' \
    -rotate -90 box_spine.jpg

  # generate the front cover
  magick -size 150x200 xc:skyblue \
    -fill black -pointsize 20 -gravity north -annotate +0+5 'IM Examples' \
    -fill blue -pointsize 15 -gravity northeast -annotate +5+28 'Box Set' \
    -fill black -pointsize 15 -gravity south -annotate +0+5 'ImageMagick' \
    -stroke blue -strokewidth 2 -draw 'line 0,169 150,169' \
    \( logo.gif -resize 100x100 \) \
    -gravity center -compose multiply -composite box_front.jpg

  # Distort both images and merge using common points.
  magick \
    \( box_spine.jpg -alpha set -virtual-pixel transparent \
       +distort Perspective \
           '0,0 -30,20  0,200 -30,179  40,200 0,200  40,0 0,0' \) \
    \( box_front.jpg -alpha set -virtual-pixel transparent \
       +distort Perspective \
           '0,0 0,0  0,200  0,200  150,200 100,156  150,0 100,30' \) \
    \
    -background black -compose plus -layers merge  +repage \
    -bordercolor black -compose over -border 15x2    box_set.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="box_spine.jpg"><img src="box_spine.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="box_front.jpg"><img src="box_front.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="box_set.jpg"><img src="box_set.jpg" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Also note the use of <a href="../compose/#plus">Plus Alpha Composition</a> to join 'edge connected' pieces. This is required to prevent the generation of a 'semi-transparent gap' between the two images. For more information see <a href="#cube3d">3D Cube</a> example above, as well as <a href="../masking/#aligning">Aligning Two Masked Images</a>. Using positions like this means that almost all the 'spine' image is actually distorted into a negative 'x' position. The resulting image thus has a negative offset on the virtual canvas. IM has no problems doing this when using the layering "<a href="../option_link.cgi?distort"><code>+distort</code></a>" version of the operator. The <a href="../layers/#merge">Layers Merge</a> operator also is designed to handle layering images with negative offsets, 'stitching' the two images together cleanly. I still need to use a final "<a href="../option_link.cgi?repage"><code>+repage</code></a>" to remove that negative offset from the final image, after they have been 'merged' together. If I don't other programs like web browsers may not understand such negative offsets, and cause undefined effects. The above is example has also been placed in the shell script "<b><code><a href="../scripts/box_set_example">box_set_example</a></code></b>" so that you can download and play with it more conveniently. You can take this further to also add mirror images of the 'box' being reflected by surface on which it sits, though you may also like to recolor or dim that image in some way to make it more realistic. See <a href="../advanced/#reflections">Reflections</a> for such mirror techniques.<br>
            A further example in PHP, was developed in a discussion on Wrapping 'photos' over a borderless canvas frame. See <a href="../forum_link.cgi?f=1&amp;t=21239">Canvas wrap transformation</a>, for more details.<br>
            To finish off with here is a fantastic example by Jean-François Hren for <a href="http://www.animecoversfan.com/">www.animecoversfan.com</a> which was heavily discussed on the <a href="../forum_link.cgi?t=11726">IM Discussion Forums</a>.
            <div align="center"><img src="../img_diagrams/video_box_example.png" width="419" height="253" align="middle" vspace="5" hspace="5" border="0" alt="[Diagram]"></div>This image was created by taking an artistic image of an anime video box cover, splitting up that cover into 3 segments ('cover', 'spine', and 'back'), distorting each separately, into layered images, adding a fourth 'disk' image, and merged together. The image was then finished by the addition of highlights and shading effects (using <a href="../compose/#hardlight">HardLight</a> image composition), and the addition of border and semi-transparent shadow effects (using <a href="../compose/#copyopacity">CopyOpacity</a>). What is more amazing is the whole process was done by a single "<code>magick</code>" command, from the input images. It is an excellent example of just what IM can do, and the process by which a complex command script can be generated. I recommend reading the <a href="../forum_link.cgi?t=11726">forum discussion</a> as it contains a lot of hints, tips, and general debugging techniques. <i>(More Contributed examples welcome)</i> <a name="perspective_projection" id="perspective_projection"></a>
            <h3>Perspective Projection Distortion</h3>Just as the '<code><a href="#affine">Affine</a></code>' distortion can be handled directly giving the mathematical coefficients for a '<code><a href="#affine_projection">Affine Projection</a></code>', so to '<code><a href="#perspective">Perspective</a></code>' can also be handled by 8 coefficients of a '<code>Perspective Projection</code>' distortion. As before, these numbers represent the coefficents used for the <a href="#forward_mapping">Forward Mapping</a> of points in the source image to the destination image. That is, they are the mathematical values used to map a source image <code>x,y</code> to a destination image <code>i,j</code>. The 8 floating point arguments are (in the order given)...
            <table align="center">
              <tr>
                <td><code>s<sub>x</sub>, r<sub>y</sub>, t<sub>x</sub>,<br>
                r<sub>x</sub>, s<sub>y</sub>, t<sub>y</sub>,<br>
                p<sub>x</sub>, p<sub>y</sub></code></td>
              </tr>
            </table>These coefficient values in turn form the expression..
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td rowspan="3"><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>s<sub>x</sub>*X<sub>s</sub> + r<sub>y</sub>*Y<sub>s</sub> + t<sub>x</sub></code></td>
                <td rowspan="3">&nbsp; , &nbsp; &nbsp; &nbsp;</td>
                <td rowspan="3"><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>r<sub>x</sub>*X<sub>s</sub> + s<sub>y</sub>*Y<sub>s</sub> + t<sub>y</sub></code></td>
                <td></td>
              </tr>
              <tr>
                <td>
                  <hr>
                </td>
                <td>
                  <hr>
                </td>
              </tr>
              <tr>
                <td align="center"><code>&nbsp;p<sub>x</sub>*X<sub>s</sub> + p<sub>y</sub>*Y<sub>s</sub> + 1.0&nbsp;</code></td>
                <td align="center"><code>&nbsp;p<sub>x</sub>*X<sub>s</sub> + p<sub>y</sub>*Y<sub>s</sub> + 1.0&nbsp;</code></td>
              </tr>
            </table>Where "<code>X<sub>s</sub>,Y<sub>s</sub></code>" are source image coordinates and "<code>X<sub>d</sub>,Y<sub>d</sub></code>" are destination image coordinates. Internally ImageMagick Distort will reverse the above equations so as to do the appropriate <a href="#mapping">Reverse Pixel Mapping</a> to map "<code>X<sub>d</sub>,Y<sub>d</sub></code>" coordinates to lookup the color at "<code>X<sub>s</sub>,Y<sub>s</sub></code>" in the source image. The first 6 values of the '<code>Perspective Projection</code>' is in fact the same coefficients to that of the '<code><a href="#affine_projection">Affine Projection</a></code>', though they are slightly reordered to be more logical (in 'matrix math' terms, the first 6 elements have been diagonally transposed). The extra two arguments <code>p<sub>x</sub>,p<sub>y</sub></code> form a scaling divisor to the whole distortion which causes the image to look smaller in the specific direction according to the values given, and thus giving the distorted image the perspective 'distance' effect. If these two values are set to zero, the '<code>Perspective Projection</code>' distortion becomes equivalent to a '<code>Affine Projection</code>' For example...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr td="" width="10%" align="justify" rowspan="2">
                <td width="90%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -virtual-pixel transparent \
          -distort Perspective-Projection \
             '1.40, 0.25, 3.0    0.15, 1.30, 0.0    0.007, 0.009' \
          perspective_projection_rose.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="perspective_projection_rose.png"><img src="perspective_projection_rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Remember the matrix you give is the forward projective matrix, that will map source image coordinates to destination image coordinates. Internally ImageMagick will reverse the matrix so it can map destination image coordinates to source image coordinates. If you like to see what those values are use the <a href="#distort_verbose">Verbose Distortion Option</a>, to get IM output its internal coefficients as a <a href="../transform/#fx">FX Operator Expression</a> (see next). <a name="perspective_internals" id="perspective_internals"></a>
            <h3>Perspective Internals</h3>If you add "<a href="../option_link.cgi?verbose"><code>-verbose</code></a>" (see <a href="#distort_verbose">Verbose Distortion Summery</a> above) just before the Perspective distortion IM will output two operators that should be near equivalent replacements to the "<a href="../option_link.cgi?distort"><code>-distort</code></a>" operator. One is a VERY SLOW "<a href="../option_link.cgi?fx"><code>-fx</code></a>" version (See <a href="../transform/#fx">FX DIY operator</a>. The other will be the Forward mapping Perspective_Projection matrix. For example...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr td="" width="10%" align="justify" rowspan="2">
                <td width="90%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" err="perspective_verbose.txt">
  magick rose: -alpha set -virtual-pixel transparent -verbose \
          -distort Perspective "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          +verbose perspective_rose.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="perspective_rose.png"><img src="perspective_rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td>
                  <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <a href="perspective_verbose.txt"><img src="perspective_verbose.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>The first section <i>Perspective Projection</i> can be used to map source coordinates into destination coordinates. The formula is as above.
            <div align="center">
              <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
                <tr>
                  <td><code>&nbsp; i = ( 1.430099*x +0.246650*y +3 )/( 0.006757*x + 0.009448*y +1 ) &nbsp;<br>
                  &nbsp; j = ( 0.147296*x +1.434591*y +0 )/( 0.006757*x + 0.009448*y +1 ) &nbsp;</code></td>
                </tr>
              </table>
            </div>An example of extracting and using these values is showing in the last set of examples in <a href="../layers/#layer_distort">Positioning Distorted Layer Images</a>. On the other hand the second FX equivalent section uses a different set of 8 coefficients, which performs the <a href="#mapping">Reverse Pixel Mapping</a> an image distortion actually needs to apply. Namely...
            <div align="center">
              <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
                <tr>
                  <td><code>&nbsp; x = ( 0.711858*i -0.108326*j -2.135575 )/(-0.004119*i -0.005877*j +1 ) &nbsp;<br>
                  &nbsp; y = (-0.073090*i +0.699571*j +0.219269 )/(-0.004119*i -0.005877*j +1 ) &nbsp;</code></td>
                </tr>
              </table>
            </div>Note in the output <i>FX equivelent</i> formula the divisor coefficients are used first as they are common to both X and Y coordinate equations. Remember all the coordinates that you give are in image coordinates, not pixel coordinates, see <a href="#control_coordinates">Image Coordinates vs Pixel Coordinates</a> for details. As such any pixel position will need 0.5 added to the input pixel coordinate, before applying the above, and then subtract 0.5 from the final coordinate, to magick it back into pixel (draw) coordinates. You can see this being applied in the <i>FX equivalent</i> code above. The final test in the FX equivalent, just before the source image lookup, handles the invalid 'sky' pixels, where the destination fails to map to the source image correctly. However it will just substitute '<code>blue</code>' for such pixels instead of the "<a href="../option_link.cgi?mattecolor"><code>-mattecolor</code></a>", and does not provide any horizon anti-aliasing that the internal algorithm provides for the perspective distortion.<br>
            <b>Example of perspective forward mapping...</b> These mappings let you magick a specific coordinate in one image to a location in the other image (either direction). For example, a dark point in the center of the source rose image is at pixel coordinates '<code>39,20</code>'. Mapping that to image coordinates by adding ½ to get '<code>39.5,20.5</code>'. Now we can use the x,y to i,j equations to map that to destination image coordinates '<code>44.2,24.1</code>'. And finally to 'draw' pixel coordinates by subtracting ½ and we get the final position of '<code>43.7,23.6</code>'. And here I mark that coordinate using a circle on both the input and output images..
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -fill none -stroke black \
          -draw 'circle 39,20 39,24'    rose_marked.png

  magick perspective_rose.png -fill none -stroke black \
          -draw 'circle 43.7,23.6 43.7,26.6'  perspective_rose_marked.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="rose_marked.png"><img src="rose_marked.png" width="70" height="46" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="perspective_rose_marked.png"><img src="perspective_rose_marked.png" width="70" height="46" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>As you can see the same point in the perspective distorted image has been correctly located in both images (even down to a sub-pixel level)! <a name="bilinear" id="bilinear"></a>
            <h3>Bilinear Distortions</h3>The '<code>Bilinear</code>' distortion methods implements another, type of 4 point distortion. However this are not nearly as straight forward as a '<code><a href="#perspective">Perspective</a></code>' distortion we looked at above. But as you will see it is a very useful alternative distortion. <a name="bilinear_forward" id="bilinear_forward"></a>
            <h4>Forward Bilinear Distortion</h4>For example lets take a special test image of a mandrill that has had a grid overlaid on it, and distort it with perspective and bilinear.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_grid.jpg -alpha set -virtual-pixel black \
       -distort Perspective \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_pers.jpg
  magick mandrill_grid.jpg -alpha set -virtual-pixel black -interpolate Spline \
       -distort BilinearForward \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin.jpg
</samp></pre>
                  </td>
                </tr>
              </table>
              <table>
                <tr>
                  <td align="center">
                    <a href="../img_photos/mandrill_grid.jpg"><img src="../img_photos/mandrill_grid.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Original</font>
                  </td>
                  <td><img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"></td>
                  <td align="center">
                    <a href="mandrill_pers.jpg"><img src="mandrill_pers.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Perspective</font>
                  </td>
                  <td align="center">
                    <a href="mandrill_blin.jpg"><img src="mandrill_blin.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Bilinear</font>
                  </td>
                </tr>
              </table>
            </div>First you should notice that both distortions correctly mapped the image from one set of control points to the other set of points. Also all horizontal and vertical lines in the source image also remain straight, in both distortions. However there the simalities end. Perspective will reduce the spacing between lines so that even the diagonal lines remain straight. This results in the areas of the squares becomming smaller, and thus giving the top-right corner a realistic 'in the distance' look. Bilinear on the other hand does not make one side of the image look 'further away', nor does it try to keep lines straight. What it tries to do is keep all the spacings between the lines constant, but this results in the diagonal line becomming curved. That is, it preserves the distance ratios along any given line. That is, the relative lengths each line segment remains the same along the whole length of the line, even though the line itself may be bent, curved, or shortened as a whole. That means the grid spacing in the above example remains constant scale across the whole image, and the distorted square at the top-right is still about the same size as the distorted square at the bottom-left. The image remains 'flat looking', just distorted into a different shape. Note that (forward) bilinear does ensure that any horizontal or vertical lines in the original image will remain straight in the final image. That is, it will take an orthogonally aligned rectangle and transform it into the specified quadrilateral, so that each of the sides of the original rectangle remains straight with constant scaling over the whole line. It is this aspect of the distort that makes a '<code>BilinearForward</code>' distortion useful in much more complex 'grid' distortions. That is, because two neighbouring 'quadrilaterals' even though they may be distorted very differently will still correctly line up correctly edge-to-edge. Here is another comparison between '<code><a href="#perspective">Perspective</a></code>' and '<code><a href="#bilinear_forward">BilinearForward</a></code>', using a very severe distortion of the built-in rose image...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
<br>  magick rose: -alpha set -virtual-pixel transparent \
          -distort Perspective "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          perspective_rose.png
  magick rose: -alpha set -virtual-pixel transparent -interpolate Spline \
          -distort BilinearForward "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          bilinear_rose.png
</samp></pre>
                  </td>
                </tr>
              </table>
              <table>
                <tr>
                  <td align="center">
                    <a href="../images/rose.png"><img src="../images/rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a><br>
                    <font size="-1">Original</font>
                  </td>
                  <td><img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"></td>
                  <td align="center">
                    <a href="perspective_rose.png"><img src="perspective_rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a><br>
                    <font size="-1">Perspective</font>
                  </td>
                  <td align="center">
                    <a href="bilinear_rose.png"><img src="bilinear_rose.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a><br>
                    <font size="-1">Bilinear</font>
                  </td>
                </tr>
              </table>
            </div>To achieve its goals (preserving all straight lines) the Perspective Distortion seems to 'suck' just about the whole image into the smaller area to the right, while the Bilinear distortion kept the centered rose, centered in its results. Again it preserved distance ratios, keeping the rose equally spaced between the left and right edges. All in did was to simply vertically compress the height of the image linearly along its length. This aspect of a '<code>BilinearForward</code>' distortion makes it also known as a 'Trapezoidal' distortion. That is, simply compress the image linearly in one direction, when only one direction being scaled. that compression direction can even be angled, rather than aligned along one axis.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Note that due to the complexity of the reverse pixel mapping needed to perform a '<code>BilinearForward</code>' distortion, the <a href="#area_resample">Area Resampling</a> is currently turned off.<br>
                <br>
                As such areas of extreme compression (more than a factor of 2) will likely show some aliasing effects (see the edges of the lines in the examples above. However using <a href="#super_sample">Super-Sampling</a>, or '<code>-interpolate Spline</code>' can be used to improve the quality of the final image.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Before IM v6.5.7-0 the '<code>BilinearForward</code>' distortion was still in development and had problems with specific 'degenerate' cases, that could cause a 'black' error image in specific situations.</i></font></td>
              </tr>
            </table><a name="bilinear_reverse" id="bilinear_reverse"></a>
            <h4>Reversed Bilinear Distortion</h4>Because only horizontal and vertical lines remain straight you can not use a '<code>BilinearForward</code> distortion to reverse the distortion. As the grid lines in the transformed image are no longer horizontal or vertical, they will no longer remain straight in the resulting image! For example swapping coordinate pairs, and re-applying the 'forward' distortion (such as we did using the '<code><a href="#perspective">Perspective</a></code>' distortion above) will fail to recover the original image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_blin.jpg -alpha set -virtual-pixel black \
       -distort BilinearForward \
              '26,0 0,0   114,23 128,0   128,100 128,128  0,123 0,128' \
       mandrill_blin_back.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="mandrill_blin.jpg"><img src="mandrill_blin.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="mandrill_blin_back.jpg"><img src="mandrill_blin_back.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>Note that the actual coordinates specified did actually position themselves correctly, but the image distortion has not been reversed. In summery a '<code><a href="#bilinear_forward">BilinearForward</a></code>' distortion is NOT its own reverse. To restore the image you need to use a slightly different but closely related distortion. The mathematical reverse of the 'geometric transformation' has been implemented as a '<code>BilinearReverse</code>' distortion. For example...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_blin.jpg -alpha set -virtual-pixel black \
       -distort BilinearReverse \
              '26,0 0,0   114,23 128,0   128,100 128,128  0,123 0,128' \
       mandrill_blin_rev.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="mandrill_blin.jpg"><img src="mandrill_blin.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="mandrill_blin_rev.jpg"><img src="mandrill_blin_rev.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>As previously stated, due to the complexity of a '<code><a href="#bilinear_forward">BilinearForward</a></code>' distortion, the <a href="#area_resample">Area Resampling</a> is currently turned off, which in the above causes sever aliasing effects.</i></font></td>
              </tr>
            </table>The '<code><a href="#bilinear_reverse">BilinearReverse</a></code>'has the same distance ratio preserving features of a '<code>BilinearFoward</code>' but will magick any quadrilateral into an orthogonally aligned rectangle, ensuring the sides of the quadrilateral remain straight when mapped to a vertical and horizontal alignment. As you can see in the above.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Before IM v6.5.1-2 the '<code>BilinearReverse</code>' distortion was implemented simply as '<code>Bilinear</code>'.</i></font></td>
              </tr>
            </table>Some implementations of a bilinear distortion (including older versions of IM and the <a href="http://www.leptonica.com/local-sources.html">Leptonica Library</a>) only implemented the above simpler (reversed) version of Bilinear distortion. However such a distortion is not very well suited to 'forward mapping' a rectangular image. For example, here I try to use a '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' for an distortion which should probably have used a '<code><a href="#bilinear_forward">BilinearForward</a></code>' distortion.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_grid.jpg -alpha set -virtual-pixel black \
       -distort BilinearReverse \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin_rev2.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/mandrill_grid.jpg"><img src="../img_photos/mandrill_grid.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="mandrill_blin_rev2.jpg"><img src="mandrill_blin_rev2.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>As you can see as the destination quadratrial was not an orthogonal rectangle the image was severely distorted producing lots of inward curving lines. <a name="bilinear_tiling" id="bilinear_tiling"></a>
            <h4>Tiled Bilinear Distortions</h4>Now while a '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' produces 'curved' images from rectangular ones. The effect does produce interesting tile patterns that seem to generate curved 3-dimentional looking surfaces. For example by applying the same transformation as was used for <a href="#horizon">Viewing Distant Horizons</a> above we get this interesting result.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png  -virtual-pixel tile  -mattecolor DodgerBlue \
          -distort BilinearReverse \
               '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          bilinear_rev_tile.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="bilinear_rev_tile.png"><img src="bilinear_rev_tile.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>In actual fact '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' will never produce a 'horizon' (invalid pixels). On the other hand, using '<code><a href="#bilinear_forward">BilinearForward</a></code>' tends to produce 'sky' or 'invalid pixels' (filled with the current "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>") quite regularly. In fact the tile pattern tends to go rather crazy...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png  -virtual-pixel tile  -mattecolor DodgerBlue \
          -interpolate Spline  -distort BilinearForward \
               '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          bilinear_fwd_tile.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="bilinear_fwd_tile.png"><img src="bilinear_fwd_tile.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>As previously stated, due to the complexity of a '<code><a href="#bilinear_forward">BilinearForward</a></code>' distortion, the <a href="#area_resample">Area Resampling</a> is currently turned off, which in the above causes sever aliasing effects.</i></font></td>
              </tr>
            </table>As such I do not recommend using a tiled form of '<code><a href="#bilinear_forward">BilinearForward</a></code>'. However I do recommend you define an appropriate "<code><a href="../option_link.cgi?mattecolor">-mattecolor</a></code>" when using the forward distortion, to prevent the appearance of unexpected gray patches of 'sky'. <a name="bilinear_internals" id="bilinear_internals"></a>
            <h4>Bilinear Internals</h4>The actual formula for mapping a coordinate in the source image to a destination image using a '<a href="#bilinear_forward">Forward Mapped Bilinear Distortion</a> is...
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td rowspan="3"><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>0</sub>*X<sub>s</sub> + C<sub>1</sub>*Y<sub>s</sub> + C<sub>2</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>3</sub></code></td>
                <td rowspan="3">&nbsp; , &nbsp; &nbsp; &nbsp;</td>
                <td rowspan="3"><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>4</sub>*X<sub>s</sub> + C<sub>5</sub>*Y<sub>s</sub> + C<sub>6</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>7</sub></code></td>
              </tr>
            </table>However because IM implements distortions using the <a href="#mapping">Reversed Pixel Mapping</a> technique, the above formula needs to be reversed. A complex process that requires the solving of a quadratic equation, square roots, and a whole page fill of algebra. If you ask IM to <a href="#distort_verbose">Verbosely</a> output the FX equivalent, you will see this complexity. For example using the checks image we created previously...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr td="" width="10%" align="justify" rowspan="2">
                <td width="90%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" err="bilinear_verbose.txt">
  magick checks.png -alpha set -virtual-pixel transparent -mattecolor none \
      -interpolate Spline -verbose -distort BilinearForward \
                   '0,0,0,0  0,90,0,90  90,0,60,30  90,90,90,90' \
      +verbose bilinear_checks.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="bilinear_checks.png"><img src="bilinear_checks.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td>
                  <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <a href="bilinear_verbose.txt"><img src="bilinear_verbose.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>The '<code>(rt &gt; 0 ) ? red :</code>' check in the final line of the '<i>FX equivalent</i>' is to avoid an invalid negative square root. This is the check that creates the 'sky' effect that was shown in the previous examples.On the other hand, as the <a href="#bilinear_reverse">Reversed Bilineaer Distortion</a> is much simpler, as you can directly apply the simpler polynomial equation, to reverse the previous distortion...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr td="" width="10%" align="justify" rowspan="2">
                <td width="90%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" err="bilinear_rev_verbose.txt">
  magick bilinear_checks.png  -virtual-pixel transparent \
      -verbose -distort BilinearReverse \
                   '0,0,0,0  0,90,0,90  60,30,90,0  90,90,90,90' \
      +verbose bilinear_checks_rev.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="bilinear_checks_rev.png"><img src="bilinear_checks_rev.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td>
                  <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <a href="bilinear_rev_verbose.txt"><img src="bilinear_rev_verbose.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>As you can see the resulting equations is very simple, as we are now applying it to do a <a href="#mapping">Reversed Pixel Mapping</a> of destination coordinates to source image coordinates.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The aliasing effects seen in the above is being cause by '<code><a href="#bilinear_forward">BilinearForward</a></code>', and not by the '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' distort. This is because currently <a href="#area_resample">Area Resampling</a> is turned off for the 'forward' mapped version due to its complexity.</i></font></td>
              </tr>
            </table>For further reading I direct you to <a href="http://www.leptonica.com/affine.html">Leptonica Affine and Perspective Transforms</a>. <a name="bilinear" id="bilinear"></a>
            <h4>Combined Bilinear Distortion</h4>
            <div align="center">
              <font size="+2"><b><img src="../img_www/const_barrier.gif" width="39" height="35" align="top"> Under Construction <img src="../img_www/const_hole.gif" width="144" height="50" align="middle"></b></font>
            </div>The two Bilinear Distortion methods together will allow you to directly distort ANY quadrilateral into any other quadrilateral, while keeping the sides of the quadrilateral straight. Essentially you can first 'Reverse' distort one quadrilateral into a rectangular image, then you can 'Forward' distort that rectangle into the final quadrilateral. This type of distortion also means that you can take any rectangular grid of coordinates, and distort them to another rectangular grid of coordinates. This is known a 'Grid' Distortion. this technique is the primary basis of Image Morphing, where you define a rectangular grid of lines over two images and use them to merge the images into an intermediate composite, or even generate an animation that properly morphs from one image into another. This however has not been implemented yet, though is a planned addition.<br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="polynomial" id="polynomial"></a>
            <h3>Polynomial Distortion <font size="-1">(distorts using a polynomial fit)</font></h3>The '<code>Polynomial</code>' distortion like most of the previous distortion methods also maps pairs of control points, but uses a standard polynomial equation. This means one extra argument is needed before the control points are given.
            <div align="center">
              <code>Order &nbsp; &nbsp; X<sub>1</sub>,Y<sub>1</sub> I<sub>1</sub>,J<sub>1</sub> &nbsp; &nbsp; X<sub>2</sub>,Y<sub>2</sub> I<sub>2</sub>,J<sub>2</sub> &nbsp; &nbsp; X<sub>3</sub>,Y<sub>3</sub> I<sub>3</sub>,J<sub>3</sub> &nbsp; &nbsp; X<sub>4</sub>,Y<sub>4</sub> I<sub>4</sub>,J<sub>4</sub> . . . .</code>
            </div>The '<i>Order</i>' argument is usually an integer from '<code>1</code>' onward, though a special value of '<code>1.5</code>' can also be used. This defines the 'order' or complexity of the 2-dimensional mathematical equation (using both 'x' and 'y') , that will be applied. For example an order '<code>1</code>' polynomial will fit an equation of the form...
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td rowspan="3"><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>2x</sub>*X<sub>s</sub> + C<sub>1x</sub>*Y<sub>s</sub> + C<sub>0x</sub></code></td>
                <td rowspan="3">&nbsp; , &nbsp; &nbsp; &nbsp;</td>
                <td rowspan="3"><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>2y</sub>*X<sub>s</sub> + C<sub>1y</sub>*Y<sub>s</sub> + C<sub>0y</sub></code></td>
                <td></td>
              </tr>
            </table>Which if you compare with the equation used for <a href="#affine_projection">Affine Projection</a> you will see that it is the equivalent. As 3 constants is needed for each X and Y formula, you also need to provide at least 3 X,Y coordinate pairs. Any more will cause the equation to be least-squares fitted to the coordinates given. The next 'order' or '<code>1.5</code>' is equivalent to a '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' (remember the equation is used to map destination coordinates to the source image).
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td rowspan="3"><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>3x</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>2x</sub>*X<sub>s</sub> + C<sub>1x</sub>*Y<sub>s</sub> + C<sub>0x</sub></code></td>
                <td rowspan="3">&nbsp; , &nbsp; &nbsp; &nbsp;</td>
                <td rowspan="3"><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>3x</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>2y</sub>*X<sub>s</sub> + C<sub>1y</sub>*Y<sub>s</sub> + C<sub>0y</sub></code></td>
                <td></td>
              </tr>
            </table>Just like '<code><a href="#bilinear_reverse">BilinearReverse</a></code>' distortion, it needs a minimum of 4 coordinates. For example... Basically this is exactly the same as the order '<code>1</code>' equations but with 1 extra term added to the polynomial equations. That is, as each equation now has 4 terms per axis, with 4 constants, so you now need at least 4 coordinate pairs, to allow IM to determine those constants.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_grid.jpg -alpha set -virtual-pixel black \
       -distort Polynomial \
              '1.5   0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_poly_1.5.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/mandrill_grid.jpg"><img src="../img_photos/mandrill_grid.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="mandrill_poly_1.5.jpg"><img src="mandrill_poly_1.5.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>With an order '<code>2</code>' the polynomial equations is expanded further to become a full quadratic fit, requiring a minimum of least 6 coordinate pairs.
            <table align="center" cellspacing="0" cellpadding="0">
              <tr valign="center">
                <td><code>X<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>5x</sub>*X<sub>s</sub><sup>2</sup> + C<sub>4x</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>3x</sub>*Y<sub>s</sub><sup>2</sup> &nbsp; + C<sub>2x</sub>*X<sub>s</sub> + C<sub>1x</sub>*Y<sub>s</sub> + C<sub>0x</sub></code></td>
              </tr>
              <tr valign="center">
                <td><code>Y<sub>d</sub> =&nbsp;</code></td>
                <td align="center"><code>C<sub>5y</sub>*X<sub>s</sub><sup>2</sup> + C<sub>4y</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>3y</sub>*Y<sub>s</sub><sup>2</sup> &nbsp; + C<sub>2y</sub>*X<sub>s</sub> + C<sub>1y</sub>*Y<sub>s</sub> + C<sub>0y</sub></code></td>
                <td></td>
              </tr>
            </table>Basically this is exactly the same as the order '<code>1</code>' equations but with 3 extra terms (order 2 + 1) pre-pended to the polynomial equations. that is as each equation now has 6 terms with 6 constants you now need at least 6 coordinates to allow IM to determine those constants. Each successive order polynomial after this adds another <code>'order'+1</code> terms to each of the pair of equations. As such an order '<code>3</code>' cubic-fit polynomial requires a minimum of 10 coordinate pairs to fully define, and an order '<code>4</code>' quintic-fit polynomial needs 15 coordinate pairs. You can use a <a href="#distort_verbose">Verbose Distortion Summery</a> to see the resulting equation that the polynomial distortion fitted to the coordinates specified. As an larger example I have an image of a grid. I also have a large set of coordinates (stored in the file "<code><a href="../images/grid16_control_points.txt">grid16_control_points.txt</a></code>") on how I what to warp that grid. I then requested IM to generate a cubic polynomial to 'best-fit' the input coordinates.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  # warp image
  magick grid16.png -virtual-pixel gray \
          -distort polynomial "3 $(cat grid16_control_points.txt)" \
          grid16_polynomial.png

  # reverse image coordinate order
  awk '{print $3, $4, $1, $2}' grid16_control_points.txt \
                             &gt; grid16_cp_inverse.txt

  # warp image back again
  magick grid16_polynomial.png -virtual-pixel gray \
          -distort polynomial "3 $(cat grid16_cp_inverse.txt)" \
          grid16_restored.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="../images/grid16.png"><img src="../images/grid16.png" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="grid16_polynomial.png"><img src="grid16_polynomial.png" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="grid16_restored.png"><img src="grid16_restored.png" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
            </div>The small "<code>awk</code>" script takes the original set of X,Y control point pairs and reverses the order, so that we can then use the new file to try to 'undo' the distortion.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The coordinates in the control-point file "<code><a href="../images/grid16_control_points.txt">grid16_control_points.txt</a></code>" are in image coordinates, meaning each number refers to the center of the pixel it refers to. Without the additional 0.5, the values would be in interger 'pixel coordinates'. See <a href="#control_coordinates">Image Coordinates vs Pixel Coordinates</a> above.<br>
                <br>
                The values were determined purely by hand lookup using an image viewer, and as such are not really very exact. This may be the source of some of the reverse distortion artifacts, though the functional 'best-fit' of the polynomial equations would have reduced the overall distortion effects.<br>
                <br></i></font></td>
              </tr>
            </table>This shows that while a polynomial distortion works, and works well, it is not an exact or reversible distortion. Essentially the 81 coordinates are 'averaged' together so as to generate a mathematical 'best-fit' of the input coordinates. Because more control-points (81) have been provided rather than the minimum (10) needed, none of the control points are guaranteed to exactly match the coordinates requested. However for this specific example, where the coordinaites are close to the expected distorted result, it should be reasonably close. The polynomial function will generally have the most errors along the edges and especially in the corners of the image. This not only effects the pixel locations but also the sampling area (EWA) at the edges. This is a natural result of the approximation used. A higher order polynomial could have been used, but in this case it does not make any great improvements. For this specific case, the polynomial is actually trying to fit itself to a non-polynomial trigonometric function. Due to the nature of those functions, the second distort will be more inaccurate than the first. This example is actually very closely related to a radial <a href="#barrel">Barrel Distortion</a> method which we will look at below. Note however that the coordinates being mapped do not actually need to be in a grid arrangement, but can be any set of coordinate mapping. Because of this it is often used by geographers for aligning (and overlaying) aerial photos with geo-physical maps, using known locations of towns, cross-roads, mountain peaks, and other landmarks as the control points.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Due <a href="#polynomial">Polynomial Distortion</a> being generally non-reversible, it isn't posible for IM to calculate the 'best-fit' of the destination image's viewport, for the given source image. As such the "<code><a href="#distort_bestfit">+distort</a></code>" form of the operator does not work, and falls back to a normal "<code><a href="../option_link.cgi?distort">-distort</a></code>" operation. You can however still use the <a href="#distort_viewport">Distort Viewport</a> option to define the viewport of the destination image.</i></font></td>
              </tr>
            </table><br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="circular_distorts" id="circular_distorts"></a>
            <h2>Circular and Radial Distortion Methods</h2>This are distortions that involve the use of radial vectors as the major component of the distortion process. <a name="arc" id="arc"></a>
            <h3>Arc Distortion <font size="-1">(curving images into circular arcs)</font></h3>The '<code>Arc</code>' distortion (as of IM v6.3.5-5) is a simple variation of a much more complex, <a href="#polar">polar distortion</a> (see below). By default it will curve the given image into a perfectly circular arc over the angle given, and without other arguments it will try to preserve the scaling of both the horizontal center-line of the image, and the image's aspect ratio, as much as possible. To do this it takes up to four arguments.
            <div align="center">
              <code><i>arc_angle &nbsp; rotate_angle &nbsp; top_radius &nbsp; bottom_radius</i></code>
            </div>However only the "<code><i>arc_angle</i></code>" is required, the other arguments are optional, and can be added as needed, in the sequence given. For example '<code>Arc</code>' an image over an angle of 60 degrees...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel White -distort Arc 60  arc_rose.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_rose.jpg"><img src="arc_rose.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Note that unlike the other image distortion operators, an '<code>Arc</code>' distort will always set the size of the resulting image so that the complete source image is present. This includes any anti-aliasing edge pixels. As such the resulting image will rarely match the size of the input image.<br>
                <br>
                Only a the <a href="#distort_viewport">Viewport Distort Options</a>, will allow you to change the resulting image size for a specific distortion.</i></font></td>
              </tr>
            </table>Adding the second argument "<code><i>rotate_agle</i></code>" allows you to rotate the image around the circle. For example rotate it by 90 degrees.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel White -distort Arc '60 90'  arc_rose_rot.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_rose_rot.jpg"><img src="arc_rose_rot.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As no specific radius argument has be mentioned, the '<code>Arc</code>' distortion method takes great pains to try to ensure the original images scale is preserved as much as possible. To do this the horizontal center line of the image is set to the 'ideal radius' for the width and the given "<code><i>arc_angle</i></code>" of the source image. This means that if you arc the image over a larger "<code><i>arc_angle</i></code>", the radius of the center-line used will also shrink by the same factor. As such the radius of the center-line will be smaller and tighter.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel White -distort Arc 120  arc_rose_3.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_rose_3.jpg"><img src="arc_rose_3.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note how the image will now fit into a smaller circle, but that the bottom edge of the image is an even smaller circle still! If you set an even larger angle over which to arc the image, the bottom edge will hit the center of the distortion, and beyond, which results in the lower part of the source image disappearing into oblivion.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -virtual-pixel White -distort Arc 60   arc_rose_1.jpg
  magick rose: -virtual-pixel White -distort Arc 90   arc_rose_2.jpg
  magick rose: -virtual-pixel White -distort Arc 120  arc_rose_3.jpg
  magick rose: -virtual-pixel White -distort Arc 180  arc_rose_4.jpg
  magick rose: -virtual-pixel White -distort Arc 240  arc_rose_5.jpg
  magick rose: -virtual-pixel White -distort Arc 300  arc_rose_6.jpg
  magick rose: -virtual-pixel White -distort Arc 360  arc_rose_7.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="arc_rose_1.jpg"><img src="arc_rose_1.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_2.jpg"><img src="arc_rose_2.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_3.jpg"><img src="arc_rose_3.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_4.jpg"><img src="arc_rose_4.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_5.jpg"><img src="arc_rose_5.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_6.jpg"><img src="arc_rose_6.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <a href="arc_rose_7.jpg"><img src="arc_rose_7.jpg" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
            </div><a name="arc_rings" id="arc_rings"></a>
            <h4>Arc into Full Circle Rings</h4>Longer images will '<code>Arc</code>' distort a lot better over very large angles. For example you can wrap long images (like text messages) into rings. And just so you can truly see what is happening here I set a different <a href="../misc/#virtual-pixel">Virtual Pixel</a> background color, so you can see the boundary of the original image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 60     arc_circle_1.jpg
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 120    arc_circle_2.jpg
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 180    arc_circle_3.jpg
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 270    arc_circle_4.jpg
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 360    arc_circle_5.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="arc_circle_1.jpg"><img src="arc_circle_1.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="arc_circle_2.jpg"><img src="arc_circle_2.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="arc_circle_3.jpg"><img src="arc_circle_3.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="arc_circle_4.jpg"><img src="arc_circle_4.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="arc_circle_5.jpg"><img src="arc_circle_5.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>And hey presto we have 'arc'ed the label image into a full circle. If you look closely at the join of the full circle image you may see a small line of pixels, where the join is not quite complete. This is caused by the effect of the surrounding '<code>SkyBlue</code>' <a href="../misc/#virtual-pixel">Virtual Pixel</a> background, as we are effectively joining two edges of an image. When generating a full circle, you need to use a virtual pixel method that will 'join' these two edges correctly. This is generally done by using one of the tiling <a href="../misc/#virtual-pixel">Virtual Pixel</a> methods, such as <a href="../misc/#tile">Tile</a>.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Tile -background SkyBlue \
          -distort Arc 360   arc_circle_tile.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_circle_tile.jpg"><img src="arc_circle_tile.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Unfortunately, as you can see, this not only joins the image together properly, but also generates duplicate lines of the image into and out-of the primary ring. Not good. As of IM v6.4.2-6 a new <a href="../misc/#virtual-pixel">Virtual Pixel</a> method, <a href="../misc/#horizontal_tile">HorizontalTile</a>, solves this problem. This method tiles the image sideways only, so it creates a good join for our circled image, but fills the areas above and below the tiles with the current background color, producing a perfect circle of text.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc 360   arc_circle.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_circle.jpg"><img src="arc_circle.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>If before 'arc'ing an image you rotate the input image upside-down, you can place the original 'top' of the image on the inside edge of the circle. Of course you may like to 'rotate' the result back upright again afterward, but that capability is already built into the '<code>Arc</code>' distortion method.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background -background SkyBlue \
          -rotate 180 -distort Arc '270 180'  arc_flip.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_flip.jpg"><img src="arc_flip.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The third argument "<code><i>top_radius</i></code>" will override the 'ideal' center line radius that is calculated, so that the top of the image will become a circle of the radius given. This creates a ring that is 100 pixels wide, though the accomidating image is 102 pixels wide to allow for anti-aliasing effects.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 50'  arc_radius.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_radius.jpg"><img src="arc_radius.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The image still remains the same aspect ratio, so the above has essentially the same as before, just scaled so as to fit the circle of the radius requested. Remember the radius can be floating point, but the center of an arc will always be aligned to a pixel 'corner', so the reulting image will still be an even number of pixels wide. If you provide the fourth "<code><i>bottom_radius</i></code>" argument, you can get complete control of the width of the ring, or its 'radial height'.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 45 30'   arc_inner.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_inner.jpg"><img src="arc_inner.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This will distort the radial scaling of the image, and effectivally separates the radial scaling from the 'arc width' or angle of the resulting image. In other words the original image aspect ratio will no longer be preserved.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You can even force it to completely fill the inside of the circle, wrapping the bottom edge of the input image at the center, or 'pole' of the distrotion.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 45 0'   arc_fill.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_fill.jpg"><img src="arc_fill.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="arc_examples" id="arc_examples"></a>
            <h4>Arc Distortion Examples</h4>You can generate interesting effects using a <a href="#arc">Arc Distortion</a>, for example arcing a longish checkerboard pattern into the ring (using the <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting '<code><a href="../misc/#horizontal_tile">HorizontalTile</a></code>' produces...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 210x30 pattern:checkerboard -alpha set \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc 360   arc_checks.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_checks.png"><img src="arc_checks.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  By using the default <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting of '<code><a href="../misc/#edge">Edge</a></code>' you can produce a more interesting effect.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 210x30 pattern:checkerboard  -virtual-pixel Edge \
          -distort Arc 360   arc_checks_edge.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_checks_edge.png"><img src="arc_checks_edge.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Of course a '<code><a href="../misc/#edge">Tile</a></code>' setting generated interesting 'radial' effects too, allowing you to generate a circular checkerboard pattern.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 210x30 pattern:checkerboard  -virtual-pixel Tile \
          -distort Arc 360   arc_checks_tile.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_checks_tile.png"><img src="arc_checks_tile.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The above can be refined further by controling the top and bottom radius of the resulting image. Here are some more '<code><a href="#arc">Arc</a></code>' distort examples, but I let you play with them to figure out how they work. What can you come up with?
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 90x1 pattern:gray50 -scale 900x100 -normalize \
          -virtual-pixel Tile  -set option:distort:viewport 100x100-50-50 \
          -distort Arc 360  +repage  arc_radii.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="arc_radii.gif"><img src="arc_radii.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 400x100 pattern:hs_diagcross \
          -virtual-pixel Tile  -set option:distort:viewport 100x100-50-50 \
          -distort Arc '360 0 80 0' +repage  arc_cross.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="arc_cross.gif"><img src="arc_cross.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 360x80 xc: -draw "fill none stroke black line 0,5 360,80" \
          -virtual-pixel White  -distort Arc '360 0 50 0'  arc_spiral.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="arc_spiral.gif"><img src="arc_spiral.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify"></td>
              </tr>
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif -set option:distort:viewport 120x60-60-60 \
          -virtual-pixel Dither  +distort Arc '180 0 25 0' \
          +repage arc_rays.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="arc_rays.gif"><img src="arc_rays.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The 'rays' in this last example are a by-product of the pseudo-random '<code><a href="../misc/#dither">Dither</a></code>' <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting, resulting in an odd pixel pattern of the 'sun' color from the top-left corner from the original image. The same dithering effects also produces the circular line of 'dashes' surrounding the 'tree' image. You can achieve a similar and more controlled version of this effect by using a '<code><a href="../misc/#edge">Edge</a></code>' setting with image that has been modified to add interesting edge pixels. <a name="arc_center" id="arc_center"></a>
            <h4>Arc Center Point Placement</h4>By default '<code><a href="#arc">Arc</a></code>' will completely ignore any <a href="../basics/#page">Virtual Canvas</a> offset the image may have or even not report the location of the 'center' around which the image was arc'ed. However knowing the location of the 'center point' can be very useful. If instead of using "<a href="../option_link.cgi?distort"><code>-distort</code></a>" you use the special plus form, "<a href="../option_link.cgi?distort"><code>+distort</code></a>", the image will be given a <a href="../basics/#page">Virtual Canvas</a>, so that center is located at the virtual canvas origin. In other words the '<code>0,0</code>' point of the image is set to be the 'center' of the arc. This is especially useful for positioning an arc'ed image with a smaller angle than the full circle, where the arc 'center' is not the center of the image. For an example...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick logo: -resize x150 -gravity NorthEast -crop 100x100+10+0! \
          \( -background none label:'IM Examples' \
             -virtual-pixel Background +distort Arc '270 50 20' \
             -repage +75+21\! \)  -flatten  arc_overlay.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="arc_overlay.jpg"><img src="arc_overlay.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Here I create a text label '<code><a href="#arc">Arc</a></code>' distorted it into an incomplete circle using the plus "<a href="../option_link.cgi?distort"><code>+distort</code></a>" form of the operator. The 'center' of the arc was carefully preserved by IM using the images virtual canvas offset. This means that by simply doing a relative adjustment of the offset using "<a href="../option_link.cgi?repage"><code>-repage</code></a>" with a '<code>!</code>' flag, we can position the resulting circle of text anywhere we want! Such as the point of the wizard hat, which is located at the pixel coordinated 75,21, in the above example. Unfortunatally as virtual offsets are used to position the image, the exact positioning is limited to integer pixel sizes. You can not position a <a href="#arc">Arc Distortion</a> to a sub-pixel defined location without doing a second distortion. However you can do this for a <a href="#polar">Polar Distortion</a> (see next).<br>
            <a name="polar" id="polar"></a>
            <h3>Polar Distortion <font size="-1">(full circle distorts)</font></h3>The '<code>Polar</code>' distort (Added IM v6.4.2-6) is a more low level version of the '<code><a href="#arc">Arc</a></code>' distortion above. But it will not automatically do 'bestfit', nor does it try to preserve the aspect ratios of images. The 6 optional floating point arguments are...
            <table align="center">
              <tr>
                <td><code>Radius_Max Radius_Min Center_X,Center_Y Start_Angle,End_Angle</code></td>
              </tr>
            </table>All the arguments are optional at the spaced positions. By default the '<i>CenterX,Y</i>' will default to the very middle of the input image area. Then a full circle polar image will be generated such that the whole top edge becomes the center, while the bottom edge is wrapped completely around the outside of the circle. The left and right edges meeting will meet at above the center point at angles '<code>-180</code>' to '<code>+180</code>' image. As the '<i>Radius_Max</i>' must be given, it should some positive value. &nbsp; However if you give a value of '<code>0</code>' it will be set to the distance between the center and the closest edge, so that if the other values are not given (defaults), the whole input image is mapped into a circle in the middle of the image. For example, lets magick a map of the world into a polar view, using all the defaults. Of course you should specify a <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting of '<code><a href="../misc/#horizontal_tile">HorizontalTile</a></code>' when producing a full circle polar mapping...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick worldmap_sm.jpg -virtual-pixel HorizontalTile  \
          -background Black   -distort Polar 0   polar_arctic.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/worldmap_sm.jpg"><img src="../img_photos/worldmap_sm.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="polar_arctic.jpg"><img src="polar_arctic.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Of course this distorts the southern hemisphere severely, wrapping the Antarctica completely around the circumference of the 'diskworld'.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  By rotating the source image, and cropping it so to just show the polar cap, we can generate a nice map of the Antarctic Continent. I also specified a larger output radius, to make more visible, and asked IM to 'fit' the output image to this size by using the 'plus' form of the <a href="#distort">Distort Operator</a>.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick worldmap_md.jpg -rotate 180 -crop 100%x25%+0+0 +repage \
          -virtual-pixel HorizontalTile -background Black \
          +distort Polar 80 +repage  polar_antarctica.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="polar_antarctica.jpg"><img src="polar_antarctica.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the above are not strictly correct views of the earth, as the Cartesian map is a representation of a sphere, and not an image in polar coordinates. If you use a special '<i>Radius_Max</i>' value of exactly '<code>-1</code>' the radius of the distorted image is set to the distance from the center to the furthest corner (diagonal). This is to provide an ideal 'reverse' for a full image '<code><a href="#depolar">DePolar</a></code>' distortion which we look at next. (See <a href="#polar_tricks">(De)Polar Tricks</a> below for examples of use).
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Remember, unlike an '<code><a href="#arc">Arc</a></code>' distortion, '<code><a href="#polar">Polar</a></code>' (also known as a 'Cartesian to Polar' distortion) makes no attempt to preserve the 'ideal' aspect ratio of the source image. Caution is advised.</i></font></td>
              </tr>
            </table>The '<i>CenterX,Y</i>' arguments are most useful is positioning the center of the resulting image at a sub-pixel offset. That is, whether the center is at the boundary of a pixel (whole number) or the center of a pixel (with 0.5 offsets). Of course it also determines the location of the virtual canvas 'layer'. By default however it is assigned a value the middle of the image (for "<code>-distort</code>" which uses the input image as the viewport) or <code>0,0</code> (for "<code>+distort</code>" layer image). The next arguments '<i>Start_Angle,End_Angle</i> are even less commonly used, and limit angles the input image covers, defaulting to a value of -180 to 180 degress (0 is straight down). Like '<code><a href="#arc">Arc</a></code>' distortion you could use this to rotate the resulting polar image. But it can also be used to generate 'arcs'. For example...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick worldmap_sm.jpg -virtual-pixel Black -background Black \
          +distort Polar  '60,20 0,0 -60,60' +repage  polar_arc.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/worldmap_sm.jpg"><img src="../img_photos/worldmap_sm.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="polar_arc.jpg"><img src="polar_arc.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Note that currently IM does not reduce the size of the resulting layer image, which is aligned so that the virtual images origin is at coordinates <code>0,0</code>, as requested. Other than argument style, this is the biggest difference between '<code><a href="#arc">Arc</a></code>' and '<code><a href="#polar">Polar</a></code>' distortion. Also note that the left edge (angle -60) is to the left. This is mathematically correct when you consider that the 'Y' axis is downward (same as for all image rotates).
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  Of course like Arc you can use Virtual-Pixel tiling effects to generate repeated patterns. For example, this is exactly the same as the last example, just with a '<code><a href="../misc/#horizontal_tile">HorizontalTileEdge</a></code>' setting...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick worldmap_sm.jpg -virtual-pixel HorizontalTile -background Black \
          +distort Polar  '60,20 0,0 -60,60' +repage  polar_arc_tiled.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="polar_arc_tiled.jpg"><img src="polar_arc_tiled.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="depolar" id="depolar"></a>
            <h3>DePolar Distortion <font size="-1">(Polar to Cartesian)</font></h3>This is essentially the inverse of a '<code><a href="#polar">Polar</a></code>' distortion, and has exactly the same set of optional arguments. The 6 optional floating point arguments are...
            <div align="center">
              <code>Radius_Max &nbsp; Radius_Min &nbsp; Center_X,Center_Y &nbsp; Start_Angle,End_Angle</code>
            </div>Again if '<i>Radius_Max</i>' is set to '<code>0</code>' the distance the '<i>CenterX,Y</i>' to the nearest edge is used which means anything in the largest whole circle, will be mapped to fit into an image the same size as the input image. For example, lets reverse the previous 'diskworld' back into a Cartesian Map.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick polar_arctic.jpg  -distort DePolar 0  world_restored.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="polar_arctic.jpg"><img src="polar_arctic.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="world_restored.jpg"><img src="world_restored.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>As the input image size has been preserved all the way though the two distortions, the result of the above is basically exactly the same as the original map. Of course as the image was compressed both at the top 'pole' and in radius, the output is a lot fuzzier than you may expect.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Actually it is made worse in that the <a href="#area_resample">Area Resampling</a> algorithm (EWA) can not sample pixels in a circular arc. As such <a href="#area_resample">Area Resampling</a> is turned off for "<code><a href="#depolar">DePolar</a></code>" distortions. It is recommended that some form of <a href="#super_sample">Super-Sampling</a> technique be used instead, such as shown in the next section.</i></font></td>
              </tr>
            </table>If you allow IM to use 'bestfit' (using the "<a href="../option_link.cgi?distort"><code>+distort</code></a>" form of the operator), then it will resize the output image so as keep the '<i>Radius_Max</i>' at unity scaling, and set the width to the circumference distance of the radius midway between '<i>Radius_Max</i>' and '<i>Radius_Min</i>'. This essentially tries to best preserve the Aspect Ratio of the polar image, though this may produce a longer thinner image than expected. For example.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick polar_arctic.jpg  +distort DePolar 0  world_restored_2.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="polar_arctic.jpg"><img src="polar_arctic.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="world_restored_2.jpg"><img src="world_restored_2.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div><a name="polar_tricks" id="polar_tricks"></a>
            <h3>(De)Polar Cycle Tricks <font size="-1">(radial/angular blurs)</font></h3>As we saw above using a '<i>Radius_Max</i>' of '<code>0</code>' will ensure that the whole image will be mapped into a circle when using a '<code><a href="#polar">Polar</a></code>' (<i>Cartesian to Polar</i>) distortion, and the same setting will map that circle back into a rectangular image by using '<code><a href="#depolar">DePolar</a></code>' (<i>Polar to Cartesian</i>). However this will not work very well if you what to '<code><a href="#depolar">DePolar</a></code>' a rectangular image, and then reverse the distortion again using '<code><a href="#polar">Polar</a></code>'. For example lets take a flower image, de-polar, then restore it using the special '<i>Radius_Max</i>' value of '<code>0</code>' (radius = nearest edge).
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg -virtual-pixel Black \
          -distort DePolar 0  flower_depolar.jpg
  magick flower_depolar.jpg \
          -virtual-pixel HorizontalTile -background black \
          -distort  Polar  0  flower_circle.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="flower_sm.jpg"><img src="flower_sm.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="flower_depolar.jpg"><img src="flower_depolar.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="flower_circle.jpg"><img src="flower_circle.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Now the image is not restored properly as it was clipped by the first '<code><a href="#depolar">DePolar</a></code>' distortion. Even so this itself an useful technique, and can be used to generate perfect circular masks for an existing image sized in a way that is completely independent of the input image given. To do this '<code><a href="#depolar">DePolar</a></code>'-'<code><a href="#polar">Polar</a></code>' cycle technique correctly we need to use a radius that is the distance from the center to the furthest corner. The special '<i>Radius_Max</i>' value of '<code>-1</code>', will ask IM to calculate an use the furthest corner from the 'center point', as the radius.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg  -virtual-pixel Black \
          -distort DePolar -1  flower_depolar-1.jpg
  magick flower_depolar-1.jpg \
          -virtual-pixel HorizontalTile -background black \
          -distort  Polar  -1  flower_restored.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="flower_sm.jpg"><img src="flower_sm.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="flower_depolar-1.jpg"><img src="flower_depolar-1.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="flower_restored.jpg"><img src="flower_restored.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>The restored image is slightly blurry, which is caused by the compression of the radius needed to preserve the whole image during the '<code><a href="#depolar">DePolar</a></code>' operation. That however can be fixed by using an appropriate <a href="#super_samping">Super-Sampling</a> technique (see next set of examples). But why would you want to magick an image into this form and back again? Well by applying other distortions on the intermediate 'DePolar' version of the image, you can generate some very fancy radial or angular effects very easily. For example by rolling the intermediate image, you will rotate the output image, though you may get some clipping of the corners...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg -virtual-pixel Black -distort DePolar -1 \
          -roll +15+0 \
          -virtual-pixel HorizontalTile -background Black \
          -distort  Polar  -1  flower_polar_rotate.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_polar_rotate.jpg"><img src="flower_polar_rotate.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the direction of the rotation is reversed from that of the <a href="../warping/#rotate">Rotate Operator</a> or the <a href="#srt">SRT Distortion</a>. <a name="polar_problems" id="polar_problems"></a>
            <h4>Depolar-Polar Cycle problems</h4>In the image rotation above you may have notice some 'stair case' like distortions along the edge of the rotated image. This is a well known problem and is caused by compressing the large circular circumfrence of the image into the smaller 'width' of the input image. For example, here I take the checker-board test image, and just run it though a normal Depolar-Polar cycle without making any changes.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png   -virtual-pixel Transparent \
          -distort DePolar -1   checks_depolar.png
  magick checks_depolar.png  -virtual-pixel HorizontalTile -background None \
          -distort  Polar  -1   checks_cycled.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="checks.png"><img src="checks.png" width="90" height="90" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="checks_depolar.png"><img src="checks_depolar.png" width="90" height="90" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="checks_cycled.png"><img src="checks_cycled.png" width="90" height="90" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>You can clearly see the aliasing effects caused by image compression in the points of the intermedite image. It is also exasperated by the fact that normal <a href="#area_resample">Area Resampling</a> is not used during that initial '<code><a href="#depolar">Depolar</a></code>' conversion of the input image. The best way to solve this problem is to use <a href="#distort_scale">Distort Output Scaling</a> to both enlarge the intermediate image, and then shrink the final image. This will provide a <a href="#super_sample">Super-Sampled</a> result, that will remove the compression artifacts seen above. For example, this is the better 'no-op' depolar-polar cycle, all in one command...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png -virtual-pixel Background -background None \
          -set option:distort:scale 4  -distort DePolar -1 \
          -noop \
          -virtual-pixel HorizontalTile -background None \
          -set option:distort:scale .25 -distort  Polar  -1 \
          checks_cycled_ss.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="checks_cycled_ss.png"><img src="checks_cycled_ss.png" width="90" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see the horible aliasing effects has all but disappeared. However be warned that a very tall thin image could make the problem reappear. The best idea is to limit this to 'landscale' or wide images, with super-sampling as shown above. All you need to do now is replace the "<a href="../option_link.cgi?noop"><code>-noop</code></a>" operator with the appropriate command to generate the radial and rotational effect you are looking for. <a name="polar_rotation" id="polar_rotation"></a>
            <h4>Example Depolar-Polar Effects</h4>So lets again show better <b>Polar Rotation</b> of the image, this time using super sampling. Note however that as the intermediate image is 4 times larger, the amount of <a href="../warping/#roll">Image Roll</a> also needs to be 4 times larger.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg   -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -roll +60+0   \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_polar_rotate_ss.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_polar_rotate_ss.jpg"><img src="flower_polar_rotate_ss.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see the 'stair-case' effect along the edge has been removed, with a much higher quality image result.<br>
            <a name="rotation_blur" id="rotation_blur"></a> Or you can apply simple linear blurring of the intermediate image (such achieved by squeezing and enlarging the image again).
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -scale 10%x100%\! -filter Gaussian -resize 1000%x100%\! +filter \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_angular_blur.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_angular_blur.jpg"><img src="flower_angular_blur.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The result is very similar to a '<b>Rotational Blur</b>' of the image. This is similar to but not quite the same as the mis-named <a href="../blur/#radial-blur">Radial Blur Operator</a>. Actually the results are at a higher quality than that specialized blurring method. Note the use of a '<code>black</code>' color in the various forms of <a href="../misc/#virtual-pixel">Virtual Pixel Settings</a> that was applied, will result in a slight darkening of the edges, but it isn't too bad in the above case. One method to remove the 'black' edges effects, would be to use '<code>transparency</code>' color instead, and then just turn-off the alpha channel completely when finished so as to leave just the actual color that IM calculated. Another is to use two 'edge' virtual pixel methods ('<code><a href="../misc/#edge">Edge</a></code>' and '<code><a href="../misc/#horizontal_edge">HorizontalTileEdge</a></code>'), which extends the edges of the image into the undefined virtual canvas space.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg -virtual-pixel Edge \
          -set option:distort:scale 4   -distort DePolar -1 \
          -scale 10%x100%\! -filter Gaussian -resize 1000%x100%\! +filter \
          -virtual-pixel HorizontalTileEdge -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_angular_blur_edge.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_angular_blur_edge.jpg"><img src="flower_angular_blur_edge.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Which shows a much better result near the edges.<br>
            <a name="radial_streaks" id="radial_streaks"></a> By blurring the polar version of the image vertically, this time using <a href="../blur/#motion-blur">Motion Blur Operator</a>, rather than resize compression, you can generate a <b>Radial Streaks</b> that move outward from the center of the image...
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg   -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -virtual-pixel Edge   -motion-blur 0x28-90 \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_radial_blur.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_radial_blur.jpg"><img src="flower_radial_blur.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>To make the result only blur the highlights (the petals) of the image, you can compose this with the original image using <a href="../compose/#lighten">Lighten</a>, so only the blurred lighter colors remain visible, with the dark colors not blurring into the lighter areas, and destroying the yellow spots in the middle of the flower.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick flower_sm.jpg  flower_radial_blur.jpg \
          -compose Lighten -composite   flower_radial_blur_lighten.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flower_radial_blur_lighten.jpg"><img src="flower_radial_blur_lighten.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>See also <a href="../advanced/#stars">Stars and Comets</a> for another example of doing this, but directly generating the intermediate 'DePolar' image, before applying a '<code><a href="#polar">Polar</a></code>' distortion.Special thanks goes to <a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a> for the special uses of a DePolar-Polar cycle, and for insisting that I ensure that these distortions were fully reversible for rectangular images. He puts this technique to good effect in a number of his <a href="http://www.fmwconcepts.com/imagemagick/index.html">ImageMagick Scripts</a>, including "<code><a href="http://www.fmwconcepts.com/imagemagick/bump/index.php">bump</a></code>", "<code><a href="http://www.fmwconcepts.com/imagemagick/ripples/index.php">ripples</a></code>", and "<code><a href="http://www.fmwconcepts.com/imagemagick/striations/index.php">striations</a></code>".<br>
            <a name="barrel" id="barrel"></a>
            <h3>Barrel Distortion <font size="-1">(correcting lens distortions)</font></h3>The Barrel Distortion (added to IM v6.4.2-4) is designed specifically for correcting the spherical distortions caused by camera lenses in photos. That is distortions such as barrel and pincushion effects, which are effectively the reverse of each other. For actual application of using this operator for lens distortion correction see the section, <a href="../#lens">Lens Correction</a>. The distort is implemented based on a set of 4 coefficient values, known as <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>, as defined by <a href="http://webuser.fh-furtwangen.de/~dersch/">Professor Helmut Dersch</a>, in a web size that has since vanished. You can see a <a href="http://waybackmachine.org/web/web.php">Wayback Machine</a> archive of the site at <a href="http://replay.waybackmachine.org/20090613040829/http://www.all-in-one.ee/~dersch/barrel/barrel.html">Correcting Barrel Distortion</a>. The values basically form a distortion equation such that...
            <div align="center">
              <code><i>R<sub>src</sub></i> = r * ( A*<i>r<sup>3</sup></i> + B*<i>r<sup>2</sup></i> + C*<i>r</i> + D )</code>
            </div>Where "<code><i>r</i></code>" is the destination radius and "<code><i>R<sub>src</sub></i></code>" is the source pixel to get the pixel color from. the radii are normalized so that radius = '<code>1.0</code>' for the half minimum width or height of the input image. This may seem reversed but that is because the <a href="#mapping">Reverse Pixel Mapping</a> technique is used to ensure complete coverage of the resulting image. All four coefficients (<code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>) are fixed for any specific camera, lens, and zoom, combination. All three of which is typically stored with the image in a <a href="../photos/#exif">EXIF Profile</a>. This is important as it means that once you have these values for your camera you can use them to remove the spherical lens distortion that is present in all the photos taken by that camera and lens combination. The arguments needed for the '<code><b>Barrel</b></code>' distort method. Generally you supply 3 or 4 values only...
            <div align="center">
              <code><i>A &nbsp; B &nbsp; C</i> &nbsp; [ <i>D</i> &nbsp; [ <i>X</i> , <i>Y</i> ] ]</code>
            </div>The optional <i>X</i>,<i>Y</i> arguments provide an optional 'center' for the radial distortion, otherwise it defaults to the exact center of the image given (regardless of its virtual offset). The coefficients are designed so that if all four <i>A</i> to <i>D</i> values, add up to '<code>1.0</code>', the minimal width/height of the image will not change. For this reason if <i>D</i> (which controls the overall scaling of the image) is not supplied it will be set so all four values do add up to '<code>1.0</code>'. Using the parameters '<code>0.0 0.0 0.0</code>' (equivalent to <code><i>A</i>=<i>B</i>=<i>C</i>=0.0</code> and <code><i>D</i>=1.0</code>') will produce no change to the input image, and is the 'no-op' argument for this distortion. Here is an example from the original web site, using the supplied coefficients for the camera that was used to take the photo.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick barrel_distorted.jpg -virtual-pixel black \
          -distort Barrel "0.0 0.0 -0.075 1.1" \
          barrel_distorted_fixed.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="../img_photos/barrel_distorted.jpg"><img src="../img_photos/barrel_distorted.jpg" width="300" height="225" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="barrel_distorted_fixed.jpg"><img src="barrel_distorted_fixed.jpg" width="300" height="225" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Note how the distortion in the image was corrected making the pillars of the building straight. However as the 4 coefficients added up to a value that was greater than <code>1.0</code> the image was shrunk by a small amount, producing the small black areas at the middle top and bottom edges (according to the given <a href="../misc/#virtual-pixel">Virtual Pixel Setting</a>). Here is the effect of adding 0.2 to each of the input coefficients, again the values add up greater than <code>1.0</code> so the resulting distorted image will be smaller.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.2 0.0 0.0 1.0"   barrel_checks_A.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.2 0.0 1.0"   barrel_checks_B.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.2 1.0"   barrel_checks_C.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.0 1.2"   barrel_checks_D.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="barrel_checks_A.png"><img src="barrel_checks_A.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks_B.png"><img src="barrel_checks_B.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks_C.png"><img src="barrel_checks_C.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks_D.png"><img src="barrel_checks_D.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
            </div>Subtracting <code>0.2</code> produces the opposite effect, though I offset the effect using a larger '<i>D</i>' value (to shrink the image) so you can see the results better.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick checks.png -virtual-pixel gray \
          -distort Barrel "-0.2 0.0 0.0 1.3"   barrel_checks-A.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 -0.2 0.0 1.3"   barrel_checks-B.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 -0.2 1.3"   barrel_checks-C.png
  magick checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.0 1.3"    barrel_checks-D.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="barrel_checks-A.png"><img src="barrel_checks-A.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks-B.png"><img src="barrel_checks-B.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks-C.png"><img src="barrel_checks-C.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <a href="barrel_checks-D.png"><img src="barrel_checks-D.png" width="90" height="90" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
            </div>Note how the value of <i>A</i> produces a larger effect than <i>B</i>, and <i>B</i> a larger effect than <i>C</i>, while <i>D</i> provides an overall scaling of the result. This allows you to use each coefficient to adjust the image so that you can correct for one distortion around the outer edge, and another distortion toward the middle, be it pincushion for one, and barrel for the other. Very versatile.The above coefficients (<i>A</i>, <i>B</i>, <i>C</i>, and <i>D</i>) are designed to work with a 'normalized' radius that is half the minimum width or height of the image (like the '0' radius setting for <a href="#polar">Polar Distort</a>. That is, they are image size independent. As such you can use the same set of values for any image that a specific camera generates, regardless of its quality size (camera setting), or if you resized the image smaller. It is possible to adjust the coefficient values to use other 'normalized' radius values using the appropriate multipliers/divisors to each coefficient. Such as using half the maximum width/height, or using the diagonal radius.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Helmut Dersch also notes that you should consider using a LAB colorspace for distortion correction in photos, as it produces better color interpolation. This may actually be true of all distortions (including <a href="../resize/#resize">Resize</a>.<br>
                <br>
                Testing show that LAB space is just as non-linear as sRGB, but does avoid the posiblity of color distions when extreme values are clipped. See <a href="../color_basics/#perception">Human Color Perception</a>, and the practical examples in <a href="../resize/#resize_colorspace">Resizing with Colorspace Correction</a>.</i></font></td>
              </tr>
            </table><br>
            You can also declare a different set of coefficients for the x and y axis, allowing you to generate some unusual distortions.
            <div align="center">
              <code><i>A<sub>x</sub> B<sub>x</sub> C<sub>x</sub> D<sub>x</sub> &nbsp; A<sub>y</sub> B<sub>y</sub> C<sub>y</sub> D<sub>y</sub></i> &nbsp; [ <i>X</i> , <i>Y</i> ]</code>
            </div>The use of separate X and Y arguments was prototyped in Fred Weinhaus's <a href="http://www.fmwconcepts.com/imagemagick/pinbarrel/">pinbarrel</a> script though his arguments are in the reverse order with <code>D</code> first and <code>A</code> last. By using a positive <i>C</i> value, with appropriate <i>D</i> value for just the 'y' set of coefficients you can distort images so that they bulge vertically in the middle.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.0 1.0   0.0 0.0 0.5 0.5" \
          barrel_bulge.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="barrel_bulge.png"><img src="barrel_bulge.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Similarly using a negative <i>C</i> value you can 'pinch' an image in the middle.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.0 1.0   0.0 0.0 -0.5 1.9" \
          barrel_pinch.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="barrel_pinch.png"><img src="barrel_pinch.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or by adding the opposite effect for the X coefficients, make it look like your squeezing the image between your fingers, making it bulge out the sides.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.5 0.5   0.0 0.0 -0.5 1.9" \
          barrel_pinch_2.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="barrel_pinch_2.png"><img src="barrel_pinch_2.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><br>
            <a name="barrelinverse" id="barrelinverse"></a>
            <h3>BarrelInverse Distortion <font size="-1">(alternative barrel distortion)</font></h3>The '<code>BarrelInverse</code>' distortion method is very similar to the previous <a href="#barrel">Barrel Distortion</a> distortion method, and in fact takes the same set of arguments. However the formula that is applied is slightly different, with the main part of the equation dividing the radius. that is the Equation has been inverted.
            <div align="center">
              <code><i>R<sub>src</sub></i> = r / ( A*<i>r<sup>3</sup></i> + B*<i>r<sup>2</sup></i> + C*<i>r</i> + D )</code>
            </div>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>This equation does NOT produce the 'reverse' the '<code>Barrel</code>' distortion. You can NOT use it to 'undo' the previous distortion.</i></font></td>
              </tr>
            </table>The result of this is that you would use the 'negative' form of the <i>A</i>, <i>B</i>, <i>C</i>, with an equivalent adjustment in <i>D</i> to achieve a similar but slightly different result. Some sources such the research paper <a href="http://www.fieldrobotics.org/~cgeyer/OMNIVIS05/final/Li.pdf">Method for Correcting Lens Distortion (PDF)</a> suggest that a better result can be achieved with a lens correction distortion of this form. For example, here is the equivalent of the last 'Pinch' example using this form of distortion.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -virtual-pixel transparent \
          -distort BarrelInverse "0.0 0.0 -0.5 1.5   0.0 0.0 0.3 0.5" \
          barrel_inv_pinch.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="barrel_inv_pinch.png"><img src="barrel_inv_pinch.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="projective_distorts" id="projective_distorts"></a>
            <h2>Projective Distortions</h2>These are distortions that is used to project or map images that exist on one surface, onto another surface. The projective lines may be parallel, or radiate from some specific location. While technically <a href="#affine">Affine</a> and <a href="#perspective">Perspective Distortions</a> are also 'projective' in that they 'project' images on one flat surface onto another flat surface (using parallel, and radial projections respectivally), they are so common they are looking at in greater detail in their own example areas above. Here are the more unusual 'Projective Distortions' that have been implemented, typically with the help of the <a href="../forum_link.cgi?f=1">IM Discussion Forum</a>. <a name="cylinder2plane" id="cylinder2plane"></a>
            <h3>Cylinder 2 Plane</h3>The '<code>Cylinder2Plane</code>' distort is a radial projective distortion from a point in the center of a cylinder to a flat plane that is at a tangent to that cylinder.
            <div align="center"><img src="cylinder2plane.png" width="383" height="275" border="1" alt="[diagram]"></div>This arrangement is typical of a special pinhole camera known as a <a href="http://mottweilerstudio.com/wordpress/cameras/">P.90 camera</a>. where a photo of 90 degree arc is captured on a film that forms a cylinder in the camera. Here is an example photo from such a camera...
            <div align="center"><img src="../img_photos/p90_orig.jpg" width="512" height="328" border="1" alt="[photo]"></div>The problem with this is that the resulting image is distorted, so that straight lines become curved arcs, due to the physical arrangement of the film. Essentually a curved surface wrapping itself around 'point' projection source (a pinhole). Note that normal pin hole camera does not have this problem as you are projecting onto a flat surface from a point source. The '<code>Cylinder2Plane</code>' distort fixes this by projecting the image from its cylindrical arrangement onto a flat plane. It takes the parameters...
            <div align="center">
              <code><i>fov_angle &nbsp; center_x,y &nbsp; fov_output &nbsp; dest_center_x,y</i></code>
            </div>Only the first parameter the angle of the cameras field of view is required. For a P.90 camera it used a 90mm (radial) focal length and standard 57mm wide film, which in turn produces produces a 'field of view' of <code>90 / 57 * 180/pi</code> or 90.467 degrees. Here for example I project a P90 photo onto a plane to make the image look more 'normal' and make straight lines straight again.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick p90_orig.jpg -virtual-pixel Gray \
          +distort Cylinder2Plane 90.467  p90_plane.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="p90_plane.png"><img src="p90_plane.png" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
            </div><!--
 This produces a black middle line!
   magick p90_sm.png -virtual-pixel Gray \
             +distort Cylinder2Plane 90.467  p90_plane.png
-->
            Note that the both the width and the height of the image has changed, as we are using the 'plus' version of the distort, so as to show all the distorted pixels in the original image. It is wider because of the projection, while the height of that actual image along the vertical center line did not change. The photo and algorithm was from an IM discussion <a href="../forum_link.cgi?f=1&amp;t=18864">Correcting for a curved film plane</a>. The discussion also flowed into another discussion on <a href="../forum_link.cgi?f=1&amp;t=18944">Algorithmic vignetting correction for pinhole cameras</a>.<br>
            The special '<i>fov_output</i>' if given will scale the resulting output image so the width of the output image (typically a viewport size) will exactly match this angle. If no viewport is given, a best match is enabled, to best approximate a 1:1 scaling of the image image, while still aligning the image edges to whole integers. The center-point parameter of the distortion (tangent and horizon point of the input). The last 'center' parameter controls precise floating point positioning of the results in the viewport image 'layer' (that is sub-pixel translations). This with the '<i>center_x,y</i>' parameter allows you to extract parts from a larger image. For example extracting a small 90-degree view from a larger 360 degree panorama image. <i>FUTURE: extracting smaller flat 'viewing' images from a 360 panorama, as well as an animation that slowly pans around those 360 degrees.</i> <!--
<DIV ALIGN=center>
<table class="table table-sm table-hover table-striped" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick mars_panorama_sm.jpg \
          -define distort:viewport=100x100 \
          +distort Cylinder2Plane  '360  %[fx:w*3/4],%[h/2]  90' \
          mars_cube_face.jpg
</samp></pre></TD></TR></TABLE>
  <A HREF="mars_pano_orig.jpg"
     ><IMG SRC="../img_photos/p90_sm.png"  WIDTH=800  HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="p90_plane.png"
     ><IMG SRC="p90_plane.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
-->
            <a name="plane2cylinder" id="plane2cylinder"></a>
            <h3>Plane 2 Cylinder</h3>The '<code>Plane2Cylinder</code>' distort is the reverse of the above projection, and takes the parameters...
            <div align="center">
              <code><i>fov_angle &nbsp; center_x,y</i></code>
            </div>For example, this un-does the previous P.90 camera example.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick p90_plane.png -virtual-pixel Black \
          +distort Plane2Cylinder 90.467  p90_restored.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="p90_restored.png"><img src="p90_restored.png" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
            </div>The results still contain the extra pixels that were added previously, and adds even more. These should be trimmed from the above result. Here I use this distortion to generate an animation of a 'film-strip' complete with film sprocket edge holes.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 12x12 xc: -draw 'circle 6,6 6,2' -negate \
          -duplicate 5 +append +duplicate \
          rose: +swap -background black -append \
          -duplicate 3 +append \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -duplicate 19  -distort SRT '%[fx:72*t/n],0 1 0 0,0' \
          -distort Plane2cylinder 115 \
          -bordercolor Skyblue -border 0x3 -set delay 5 \
          film_strip_anim.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="film_strip_anim.gif"><img src="film_strip_anim.gif" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
            </div><b>Explanation:</b>
            <ul>
              <li>First a hole image is drawn, which is duplicated and appended to make a sequence of 6 holes. Then duplicated again.</li>
              <li>A built-in rose image is then added and sandwiched between the two copies of these sprocket holes and appended together (with black fill) to create a single frame of the final film strip.</li>
              <li>This is duplicated to create a film strip of 4 frames, that will define the length of the final image.</li>
              <li>A 20 frame animation is created using SRT 'translation' distortions See <a href="../anim_mods/#distort">Distort Animations</a>.
              </li>
              <li>Then each of those 20 frames is then distorted onto a cylinder over an arc of 115 degrees, using a virtual pixel setting to generate an infinite horizontale tile of the film strip</li>
              <li>The angle in this case is for just for the width of the input image the width of the final image is more than 180 degrees, as I did not use a 'plus' version of the distort. So while the distorted width shrinks width wise, the output image does not.</li>
              <li>A final border is added, and animation settings applied.</li>
            </ul><br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="freeform_distorts" id="freeform_distorts"></a>
            <h2>Multi-Point and Freeform Distorts</h2><a name="shepards" id="shepards"></a>
            <h3>Shepard's Distortion <font size="-1">(taffy-like distort)</font></h3>Shepard's method (added to IM v6.4.2-4) uses the movement of the given control points to distort the image in terms of 'local' effects. You can think of this as equivalent to a thick block of 'taffy' representing the source image, having pins driven into it and then the pins moved around. More technically it moves points in terms of a <a href="http://www.ems-i.com/smshelp/Data_Module/Interpolation/Inverse_Distance_Weighted.htm">Inverse Squared Distance Interpolation</a>. If only one control point is used, naturally the whole image is moved (translated), just as you would get for an one point '<code><a href="#affine">Affine</a></code>' distortion. Not very interesting. So lets try moving two control points. For example lets torture the 'koala' by pulling on his ears (at '<code>30,11</code>' and '<code>48,29</code>')... <!-- <CODE EXECUTE>
  magick koala.gif -fill none \
          -draw "stroke red  path 'M 30,11 15,11 M 20,8  15,11 20,14'" \
          -draw "stroke lime path 'M 48,29 63,29 M 58,26 63,29 58,32'" \
          koala_ears.png
</CODE>-->
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="koala_ears.png"><img src="koala_ears.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_ear_pull.png"><img src="koala_ear_pull.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>As you can see the parts of the image between the two control points were stretched out because of the control point movement. However all the other parts of the image was left pretty much intact, including the image close to the control point itself, the bottom of the image, and so on. The area that lies in the middle between the control points were pulled and stretched out to ensure the control points are positioned where you requested. What may not be so noticable is that the parts on the far-side of the control points are also compressed, so that as you get further away, the control points have less influence on the result. That is, this distortion generates a 'localized' distortion.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Lets expand our view (using a <a href="#distort_viewport">Distortion Viewport</a>) so we can see this better...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -virtual-pixel Black \
          -set option:distort:viewport 115x115-20-20 \
          -distort Shepards '30,11 15,11  48,29 58,29' \
          +repage koala_ear_pull_2.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="koala_ear_pull_2.png"><img src="koala_ear_pull_2.png" width="115" height="115" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see the shape of the image was also distorted to accommodate the stretched 'head' of the koala.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  To avoid this effect it is more typical to also 'pin' the corners and possibility some of the edges of the image, so that they don't move.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="koala_ear_pull_3.png">
  magick koala.gif -virtual-pixel Black \
          -set option:distort:viewport 115x115-20-20 \
          -distort Shepards '30,11 15,11  48,29 58,29
              0,0 0,0  0,74 0,74   74,0 74,0  74,74 74,74' \
          +repage koala_ear_pull_3.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="koala_ear_pull_3.png"><img src="koala_ear_pull_3.png" width="115" height="115" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Even just moving one point, while pinning other points (just the corners in this case) can be useful. For example lets just move the koala's nose (at '<code>28,24</code>') into the middle of the image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="koala_move_nose.png">
  magick koala.gif -virtual-pixel Black \
          -distort Shepards '28,24 37,37
              0,0 0,0  0,74 0,74   74,0 74,0  74,74 74,74' \
          +repage koala_move_nose.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="koala_move_nose.png"><img src="koala_move_nose.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This specific example is special as it is the distortion used by Fred Weinhaus for his single point 'animated morphing' script "<code><a href="http://www.fmwconcepts.com/imagemagick/shapemorph/">shapemorph</a></code>". However his original script used a slow <a href="../transform/#fx">DIY FX Operator</a>, as <a href="#shepards">Shepards Distortion</a> had yet to be added to IM. This script was actually where the original idea for <a href="#shepards">Shepards Distortion</a> came from.
            <h4>Moving areas of an image</h4>You can even move a whole sections of the image by moving a set of points around that section all together. For example lets move the koala's head sideways by using points around the head (red line), but also pinning the parts of the image we don't want to move (green line). <!-- <CODE EXECUTE>
  magick koala.gif -fill none \
     -draw "stroke red  path 'M 19,8  19,27 26,34 36,37 53,37 58,25'" \
     -draw "stroke lime path 'M 13,20 17,28 25,36 35,39 46,40 50,43'" \
     koala_head.png
</CODE>-->
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" script="" image="koala_head_move.png">
  magick koala.gif -virtual-pixel Black -distort Shepards \
            '19,8, 29,8   19,27 29,27   26,34 36,34
                 33,37 43,37   36,37 46,37   53,37 63,37   58,25 68,25
             13,20 13,20  17,28 17,28  25,36 25,36
                 35,39 35,39   46,40 46,40   50,43 50,43 ' \
          +repage koala_head_move.png
</code></pre>
                  </td>
                </tr>
              </table><a href="koala_head.png"><img src="koala_head.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_head_move.png"><img src="koala_head_move.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Note that while the head was moved, the edge of the head does get badly distorted. The reason is that the distort does not move areas, but points. If those edge marking points are too far apart, then the image will sort of drip, leak, or bend between those points, just like taffy, or jello. (ASIDE: the actual term is stretching a 'rubber sheet' or 'balloon'). Also if two control points are close together, but which move in different directions or amounts, the image could locally swirl and bend around them. The control points still end up in the right locations, but everthing else around them gets severly warped to acheive that goal. And that is what happening along the edge of the head. So how close should edge marking points be? Basically at least half the distance to any other points which are moving differently. So either add more edge points, or put some extra distance between the fixed points, and the moving points. By doing this, you will better define the space in which the image can be stretch and compressed. Also note that the whole image in general also moved to the left, along with the head. Only the control points which were either fixed or moved to specific destinations are guaranteed to be placed correctly. Any parts of the image further away from any control points will also move based on a rough average of all the control point movements. It is thus better to have a lot more 'fixed' points, spread throughout the image, or even some negative moved points some distance outside the image, so as to offset the general average movement. You can also duplicate or double up control points (list them twice) to give specific points more influence or 'power' over the distortion in that area. Here is another version of the 'move head sideways', however this time I gave some extra separation between the moving (red) and fixed (green) points. I also added a lot more fixed points to reduce the average general movement of the distorted image. <!-- <CODE EXECUTE SCRIPT IMAGE=koala_head_2.png>
  magick koala.gif -fill none \
     -draw "stroke red  path
               'M 15,15  19,27  26,34  36,37  53,37'" \
     -draw "stroke lime path 'M 10,2  2,10
                M  4,55   14,47  25,47  45,51  55,45
                M  5,70  15,60  55,60  70,70 '" \
     koala_head_2.png
</CODE>-->
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" script="" image="koala_head_move_2.png">
  magick koala.gif -virtual-pixel Black -distort Shepards \
            '15,15, 25,15   19,27 29,27   26,34 36,34
                33,37 43,37   36,37 46,37    53,37 63,37
             10,2 10,2   2,10 2,10   4,55 4,55   14,47 14,47
                25,47 25,47 45,51 45,51   55,45 55,45
                5,70 5,70  15,60 15,60   55,60 55,60   70,70 70,70' \
          +repage koala_head_move_2.png
</code></pre>
                  </td>
                </tr>
              </table><a href="koala_head_2.png"><img src="koala_head_2.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_head_move_2.png"><img src="koala_head_move_2.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>The final thing to do in the above is to simply set a better "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" setting to set what color the undefined black areas in the above should be. <a name="shepards_rotation" id="shepards_rotation"></a>
            <h4>Shepards and Image Rotations</h4>One aspect of this distortion is that it does not like any form of rotation! For example, here is a repeat of the <a href="#perspective">Perspective</a>, and <a href="#bilinear_forward">BilinearForward</a>, along side the <a href="#shepards">Shepards Distortion</a>.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
<br>  magick mandrill_grid.jpg -alpha set -virtual-pixel black \
       -distort Perspective \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_pers.jpg
<br>  magick mandrill_grid.jpg -alpha set -virtual-pixel black -interpolate Spline \
       -distort BilinearForward \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin.jpg
  magick mandrill_grid.jpg -alpha set -virtual-pixel black -interpolate Spline \
       -distort Shepards \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_shep.jpg
</samp></pre>
                  </td>
                </tr>
              </table>
              <table>
                <tr>
                  <td align="center">
                    <a href="../img_photos/mandrill_grid.jpg"><img src="../img_photos/mandrill_grid.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Original</font>
                  </td>
                  <td><img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"></td>
                  <td align="center">
                    <a href="mandrill_pers.jpg"><img src="mandrill_pers.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Perspective</font>
                  </td>
                  <td align="center">
                    <a href="mandrill_blin.jpg"><img src="mandrill_blin.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Bilinear</font>
                  </td>
                  <td align="center">
                    <a href="mandrill_shep.jpg"><img src="mandrill_shep.jpg" width="128" height="128" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Shepards</font>
                  </td>
                </tr>
              </table>
            </div>Note how <a href="#shepards">Shepards Distortion</a> produced a very curvy image when compared to the other two distortion methods. That is because it tries to preserve the image exactly in the area close-in to the given control points. And that includes the rotation of the image. As a result of this 'preservation' the grid is curved so that it remaines 'orthoginal' at the actual control point. It is a bit like those 'pins' at the control points are not actually round pins, but 'crosses', forcing the 'jelly' or 'rubber sheet' holding the image to also preserve the rotation of the image. This is also the source of many of the 'swirling' effects this distortion can produce. For example, if we take two points in the image and push them past each other. The image will swirl, not rotate. For example lets try to push the koala's ears toward each other rather than apart. <!-- <CODE EXECUTE>
  magick koala.gif -fill none \
          -draw "stroke red  path 'M 30,11 45,11 M 40,8  45,11 40,14'" \
          -draw "stroke lime path 'M 48,29 33,29 M 38,26 33,29 38,32'" \
          koala_push.png
</CODE>-->
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 40,11  48,29 38,29' \
          koala_ear_push.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="koala_push.png"><img src="koala_push.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="koala_ear_push.png"><img src="koala_ear_push.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div><a name="shepards_power" id="shepards_power"></a>
            <h4>Shepard's Power Factor</h4>Normally the distance weights of a shepard's IWD (Inverse Weighted Distance) follows an inverse square law (<sup>1</sup>/<sub>r<sup>2</sup></sub>), however as of IM v6.8.0-10 you can now use the expert <a href="../basics/#define">define</a> '<code>shepards:power</code>' to control the 'power-level' of the global weights. If not defined it has a value of 2.0, but by defining it smaller you can general more localized distortions around the moved control points from the overall average displacement of the distorted image. Using a larger value will generate a larger area of effect around the control points. For example, here is a repeat of the 'koala ear pulling' example, with different power levels applied to distortion weights.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -virtual-pixel Black -define shepards:power=0.5 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow0.5.png
  magick koala.gif -virtual-pixel Black -define shepards:power=1.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow1.png
<br>  magick koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull.png
  magick koala.gif -virtual-pixel Black -define shepards:power=3.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow3.png
  magick koala.gif -virtual-pixel Black -define shepards:power=8.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow8.png
</samp></pre>
                  </td>
                </tr>
              </table>
              <table>
                <tr valign="top">
                  <td align="center">
                    <a href="koala_ears.png"><img src="koala_ears.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">Original<br>
                    & action</font>
                  </td>
                  <td align="center"><img src="../img_www/right.gif" width="20" height="20" vspace="30" alt="==&gt;"></td>
                  <td align="center">
                    <a href="koala_ear_pull_pow0.5.png"><img src="koala_ear_pull_pow0.5.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 0.5</font>
                  </td>
                  <td align="center">
                    <a href="koala_ear_pull_pow1.png"><img src="koala_ear_pull_pow1.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 1.0</font>
                  </td>
                  <td align="center">
                    <a href="koala_ear_pull.png"><img src="koala_ear_pull.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 2.0<br>
                    (default)</font>
                  </td>
                  <td align="center">
                    <a href="koala_ear_pull_pow3.png"><img src="koala_ear_pull_pow3.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 3.0</font>
                  </td>
                  <td align="center">
                    <a href="koala_ear_pull_pow8.png"><img src="koala_ear_pull_pow8.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 8.0</font>
                  </td>
                </tr>
              </table>
            </div>All the above image results use exactly the same set of control point movements. The only difference is the area of effect around those control points. A small power will 'localise the movements to only the area close into the control point, while larger powers will drag more of the image around the control point with it. At very larger powers, this pull will tend to 'rip' the image into separate areas along the lines midway between the control points. You could even use much larger powers, which will simply translate regions around the source control point, into areas around the destination control point. These areas will form a pattern of 'voronoi regions' and can contain a duplicate copies of the source image. For example, here I map the area around the koala's nose (at coordinates 28,24), into 7 different areas in a hexagonal pattern, producing a 'insect eye' like effect in a very efficent manner.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="koala_move_nose.png">
  magick koala.gif -virtual-pixel Black -define shepards:power=25 \
          -distort Shepards '28,24 35,35 \
                      28,24 20,10   28,24 50,10 \
                      28,24 20,60   28,24 50,60 \
                      28,24 10,35   28,24 60,35'  koala_hexagonal.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="koala_hexagonal.png"><img src="koala_hexagonal.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Remember <a href="#shepards">Shepards Distortion</a> is actually equivelent to a displacement map (mapping destination pixels to the source image) generated using the same technique as the <a href="../canvas/#shepards">Shepards, Sparse Color Operator</a>, which is also effected by this same power factor define. <a name="shepards_summary" id="shepards_summary"></a>
            <h4>Shepard's Distortion, in sumary</h4>The <a href="#shepards">Shepards Distortion</a> is a very versatile and free form method, limiting its distortions to areas marked by the movements, or non-movements of the given points. Its distortions are localized and restricted according to the distances between neighboring control-points, though all points still do have an averaged global effect. Just remember that this distortion is point driven, not line or area driven, so parts between the points can bulge, or swirl unexpectedly when control points, that move differently, are positioned too close together. It will swirl and stretch and compress the image between the control points, but it tries hard not to rotate or scale the image near the control points. And finally it may produce an overall average translation of the image far away from any control point. However if blocks of control points can be moved, preserving their general relative positions, it does provide a way to implement a general and very simple point driven 'Image Morphing' technique. Fred Weinhaus script '<a href="http://www.fmwconcepts.com/imagemagick/shapemorph2/">shapemorph2</a>' uses <a href="#shepards">Shepards Distortion</a> to provide a good general purpose 'Animated Image Morphing' program.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Internally this distort is equivalent to using the <a href="../canvas/#shepards">Shepards Sparse Color</a> gradient generator to create two <a href="../mapping/#displace">Relative Displacement Maps</a> to distort the image. This is what Fred Weinhaus's original "<code><a href="http://www.fmwconcepts.com/imagemagick/shapemorph/">shapemorph</a></code>" script does, and was the source of the distortion technique.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Due to the complexity of calculations needed in using <a href="#shepards">Shepards Distortion</a>, IM does not provide any form of 'best-fit' destination viewport using the plus "<code><a href="#distort_bestfit">+distort</a></code>" form of the operator. You can however still use the <a href="#distort_viewport">Distort Viewport</a> option to define a larger output image.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>For the same reasons the <a href="#area_resample">Area Resampling</a> is turned off. As such areas of extreme compression (more than a factor of 2) will likely show some aliasing effects. For example, see the edges of the hexagon pattern in the last example. However <a href="#super_sample">Super-Sampling</a> can be used to improve the final image quality of results, and reduce such aliasing effects.</i></font></td>
              </tr>
            </table><br>
            <br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
          </div>
        </div>
      </div>
    </div>
  </main>
  <footer class="magick-footer">
    <div class="container-fluid">
      Created: 14 January 2009 (distorts/warping sub-division)<br>
      Updated: 21 March 2012<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://imagemagick.org/Usage/distorts/</code>
    </div>
  </footer>
</body>
</html>
