<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Morphology of Shapes -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/morphology/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Morphology of Shapes</h1>
        <div>
          <dl>
            <dt><b>Index</b></dt>
            <dt>
              <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
            </dt>
            <dd>
              <a href="#intro"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Morphology Introduction</a>
              <ul>
                <li>
                  <a href="#morphology">Morphology Operator</a>
                </li>
                <li>
                  <a href="#kernel">Basic Built-In Morphology Kernels</a>
                  <ul>
                    <li>
                      <a href="#unity"><code>Unity</code></a>,&nbsp; <a href="#diamond"><code>Diamond</code></a>,&nbsp; <a href="#square"><code>Square</code></a>,&nbsp; <a href="#octagon"><code>Octagon</code></a>,&nbsp; <a href="#disk"><code>Disk</code></a>,&nbsp; <a href="#plus"><code>Plus</code></a>,&nbsp; <a href="#cross"><code>Cross</code></a>,&nbsp; <a href="#ring"><code>Ring</code></a>,&nbsp; <a href="#rectangle"><code>Rectangle</code></a>
                    </li>
                    <li>
                      <a href="#user">User Defined Kernels</a>
                    </li>
                    <li>
                      <a href="#image2kernel">Image to User Kernel</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#iteration">Iterating (Repeating) Morphology Operations</a>
                </li>
                <li>
                  <a href="#verbose">Verbose Output of Changes</a> (for monitoring)
                </li>
                <li>
                  <a href="#showkernel">Displaying the Generated Kernel</a> (for debugging purposes)
                </li>
                <li>
                  <a href="#kernel2image">Generating an Image of the Kernel</a> (for debugging purposes)
                </li>
                <li>
                  <a href="#multi-kernel">Multiple Kernel List Handling</a>
                  <ul>
                    <li>
                      <a href="#multi-kernel">Generating a List of Multiple Kernels</a>
                    </li>
                    <li>
                      <a href="#rotated_kernels">Expanding to a Rotated Kernel List</a>
                    </li>
                    <li>
                      <a href="#kernel_compose">Multiple Kernel Results Merging : Re-iterate or Compose</a>
                    </li>
                  </ul>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#basic"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Basic Morphology Methods</a>
              <ul>
                <li>
                  <a href="#erode"><code>Erode</code></a>,&nbsp; <a href="#dilate"><code>Dilate</code></a>,&nbsp; <a href="#open"><code>Open</code></a>,&nbsp; <a href="#close"><code>Close</code></a>,&nbsp; <a href="#smooth"><code>Smooth</code></a>
                </li>
                <li>
                  <a href="#greyscale_flat">Flat Grey-scale Morphology</a>
                </li>
                <li>
                  <a href="#greyscale">True Grey-scale or 3-dimensional Morphology</a>
                </li>
                <li>
                  <a href="#intensity">Intensity Variant of Basic Methods</a>
                </li>
                <li>
                  <a href="#alturnative">Alternative Basic Morphology Techniques</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#difference"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Difference Morphology Methods</a>
              <ul>
                <li>
                  <a href="#edgein"><code>EdgeIn</code></a>,&nbsp; <a href="#edgeout"><code>EdgeOut</code></a>,&nbsp; <a href="#edge"><code>Edge</code></a>,&nbsp; <a href="#top-hat"><code>Top-Hat</code></a>,&nbsp; <a href="#bottom-hat"><code>Bottom-Hat</code></a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#using"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Using Low Level Morphology Methods</a>
              <ul>
                <li>
                  <a href="#channel">Basic Morphology and Channels</a>
                </li>
                <li>
                  <a href="#granularity">Granularity of a Collection of Shapes</a>
                </li>
                <li>
                  <a href="#asymmetric">Asymmetric Kernel Effects</a> (method testing)
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#hmt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Hit and Miss (HMT) Pattern Matching</a>
              <ul>
                <li>
                  <a href="#hitmiss">Hit And Miss</a>
                  <ul>
                    <li>
                      <a href="#hitmiss_greyscale">Hit and Miss with Grey-Scale Images</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#thicken">Thicken - Add pixels that match</a>
                  <ul>
                    <li>
                      <a href="#thicken_convexhull">Octagonal Convex Hull</a>
                    </li>
                    <li>
                      <a href="#thicken_greyscale">Thicken Grey-scale Images</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#thinning">Thinning - Subtracting pixels that match</a>
                  <ul>
                    <li>
                      <a href="#thinning_edgedet">Thinning Edge Detector Output</a>
                    </li>
                    <li>
                      <a href="#thinning_skeleton">Thinning down to a Skeleton</a>
                    </li>
                    <li>
                      <a href="#skeleton_info">Skeleton Information</a>
                    </li>
                    <li>
                      <a href="#thinning_pruning">Pruning Lines</a>
                    </li>
                    <li>
                      <a href="#thinning_prune_fast">Fast Pruning of Lines</a>
                    </li>
                    <li>
                      <a href="#thinning_style">Thinning Style - Sequential vs Simultaneous</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#pattern_kernels">Pattern Matching Kernels</a>
                  <ul>
                    <li>
                      <a href="#peaks"><code>Peaks</code></a>,&nbsp; <a href="#edges"><code>Edges</code></a>,&nbsp; <a href="#corners"><code>Corners</code></a>,&nbsp; <a href="#diagonals"><code>Diagonals</code></a>,&nbsp; <a href="#lineends"><code>LineEnds</code></a>,&nbsp; <a href="#linejunctions"><code>LineJunctions</code></a>,&nbsp;<br>
                      <a href="#ridges"><code>Ridges</code></a>,&nbsp; <a href="#convexhull"><code>ConvexHull</code></a>,&nbsp; <a href="#skeleton"><code>Skeleton</code></a>,&nbsp; <a href="#thinse"><code>ThinSE</code></a>
                    </li>
                  </ul>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#distance"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Distance Morphology Method</a>
              <ul>
                <li>
                  <a href="#distance_kernels">Distance Kernels</a>,&nbsp;
                  <ul>
                    <li>
                      <a href="#chebyshev"><code>Chebyshev</code></a>,&nbsp; <a href="#manhattan"><code>Manhattan</code></a>,&nbsp; <a href="#octagonal"><code>Octagonal</code></a>,&nbsp; <a href="#knight"><code>Euclidean&nbsp;(knight)</code></a>,&nbsp; <a href="#euclidean"><code>Euclidean</code></a>,&nbsp;
                    </li>
                    <li>
                      <a href="#distance_compare">Comparison of Distance Kernels</a>
                    </li>
                    <li>
                      <a href="#distance_user">Special User defined Distance Kernels</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#distance_anti-alias">Distance with an Anti-Aliased Shape</a>
                </li>
                <li>
                  <a href="#distance_feather">Feathering Shapes using Distance</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#conditional"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Conditional or Constrained Morphology</a>
              <ul>
                <li>
                  <a href="#dilate_conditional">Conditional Dilation</a>
                </li>
                <li>
                  <a href="#distance_constrainted">Constrained Distance</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#skeletons"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Generating Skeletons from Shapes.</a> <i>Under Construction</i>
              <ul>
                <li>
                  <a href="#distance_skeleton">Distance to Skeleton</a>
                </li>
                <li>
                  <a href="#autotrace_skeleton">Skeleton using Autotrace</a>
                </li>
              </ul>
            </dd>
          </dl>Morphology modifies an image in various ways based on the nearby 'neighbourhood' of the other pixels that surround it. This in turn can provide a huge range of effects, Shape expansion and contraction (dilate/erode), to distance from edge, to thining down to a skeleton, or mid-line axis. Even the more anchiet method of 'convolution' techniques that provide blurring and sharpening techniques (next section), is in a way a type of morphology method. Essentually morphology is for the modification, determination, and discovery of the shapes of objects found within an image.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="intro" id="intro"></a>
          <h2>Morphology Introduction</h2>Morphology was originally developed as a method by which the structure of shapes within an image could be cleaned up and studied. It works by comparing each pixel in the image against its neighbours in various ways, so as to either add or remove, brighten or darken that pixel. Applied over a whole image, perhaps repetitively, specific shapes can be found and/or removed and modified. For example if an pixel is white and completely surrounded by other white pixels, then that pixel is obviously not on the edge of the image. You may then like to make that pixel black, so as to leave only edge pixels turned on. A method known as '<code><a href="#edgein">EdgeIn</a></code>' (see below). The whole process actually depends on the definition of a 'Structuring Element' or 'Kernel', which defines what pixels are to be classed as 'neighbours' for each specific morphological method. Exactly what size and shape this 'neighbourhood' often depends on just what you are trying to achieve, or what you are specifically looking for within the image. Here are some examples of various kernels that have been converted into images (using a special script "<code><a href="../scripts/kernel2image">kernel2image"</a></code>") showing some of the 'neighbourhoods' around a central pixel, 'origin'.
          <div align="center">
            <!--<CODE EXECUTE>
  kernel2image -20.2 -m "Diamond"            kernel_diamond.gif
  kernel2image -20.2 -m "Square"             kernel_square.gif
  kernel2image -15.2 -m "Octagon"            kernel_octagon.gif
  kernel2image -9.1  -m "Disk"               kernel_disk.gif
  kernel2image -15.2 -m "Plus"               kernel_plus.gif
  kernel2image -15.2 -m "Rectangle:7x4+3+2"  kernel_rectangle.gif
  kernel2image -20.2 -m -k 0 "Corners"       kernel_corner.gif
  kernel2image -8.1 -mn -n "Gaussian:5x2"    kernel_gaussian.gif

  # small GIF's are broken!
  kernel2image "Disk" kernel_disk_raw.gif
</CODE>-->
            <table>
              <tr valign="center" height="100">
                <td align="center">
                  <a href="kernel_diamond.gif"><img src="kernel_diamond.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_square.gif"><img src="kernel_square.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_octagon.gif"><img src="kernel_octagon.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_disk.gif"><img src="kernel_disk.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_plus.gif"><img src="kernel_plus.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_rectangle.gif"><img src="kernel_rectangle.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_corner.gif"><img src="kernel_corner.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
                <td align="center">
                  <a href="kernel_gaussian.gif"><img src="kernel_gaussian.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
          </div>The images have been scaled to highlight the individual elements of the 'kernel', and as you can see typical kernels are often very small. In fact the 'Disk' kernel show above is actually "<img src="kernel_disk_raw.gif" width="9" height="9" border="0" alt="[Raw Disk Kernel Image]">", and that is one of the largest kernels shown above. However the 'kernels' are not really images. Just an array of floating-point values with one element specified to be the 'origin' of the kernel. This special element is the location of the pixel that will be 'effected' by the defined neighbourhood, and is typically though not always the center pixel of a symetrical kernel. Note that these are only some examples of possible neighbourhoods. Some kernels can be made larger, typically by increasing a 'radius' argument specific to that kernel, while others used for special purposes are of fixed size. For simple kernels, such as the first two, the morphological method could be repeated (iterated) to increase the effective 'size' of the kernel, so as to effect more pixels further away from the 'origin' (as marked). This does not always work however, and can produce unexpected results, however it is sometimes faster than directly using a larger kernel, but again that is not always the case. The final size and shape of a 'Structuring Element', or 'SE', as a kernel is termed in morphology research papers, is important as a means of locating and enhancing or deleting image elements that are larger or smaller than this shape. This is what makes morphology extremely powerful as a means of sorting out various elements within images. However the larger the kernel, the longer the morphological methods will take, so it is better to keep the kernels small. All of the kernels shown, excluding the last one, are actually shaped. The parts that are transparent are <i>not</i> part of the defined 'neighbourhood' of the kernel. That is, they will do not have any valid value, and will not take part in any of the morphology calculations. Note how the second last kernel '<code>Corner #0</code>' not only has 'on' values, but also 'off' values, as part of its 'shape'. Both values, as well as those that are transparent (not part of shape) are important to the <a href="#hitmiss">Hit-n-Miss</a> and related methods (see below). This specific kernel is only the first of a series of kernels that to locate 'corner' pixels of binary shapes within an image. The last 'kernel' shown above is fully defined over a large rectangular (square) area. Also unlike the other kernels which only use values of 1 (white), 0 (black), or a special 'undefined' value, the values of this kernel actually range from near-zero (almost-black) at the edges to a maximum (pure-white) value in the center. However such kernels can also use negative, or even very large values, well beyond the normal range of other kernels. Remember a kernel is really just an array of values, and these could have any value, not just a 0 to 1 range. This type of kernel is especially important in '<a href="../convolve/#intro">Convolution Operations</a>', a special method that has been around far longer than morphology itself. As a result IM has a very large number of built-in, or 'Named' kernels of this type. This will be looked at in more detail in the next section of IM Examples, <a href="../convolve/">Convolution of Images</a>'. Now as I already mentioned, kernels are not really images. They are simply an array of floating point values. We will be looking at these actual values (which was converted into an image for viewing, above) latter. <a name="morphology" id="morphology"></a>
          <h3>Morphology Operator</h3>The "<code><a href="../option_link.cgi?morphology">-morphology</a></code>" operator is a very complex, as it provides the user with a lot of controls over its actions.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  -morphology {<i>method</i>}[:{<i>iterations</i>}] <!--
                  -->  {<i>kernel</i>}[:[<i>k_args</i>}]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>Note that you need to provide at least two items, the morphology '<i>method</i>', telling the operator type of operation you want to apply to the image, and a '<i>kernel</i>' specifying what 'neighbouring' pixels should effect the final result. Both are equally important and both can have far reaching consequences. You can get a list of the methods that are available using "<b><code>-list&nbsp;morphology</code></b>". A list of the built-in kernels that we have included in IM can be see with "<b><code>-list&nbsp;kernel</code></b>". We will go though the various methods, and the kernels that those methods may use later.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?morphology">-morphology</a></code>" operator (basic methods) and the initial set of kernels was added to ImageMagick version 6.5.9-0 by myself, while I was on a vacation in China. December 2009 to January 2010.<br>
              <br>
              However it is posible to perform simplified 'square' kernel morphology using the older and closely related "<code><a href="../option_link.cgi?convolve">-convolve</a></code>" method. See <a href="#alturnative">Alternative Basic Morphology Techniques</a> below.<br>
              <br></i></font></td>
            </tr>
          </table><a name="kernel" id="kernel"></a> <a name="man_kernels" id="man_kernels"></a>
          <h3>Basic Built-In Shape Kernels</h3>As the kernel is common to all the morphology methods, and the results of the various methods depend heavily on the actual kernel selected, we will first look at how you can define or select a kernel to use. A good selection of kernels have already predefined for you and often you need look no further than these. You can get a list of the pre-defined built-in kernels by using "<code>-list&nbsp;kernel</code>" All kernels have a specific size, typically a square which has an odd number of pixels per side, the center of which is the 'origin' of the kernel. However as you will see the "<code><a href="../option_link.cgi?morphology">-morphology</a></code>" operator is not restricted to this limitation. The most common <i>k_argument</i> used for built-in kernels, and generally the first argument given is a '<i>radius</i>'. This defines how big the typical odd-sized square neighbourhood of the kernel will be. The final kernel size will generally be twice the radius plus one (for the center pixel). That is, a '<i>radius</i>' of '<code>2</code>' will create a kernel that is 5×5 pixels square. While a '<i>radius</i>' typically defines the size of the final kernel, and thus the overall speed of the morphological operation over the images, it may not be the most important factor, especially for <a href="#convolve_kernels">Convolution Kernels</a> where the values have a greater effect on results than the kernels size. If a '<i>radius</i>' set to 0, or left undefined the '<i>radius</i>' will automatically default to some reasonable or most commonly used value, depending on the kernel involved. <!--<CODE EXECUTE>
   kernel2image -35.2 -m "Unity"    kernel_unity.gif
</CODE>-->
          <a href="kernel_unity.gif"><img src="kernel_unity.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="unity" id="unity"></a>
          <h4>Unity</h4>This is a special kernel that is specifically used when you need a 'No-Op' kernel. Most morphological methods using this kernel will either re-produce the original image, or generate a blank result. The kernel has no arguments. This exact same single element kernel can also be generated using '<code><a href="#disk">Disk:0.5</a></code>', which also allow you to specify a scaling argument as part of the kernels generation. <a href="kernel_diamond.gif"><img src="kernel_diamond.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="diamond" id="diamond"></a>
          <h4>Diamond</h4>The most minimal, though perhaps not the simplist kernel is the '<b><code>Diamond</code></b>' built-in kernel. A simple way to look at the basic kernel is to use a <a href="#dilate">Dilate</a> morphology method, on an image containing a single white pixel on a black background. This basically expands the single pixel into the 'shape' of the kernels neighbourhood. Here is the result of a using '<code>Dilate</code>' with the minimal '<code>Diamond</code>' built-in kernel, and scaling the result larger to make it more visible.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick xc: -bordercolor black -border 5x5 pixel.gif
  magick pixel.gif -scale 800% pixel_mag.gif
  magick pixel.gif -morphology Dilate Diamond \
                    -scale 800% k_diamond.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="k_diamond.gif"><img src="k_diamond.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Remember all the kernel image results in this area of IM examples have been enlarged to allow you to see the individual pixels. In reality all the kernels and the results we are showing are very small, as they should be. In this case the image being dilated only 11×11 pixels in size and has been scaled 8 times for display.</i></font></td>
            </tr>
          </table>This is actually a fairly good kernel for morphological operations, and basically defines the most minimal practical neighbourhood: the original pixel, plus the four pixels in direct contact. Another name for this type of kernel is a 'Z<sub>4</sub>' structuring element. It looks rather like a tiny 'plus' sign. The diamond shape only becomes apparent as the radius increases. The optional <i>k_arg</i> for this kernel can take two values, like this...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
     Diamond[:{<i>radius</i>}[,{<i>scale</i>}]]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>For all the shape kernels the most important argument is <i>radius</i> and as mentioned before is an integer that represents the distance from the center 'origin' to the nearest edge. As such the final '<code>Diamond</code>' kernel is a square (2 times <i>radius</i> plus 1) containing the diamond shape. Here is the results of using a larger <i>radius</i> to generate a large kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="">
  for r in 1 2 3 4; do
    magick pixel.gif -morphology Dilate Diamond:$r -scale 800% k_diamond:$r.gif
  done
</code></pre>
                </td>
              </tr>
            </table>
            <table>
              <tr valign="top">
                <td align="center">
                  <a href="k_diamond_1.gif"><img src="k_diamond_1.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Diamond:1<br>
                  <font size="-1">(default)</font>
                </td>
                <td align="center">
                  <a href="k_diamond_2.gif"><img src="k_diamond_2.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Diamond:2
                </td>
                <td align="center">
                  <a href="k_diamond_3.gif"><img src="k_diamond_3.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Diamond:3
                </td>
                <td align="center">
                  <a href="k_diamond_4.gif"><img src="k_diamond_4.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Diamond:4
                </td>
              </tr>
            </table>
          </div>The other <i>k_argument</i> is <i>scale</i> which defaults to a value of 1.0. Typically this is used to change the actual values used by the kernel to form the shape. This is generally only important to special methods such as <a href="#convolve">Convolve</a>, and <a href="#greyscale">Grey-scale Morphology</a>. <a href="kernel_square.gif"><img src="kernel_square.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="square" id="square"></a>
          <h4>Square</h4>The '<b><code>Square</code></b>' is the most commonly used kernel for morphology, as it is easiest to apply using other alterantive techniques. However it is not the most minimal kernel (see '<code><a href="#diamond">Diamond</a></code>' above).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                By default the '<code>Square</code>' kernel uses a 3x3 pixel neighbourhood around the 'center'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif  -morphology Dilate Square -scale 800% k_square.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_square.gif"><img src="k_square.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Basically this means that all 8 neighbours of the original pixel will be classed as part of that pixels neighbourhood. As a result it is a good kernel for averaging pixels, or expanding/shrinking some shape by one pixel. As with all the shape kernels it takes the same <i>k_arguments</i> as shown for the <a href="#diamond">Diamond Kernel</a> above, with the first argument <i>radius</i> being the most important.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="">
  for r in 1 2 3 4; do
    magick pixel.gif  -morphology Dilate Square:$r -scale 800% k_square:$r.gif
  done
</code></pre>
                </td>
              </tr>
            </table>
            <table>
              <tr valign="top">
                <td align="center">
                  <a href="k_square_1.gif"><img src="k_square_1.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Square:1<br>
                  <font size="-1">(default)</font>
                </td>
                <td align="center">
                  <a href="k_square_2.gif"><img src="k_square_2.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Square:2
                </td>
                <td align="center">
                  <a href="k_square_3.gif"><img src="k_square_3.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Square:3
                </td>
                <td align="center">
                  <a href="k_square_4.gif"><img src="k_square_4.gif" width="88" height="88" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a><br>
                  Square:4
                </td>
              </tr>
            </table>
          </div>The default (radius=1) for this kernel as mentioned is a 3×3 square, and is commonly known as a 'Z<sub>8</sub>' structuring element (for the number of immediate neighbours involved). <a href="kernel_octagon.gif"><img src="kernel_octagon.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="octagonal" id="octagonal"></a>
          <h4>Octagon</h4>The '<b><code>Octagon</code></b>' kernel is a 8 sided shaped kernel. And was specifically designed to match the '<code><a href="octagonal">Octagonal Distance Metric</a></code>'. Do not confuse the two as they are very different kernels. Here are the resulting kernels for small radii... <!--<CODE EXECUTE>
   kernel2image -20.2 -m "Octagon:1"  kernel_octagon_1.gif
   kernel2image -15.2 -m "Octagon:2"  kernel_octagon_2.gif
   kernel2image -12.2 -m "Octagon:3"  kernel_octagon_3.gif
   kernel2image -10.1 -m "Octagon:4"  kernel_octagon_4.gif
   kernel2image -9.1  -m "Octagon:5"  kernel_octagon_5.gif
</CODE>-->
          <div align="center">
            <a href="kernel_octagon_1.gif"><img src="kernel_octagon_1.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_octagon_2.gif"><img src="kernel_octagon_2.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_octagon_3.gif"><img src="kernel_octagon_3.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_octagon_4.gif"><img src="kernel_octagon_4.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_octagon_5.gif"><img src="kernel_octagon_5.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>Note that at radius 1, you get the same kernel as a "Diamond" kernel. Because of this the default octagon size is of radius '<code>2</code>'.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>From this point on I will be using a special <a href="#kernel2image">kernel2image</a> script to generate images of the kernels as they are much clearer than using a raw "dilate-scale" method (as above). Remember however the kernels are in generally very small, though Octagon and Disk kernels (see next) can become very large for specific uses.<br>
              <br></i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code>Octagon</code>" kernel was added in IM v6.6.9-4, along with the "<code><a href="#octagonal">Octagonal</a></code>" distance kernel.</i></font></td>
            </tr>
          </table><a href="kernel_disk.gif"><img src="kernel_disk.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="disk" id="disk"></a>
          <h4>Disk</h4>The '<code>Disk</code>' kernel is as you would expect, a circular shape. And is commonly used when a very large morphological kernel is needed. Note however it is an aliased boolean circle. However the <i>radius</i> argument for a disk can be a floating point number, which allows you to produce a quite a range of shapes, using small radii. <!--<CODE EXECUTE>
   kernel2image -30.2 -m "Disk:0.5"  kernel_disk_01.gif
   kernel2image -20.2 -m "Disk:1.0"  kernel_disk_02.gif
   kernel2image -20.2 -m "Disk:1.5"  kernel_disk_03.gif
   kernel2image -15.2 -m "Disk:2.0"  kernel_disk_04.gif
   kernel2image -15.2 -m "Disk:2.5"  kernel_disk_05.gif
   kernel2image -15.2 -m "Disk:2.9"  kernel_disk_06.gif
   kernel2image -12.1 -m "Disk:3.5"  kernel_disk_07.gif
   kernel2image -12.1 -m "Disk:3.9"  kernel_disk_08.gif
   kernel2image -10.1 -m "Disk:4.3"  kernel_disk_09.gif
   kernel2image -10.1 -m "Disk:4.5"  kernel_disk_10.gif
   kernel2image -9.1  -m "Disk:5.3"  kernel_disk_11.gif
</CODE>-->
          <div align="center">
            <a href="kernel_disk_01.gif"><img src="kernel_disk_01.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_02.gif"><img src="kernel_disk_02.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_03.gif"><img src="kernel_disk_03.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_04.gif"><img src="kernel_disk_04.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_05.gif"><img src="kernel_disk_05.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_06.gif"><img src="kernel_disk_06.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a><br>
            <a href="kernel_disk_07.gif"><img src="kernel_disk_07.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_08.gif"><img src="kernel_disk_08.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_09.gif"><img src="kernel_disk_09.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_10.gif"><img src="kernel_disk_10.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_disk_11.gif"><img src="kernel_disk_11.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The '<code>Disk:4.3</code>' kernel is the default, and what I regard as the first true disk shape. Disks of this size or larger are especially good for generally rounding and smoothing image shapes. The final size of the kernel containing the disk is the '<i>radius</i>' value rounded down, times 2 plus 1. As such the default '<code>Disk:4.3</code>' kernel has a kernel size radius of 4, making the final kernel size 4 times 2 plus 1, and generating a 9×9 kernel to hold the disk shape. Note that a value less than one (but not zero) will always produce a single pixel kernel, though that is not very useful. After that the kernel tends to mostly produce kernels that can also be generated using the previous kernel types. It is only as the radius gets large that true disk-shaped kernels start to emerge. The most important thing to note is that a disk with a fractional radius works a lot better than using an integer radius. Adding a fraction of about 0.3 to 0.5 is generally recommended, to avoid generating an off looking single pixel on the sides of the disk. <a href="kernel_plus.gif"><img src="kernel_plus.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="plus" id="plus"></a>
          <h4>Plus</h4>The '<code>Plus</code>' kernel is actually a little different to the other morphological shape kernels, in that it is designed to represent a specific 'shape' rather than a simple 'neighbourhood' around a pixel. Using a larger '<i>radius</i>' with this kernel does not simply increase the size of the kernel, but lengthens the arms of the resulting plus sign. The thickness of the arms however does not increase. <!--<CODE EXECUTE>
   kernel2image -20.2 -m "Plus:1"  kernel_plus_1.gif
   kernel2image -15.2 -m "Plus:2"  kernel_plus_2.gif
   kernel2image -10.1 -m "Plus:3"  kernel_plus_3.gif
   kernel2image -9.1  -m "Plus:4"  kernel_plus_4.gif
</CODE>-->
          <div align="center">
            <a href="kernel_plus_1.gif"><img src="kernel_plus_1.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_plus_2.gif"><img src="kernel_plus_2.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_plus_3.gif"><img src="kernel_plus_3.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_plus_4.gif"><img src="kernel_plus_4.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The default size of a '<code>Plus</code>' kernel is a radius of 2, producing 2 pixel 'arms' around the central 'origin'. A '<code>Plus:1</code>' kernel happens to be the same as the default '<code>Diamond</code>' kernel. Note that a '<code>Plus</code>' kernel is a generally not used for normal morphological methods, and should be avoided for such purposes. However it is a very useful if you are wanting to find and highlight single points in an image, such as I do later to display <a href="#skeleton_info">Skeleton Information</a>. Basically it provides a method of <a href="../draw/#symbols">Drawing Symbols</a>, without needing to know exactly where the individual 'points' are located in the image. <!--<CODE EXECUTE>
   kernel2image -13.2 -m "Cross"   kernel_cross.gif
</CODE>-->
          <a href="kernel_cross.gif"><img src="kernel_cross.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="cross" id="cross"></a>
          <h4>Cross</h4>The '<code>Cross</code>' kernel is exactly like '<code><a href="#plus">Plus</a></code>' but rotated 45 degrees. It is also just a special kernel shape suitable for expanding pixels to mark the locations of various points <!--<CODE EXECUTE>
   kernel2image -20.2 -m "Cross:1"  kernel_cross_1.gif
   kernel2image -13.2 -m "Cross:2"  kernel_cross_2.gif
   kernel2image -10.1 -m "Cross:3"  kernel_cross_3.gif
   kernel2image -9.1  -m "Cross:4"  kernel_cross_4.gif
</CODE>-->
          <div align="center">
            <a href="kernel_cross_1.gif"><img src="kernel_cross_1.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_cross_2.gif"><img src="kernel_cross_2.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_cross_3.gif"><img src="kernel_cross_3.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_cross_4.gif"><img src="kernel_cross_4.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div><!--<CODE EXECUTE>
   kernel2image -10.1 -m "Ring"   kernel_ring.gif
</CODE>-->
          <a href="kernel_ring.gif"><img src="kernel_ring.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="ring" id="ring"></a>
          <h4>Ring</h4>The '<code>Ring</code>' kernel, like the '<code><a href="#plus">Plus</a></code>' kernel is also designed as a special 'shape' kernel for marking pixels and generating patterns on images. However it does not just take one radius, it can take two radii and is defined in the same way as <a href="#disk">Disk Kernels</a>...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
     Ring[:{<i>radius1</i>}[,{<i>radius2</i>}[,{<i>scale</i>}]]]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>What it does it turn 'on' any pixel that falls between the two radii, regardless of the order of the two radii given. If no radii are given it defaults to a radii of '<code>2.5</code>' and '<code>3.5</code>', producing a '<code>Ring:2.5,3.5</code>', which looks like a hollow octagonal shaped ring, that is ideal for circling a pixel. By varying the two radii you can create a 'ring' of any size and thickness. Small changes to the radii will add and remove very small numbers of pixels around the edges, allowing you for fine control of the look of the ring. If the two radii are within 1 pixel of each other you can also generate a ring consisting of sparsly separated dots, which can be useful as a special purpose neighbourhood. Small radii will also generate box-like kernels, that can also be useful. If the second radius is not given it will default to a value of '<code>0.5</code>' which effectively defines a full disk, but without the center 'origin' pixel. In otherwords, a disk kernel but excluding the 'origin' pixel. Here are examples of many of the '<code>Ring</code>' kernels that can be generated...<!--<CODE EXECUTE>
   kernel2image -20.1 -m "Ring:1"         kernel_ring_01.gif
   kernel2image -20.1 -m "Ring:1.5"       kernel_ring_02.gif
   kernel2image -20.1 -m "Ring:1,1.5"     kernel_ring_03.gif
   kernel2image -15.1 -m "Ring:2"         kernel_ring_04.gif
   kernel2image -15.1 -m "Ring:1,2"       kernel_ring_05.gif
   kernel2image -15.1 -m "Ring:1.5,2"     kernel_ring_06.gif
   kernel2image -15.1 -m "Ring:1,2.5"     kernel_ring_07.gif
   kernel2image -15.1 -m "Ring:1.5,2.5"   kernel_ring_08.gif
   kernel2image -15.1 -m "Ring:1.5,2.9"   kernel_ring_09.gif
   kernel2image -15.1 -m "Ring:2,2.5"     kernel_ring_10.gif
   kernel2image -12.1 -m "Ring:2,3.5"     kernel_ring_11.gif
   kernel2image -12.1 -m "Ring:2.5,3.5"   kernel_ring_12.gif
   kernel2image -12.1 -m "Ring:2.9,3.5"   kernel_ring_13.gif
   kernel2image -12.1 -m "Ring:3,3.5"     kernel_ring_14.gif
   kernel2image -12.1 -m "Ring:3,3.9"     kernel_ring_15.gif
   kernel2image -10.1 -m "Ring:2.5,4.3"   kernel_ring_16.gif
   kernel2image -10.1 -m "Ring:3.5,4.3"   kernel_ring_17.gif
   kernel2image -10.1 -m "Ring:3.9,4.5"   kernel_ring_18.gif
   kernel2image -10.1 -m "Ring:4,4.5"     kernel_ring_19.gif
   kernel2image -10.1 -m "Ring:4.3,4.5"   kernel_ring_20.gif
   kernel2image -9.1  -m "Ring:4.3,5.3"   kernel_ring_21.gif
</CODE>-->
          <div align="center">
            <a href="kernel_ring_01.gif"><img src="kernel_ring_01.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_02.gif"><img src="kernel_ring_02.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_03.gif"><img src="kernel_ring_03.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_04.gif"><img src="kernel_ring_04.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_05.gif"><img src="kernel_ring_05.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_06.gif"><img src="kernel_ring_06.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_07.gif"><img src="kernel_ring_07.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_08.gif"><img src="kernel_ring_08.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_09.gif"><img src="kernel_ring_09.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_10.gif"><img src="kernel_ring_10.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_11.gif"><img src="kernel_ring_11.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_12.gif"><img src="kernel_ring_12.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_13.gif"><img src="kernel_ring_13.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_14.gif"><img src="kernel_ring_14.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_15.gif"><img src="kernel_ring_15.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_16.gif"><img src="kernel_ring_16.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_17.gif"><img src="kernel_ring_17.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_18.gif"><img src="kernel_ring_18.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_19.gif"><img src="kernel_ring_19.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_20.gif"><img src="kernel_ring_20.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_ring_21.gif"><img src="kernel_ring_21.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>As you can see you have a lot of possibilities, by carefully adjusting the two radii, and provides a good way of showing locations of interest in an image. <a href="kernel_rectangle.gif"><img src="kernel_rectangle.gif" align="right" hspace="10" border="0" alt="[IM Output]"></a> <a name="rectangle" id="rectangle"></a>
          <h4>Rectangle</h4>The '<code>Rectangle</code>' kernel is closely related to the '<code><a href="#k_square">Square</a></code>' kernel above, and by default produces the same square 3x3 kernel. But rather than a simple radius argument, you can give a '<i>geometry</i>' argument to specify the exact size of the rectangular kernel wanted. Here are some specifications and an image of the kernels they produce. <!--<CODE EXECUTE>
   kernel2image -35.2 -m "Rectangle:2x2"      kernel_rect_1.gif
   kernel2image -25.2 -m "Rectangle"          kernel_rect_2.gif
   kernel2image -20.2 -m "Rectangle:4x2"      kernel_rect_3.gif
   kernel2image -20.2 -m "Rectangle:4"        kernel_rect_4.gif
   kernel2image -15.1 -m "Rectangle:7x3"      kernel_rect_5.gif
   kernel2image -15.1 -m "Rectangle:7x1"      kernel_rect_6.gif
   kernel2image -15.1 -m "Rectangle:7x1+1+0"  kernel_rect_7.gif
   kernel2image -15.1 -m "Rectangle:7x1+6+0"  kernel_rect_8.gif
</CODE>-->
          <div align="center">
            <a href="kernel_rect_1.gif"><img src="kernel_rect_1.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_2.gif"><img src="kernel_rect_2.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_3.gif"><img src="kernel_rect_3.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_4.gif"><img src="kernel_rect_4.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a><br>
            <a href="kernel_rect_5.gif"><img src="kernel_rect_5.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_6.gif"><img src="kernel_rect_6.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_7.gif"><img src="kernel_rect_7.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_rect_8.gif"><img src="kernel_rect_8.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>By default the kernel will try to set the 'origin' of the neighbourhood to the exact 'center' of the kernel. But for an even-sized rectangle, it will pick the point to the immediate top and/or left of the center as appropriate. However you can also specify off-centered origins as well. This particular kernel is also good at defining long horizontal and vertical lines, allowing you to search for such objects within images. More on this later. At this time you can not provide a <i>scale</i> factor for a rectangle. All its kernel values will be set to 1.0 only. <a name="user" id="user"></a>
          <h4>User Defined DIY Kernels</h4>You are not restricted to just the built-in kernels, but can also specify your own kernel, and giving the exact values you want the kernel to use...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   "[{<i>geometry</i>}:] {<i>value</i>}, {<i>value</i>}, {<i>value</i>},....."
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The '<i>geometry</i>' specification is basically exactly like the argument of the previous '<code><a href="#k_rectangle">Rectangle</a></code>' kernel. It gives the size of the kernel, and optionally the 'offset' of the neighbourhood 'origin'. If only one number is supplied, it is the dimensions for an square kernel will be assumed.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Remember the geometry value is NOT a 'radius' argument but the overall kernal size.</i></font></td>
            </tr>
          </table>If no '<i>geometry</i>' or '<code>:</code>' is specified, then you are using the 'old' style specification. An odd sized square kernel big enough to hold all the values given will be generated. This is not recommended and only provided for backward compatibility with older versions of ImageMagick. After the '<code>:</code>' (which is required after a '<i>geometry</i>' specification) you then supply <i>width</i> × <i>height</i> floating point values separated by commas and/or whitespace. A special value of '<code>NaN</code>' (meaning "Not a Number") or a '<code>-</code>' on its own, can be used to specify that this point in the kernel is not part of the morphological neighbourhood.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example, here is a specification for a square kernel of width 3, that can be used for convolution blurring of the single pixel image.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif   -morphology Convolve \
            "3:  0.3,0.6,0.3   0.6,1.0,0.6   0.3,0.6,0.3" \
                                         -scale 800%  k_user_3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_user_3.gif"><img src="k_user_3.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>With a single pixel, <a href="#convolve">Convolve</a> works almost the same as <a href="#dilate">Dilate</a>, however <a href="#convolve">Convolve</a> uses the kernels values, expanding and adding neighbouring values together. <a href="#dilate">Dilate</a> on the other hand generally works using an on/off (boolean) shape and the maximum of all the neighbours. However when applied on a single isolated pixel with a boolean shape you get the same result. Note how you can add extra spacing (or even newlines) to the input string so as to separate the the individual rows of the rectangular kernel definition.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                And here I defined a 5×3 rectangular area, but use the special 'nan' (not a number) values to cut off the corners to make an oval shaped kernel...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif   -morphology Dilate \
            "5x3: nan,1,1,1,nan   1,1,1,1,1   nan,1,1,1,nan " \
                                    -scale 800%   k_user_5x3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_user_5x3.gif"><img src="k_user_5x3.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                And finally here is an example of specifying a rectangular neighbourhood, that forms a 'L' shape around the 'origin'. I used '-' instead of 'nan' to specify the parts that is not part of the kernel. Note that the origin of this kernel is not even part of its own neighbourhood, it can be located anywhere inside the rectangular bounds of the kernel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif   -morphology Dilate \
            "2x3+1+1:   1,-   1,-   1,1   "  -scale 800% k_lman.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_lspace.gif"><img src="k_lman.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see user kernel specification is very flexible, allowing you to specify just about any type of kernel you like, whether it is a convolution kernel with lots of fractions, or a shaped kernel with 'not part of neighbourhood' elements, for morphological methods. <a name="image2kernel" id="image2kernel"></a>
          <h4>Convert an Image to an User Kernel</h4>To make it easier to generate DIY kernels you can use the "<code><a href="../scripts/image2kernel">image2kernel</a></code>" script to create kernels. For example, here I magick a small flag (&nbsp;<img src="../images/flag.gif" align="bottom">&nbsp;) into an user kernel data file ("<code><a href="flag_kernel.dat">flag_kernel.dat</a></code>"), then use it to dilate an image with a couple of pixels in it.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black -fill white \
          -draw 'point 20,15 point 55,30 point 40,60'  points_pixels.gif
  image2kernel -qgm flag.gif flag_kernel.dat

  magick points_pixels.gif \
             -morphology Dilate @flag_kernel.dat \
           flagged_points.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="points_pixels.gif"><img src="points_pixels.gif" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_dilate.gif" align="middle" width="20" height="30" alt="-"> <a href="kernel_flag.gif"><img src="kernel_flag.gif" align="top" vspace="2" hspace="18" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="flagged_points.gif"><img src="flagged_points.gif" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--<CODE EXECUTE>
   kernel2image -6.1 -m  -ml "Flag"  @flag_kernel.dat  kernel_flag.gif
</CODE>-->
          See also <a href="#kernel2image">Generating an Image of the Kernel</a> below, which can generate images (or generate enlarged pretty versions) of a kernel. This technique is also talked about in <a href="../draw/#symbol_alts">Alternatives to Drawing Symbols</a>.<br>
          <a name="iteration" id="iteration"></a>
          <h3>Iterating (Repeating) Morphology Operations</h3>As you have seen you can generate a larger kernel, so as to apply a morphology over a larger neighbourhood. However in most cases a faster alternative to using a larger kernel is to simply repeat (iterate or loop) the morphology operator multiple times. This means that the effect of that operator will be carried further, having the same basic effect as an using a larger kernel, but without the added computational cost of using a larger kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                For example, here is a dialation of a single pixel using a '<code>Diamond:3</code>' kernel...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif  -morphology Dilate Diamond:3 -scale 800% k_diamond_x3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_diamond:3.gif"><img src="k_diamond_x3.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                But you can also achieve the same result by using a smaller '<code>Diamond</code>' kernel (radius 1) three times...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif  -morphology Dilate Diamond \
                     -morphology Dilate Diamond \
                     -morphology Dilate Diamond  -scale 800% k_diamond_x3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_diamond_x3.gif"><img src="k_diamond_x3.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You are still only using a very small 3x3 kernel, but repeating the basic morphological operation three times to produce the same effect as if you are using a larger kernel. In fact repeating small kernels like this is actually a good deal faster than using the much larger kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>A large 'Diamond:3' kernel has 81 elements to be processed per pixel in the image. But repeating a smaller 'Diamond' kernal 3 times has 3×9, or 27 kernel elements to process or pixel in the image. In this case it is 3 times faster.<br>
              <br>
              This is speed increase isn't much in this case but he savings are much greater as the size of the kernels increase.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Because repeating a morphological operation is very common, rather than repeating the operation multiple times, you can just ask IM to loop or iterate the operation, that many times.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif   -morphology Dilate:3 Diamond -scale 800%  k_diamond_3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_diamond_3.gif"><img src="k_diamond_3.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note the difference between this and the first example. All that has happened is that we have moved the '<code>:3</code>' from being the radius of the '<code>Diamond</code>' kernel to the number of times the '<code>Dilate</code>' method is to be used. Using an '<i>iteration</i>' to make the effective neighbourhood bigger, works for most 'circular', or 'convex' kernels, such as a '<code>Square</code>' and '<code>Diamond</code>'. But <b>it does not work for all kernel types</b>. For example for a non-convex kernel such as a '<code>Plus</code>' (which is not a 'concave' shape) will produce a very unusual results.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example, this is not that same as going from '<code>Plus</code>' (radius 2) to a double size '<code>Plus:4</code>' kernel...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif   -morphology Dilate:2 Plus  -scale 800%  k_plus_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="k_plus_2.gif"><img src="k_plus_2.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that if you use a '<i>iteration</i>' count of '<code>0</code>', the morphology will do nothing. This is an useful way to 'turn off' the operator when you don't want it to do anything, but do not want to remove it from the command line. See <a href="#showkernel">Verbose Output Display</a>, below for another use of a zero iteration count. Using a special value of '<code>-1</code>', will repeat the operation until no more changes are seen in the image. That is, the image reaches a point of 'convergence'. This is however dangerous, as in some situations could lead to very long running operations. For an operation such as for '<code>Dilate</code>' for example it would simply repeat the dilation until the whole image was completely filled with white. Basically producing a sort of runaway 'flood fill' (see the next example below). Iterating a '<code>Disk</code>' kernel to produce a larger neighbourhood effect, is also generally not recommended. That is, because the '<code>Disk</code>' kernel becomes a more accurate disk shape as the radius gets larger, where an iterated disk, will enlarge not just the shape but the errors (non-disk shape) of the kernel. As such you may be better off using a larger radius (which is slower) rather than iterating the operation (which produces a more distorted disk) . However as a '<code>Disk</code>' radius becomes really large then a combination of radius and multiple iterations, could produce a faster, but still acceptable result. Caution and some experimentation with your specific situation may be needed.<br>
          <a name="verbose" id="verbose"></a>
          <h3>Verbose Output of Changes</h3>If you want to see the results of iterating (repeating) a morphological operation, you can set the "<code><a href="../option_link.cgi?define">-define debug=True</a></code>" option, which turns on the <a href="../basics/#verbose">Verbose Operational Control</a>. As the morphology operator iterates, it will report an incrementing count of the iteration, and how many pixels in the image were changed by each iterated step. The output is to standard error, so that you can still pipe the image results.. For example lets '<code>Dilate</code>' the single pixel image using the larger '<code>Octagon</code>' kernel until the whole image has been filled with white and no more changes can be made to the image. Remember an iteration limit of '<code>-1</code>' means iterate forever, or until no more changes are seen.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="" image="iterate_infinite.gif" err="verbose_iterate.txt">
  MAGICK_THREAD_LIMIT=1 \
    magick pixel.gif -define debug=true -morphology Dilate:-1 Octagon \
            -scale 800% iterate_infinite.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td rowspan="2">
                <a href="iterate_infinite.gif"><img src="iterate_infinite.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="verbose_iterate.txt"><img src="verbose_iterate.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>Note the number of changes made in each iteration. Initially there were 20 pixels converted from black to white. Then 48 more on the next iteration, and so on. This number generally grows as the edge of the resulting shape gets larger, but then started to shrink again as shape hits the image boundary. On the fourth dialation the last 4 pixels (in the corners of the image) were filled in. On the last dilation (iteration 5) the image was already completely filled, as such no more changes to any pixel was performed. As no changes were made the morphology automatically aborts, giving a final number of changes for this stage of the operation. Using an infinite iteration of '<code>-1</code>' does have an internal limit. This is currently set to the maximum width or height of the image. This is done to prevent ImageMagick from going into a never ending loop. Typically however operations will finish long before that internal limit is reached. Some morphology methods are actually defined in terms of simpler more primitive methods. For example a '<code><a href="#smooth">Smooth</a></code>' method for example is one such compound method. The "<code><a href="../option_link.cgi?debug">-define</a></code>" output that is generated when using this method, shows the multiple internal steps that goes to make up its processing.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" err="verbose_compound.txt">
  MAGICK_THREAD_LIMIT=1 \
    magick man.gif -define debug=true -morphology Smooth:2 Diamond null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="verbose_compound.txt"><img src="verbose_compound.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>If you look you can see that the '<code><a href="#smooth">Smooth</a></code>' actually iterates, 4 more primitive methods, and thus internally processes the image 8 times to perform the requested operation. Each line consists of..
          <blockquote>
            <dl>
              <dt><code>Smooth:<i>i</i>.<i>s</i></code></dt>
              <dd>this shows the high level morphology method being applied to the image, and the iteration count '<i>i</i>' and primitive 'stage' '<i>s</i>', that IM is processing. For the '<code>Smooth</code>' method that first number is always '1', as the user-given 'iteration count' is applied in the lower level primitive method. In other methods, the user-given iteration may be applied at this higher level rather than at the lower level. The second 'stage' number is the primitive 'stage' count that is being applied. '<code>Smooth</code>' itself is composed of four such stages, as it implements the '<code><a href="#open">Open</a></code>' and '<code><a href="#close">Close</a></code>' compound methods.</dd>
              <dt><code>Dilate*:<i>i</i>.<i>k</i></code></dt>
              <dd>
                This is the primitive method being applied. The first number <i>i</i> is again the user-given iteration count (if it is being applied here). The second number '<i>k</i>' is the kernel being applied by the primitive morphology method. As there is only one kernel so it is always zero in this case. (See <a href="#multi-kernel">Multi-Kernel Handling</a> below) The '<code>*</code>' indicates that the kernel was reflected (or rotated 180 degrees around origin) before being applied by the morphological primitive. This is required for some compound morphological methods, in this case the '<code><a href="#close">Close</a></code>' method always uses a reflected kernel in its use of the '<code><a href="#dilate">Dilate</a></code>' and '<code><a href="#erode">Erode</a></code>' primitive methods.
              </dd>
              <dt><code>#6 =&gt; Changed 311 Total 637</code></dt>
              <dd>This is a report of the results of applying the morphology primitive to the image. The 'hash' number is an incremental count of the number of primitive passes though the image. This gives you a good idea of how computationally intensive a compound morphology operator is. You then get a the actual number of pixels that were changed in some way during that pass. If this is the last of a number of iterations for this specific primitive and kernel, a total count of pixel modifications is also output. This does not however reflect the total number of pixels changed in total from start to finish, just the changes caused by the low-level iteration of the specific primitive, kernel operation. Some pixels may change multiple times by some morphological primitives.</dd>
            </dl>
          </blockquote>From the above you may see that internally IM may have four loops of processing being applied to fully process an given morphology method. However typically most of these loops are only applied once only.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Warning the number of pixels that change, may not be correct on machines running a multi-threaded environment on modern multi-core machines! It is only guaranteed to be accurate when executed in a single threaded environment. I class this as a bug, but not a vital one.<br>
              <br>
              If this is a problem then ensure you set the environment variable "<code>MAGICK_THREAD_LIMIT</code>" to a value of '<code>1</code>' for that specific run of ImageMagick, as I did in the last two examples above.<br>
              <br>
              As of IM v6.8.4 you no longer need the "<code>MAGICK_THREAD_LIMIT</code>" environment setting, as the counts are correctly handled in a multi-threding environment.<br>
              <br></i></font></td>
            </tr>
          </table><a name="showkernel" id="showkernel"></a>
          <h3>Displaying the Kernel Generated <font size="-1">(for debugging purposes)</font></h3>If you like to actually see the values that was used to define a particular kernel that was generated, you can define a special setting...
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code not_an_executable="">
    -define morphology:showkernel=1    
    -define convolve:showkernel=1    
</code></pre>
                </td>
              </tr>
            </table>
          </blockquote>Any of the above defines causes IM to output (to 'standard error') all the information about a generated kernel, after the kernel has been completely processed in preparation for its use. (See <a href="../convolve/#kernel_scaling">Convolve Kernel Scaling</a>). For example, here is the actual values of the built-in '<code><a href="#disk">Disk</a></code>' kernel...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="k_disk.txt">
  magick xc: -define morphology:showkernel=1 -morphology Dilate:0 Disk null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_disk.txt"><img src="k_disk.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Note that as I only wanted to show the kernel, I really don't care about the image processing at all. As such I set the morphology '<i>iteration</i>' to '<code>0</code>' (do nothing), and also discard any image result using a <a href="../files/#null">null:</a> output file format. The special floating point value of 'nan' in the above has the same meaning as when inputting a <a href="#user">User Defined Kernel</a>. It means 'Not A Number' and marks the parts of a kernel that is not part of the neighbourhood. These values are ignored by all morphological operations. Here is another example. This time of a '<code><a href="../convolve/#comet">Comet</a></code>' convolution kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="k_comet.txt">
  magick xc: -define morphology:showkernel=1 -morphology Dilate:0 Comet:0x2  null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_comet.txt"><img src="k_comet.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>This is actually half a 1 Dimensional Gaussian Curve (sigma of 1.0), and can provide a nice way of extracting such a curve from ImageMagick. Also notice that this specific kernel's 'origin' (the pixel that it effects), is off-center (located at <code>+0+0</code>), which is not very common. The size and spacing of the values in the output can be controlled by the special <a href="../basics/#precision">Precision Operational Control</a>. That was added to IM at about the same time as the morphology operator. For example, here is a repeat of the previous example but using "<code><a href="../option_link.cgi?precision">-precision</a></code>" to limit the number of significant digits from the default of 6 to 3.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="k_precision.txt">
  magick xc: -define morphology:showkernel=1 -precision 3 \
          -morphology Dilate:0 Comet:0x2  null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_precision.txt"><img src="k_precision.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?precision">-precision</a></code>" option was added to ImageMagick version 6.5.9-1 during the morphology development cycle. As such if morphology is available, precision can also be regarded as available.</i></font></td>
            </tr>
          </table><a name="kernel2image" id="kernel2image"></a>
          <h3>Generating an Image of the Kernel</h3>To make it easier to see kernels, rather than using <a href="#dilate">Dilating</a> or <a href="../convolve/#convolve">Convolution</a> on an single pixel image to see what it produces, I created a special script called "<code><a href="../scripts/kernel2image">kernel2image</a></code>". This script extracts the exact <a href="#showkernel">Show Kernel</a> output, and converts it into an image of the kernel. The "<code><a href="../scripts/kernel2image">kernel2image</a></code>" script has lots of options, from output the raw image of the kernel (the default) to specifying the amount of scaling, inter-pixel gaps, montage, labeling, and even coloring of the resultant 'kernel image'. The script makes it a lot easier to view and understand the various kernels, and is used extensivally to generate the kernel images displayed in these example pages.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                For example, here is how I generated the "<code><a href="#octagon">Octagon</a></code>" kernel image.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  kernel2image -10.1  -m "Octagon"  kernel_octagon.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="kernel_octagon.gif"><img src="kernel_octagon.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The special option '<code>-10.1</code>' means scale all pixels to 10 pixels in size, but also include a 1 pixel gap between those pixels. If the kernel is scaled enough the 'origin' of the kernel will be marked with some drawn circles. The '<code>-m</code>' then specifies that I it to create a <a href="../montage/">Montage</a> of the image with an identification label of the extracted "<code><a href="#octagon">Octagon</a></code>" kernel, and shadow effects.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                And here I generate a 'kernel image' of the 'L' shaped user defined kernel, I used above.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  kernel2image -20.2 -ml 'L-Shape'  "3: 1,-,-  1,-,-  1,1,- " kernel_lman.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="kernel_lman.gif"><img src="kernel_lman.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>If you want to create a kernel from an existing image, a script "<code><a href="../scripts/image2kernel">image2kernel</a></code>" can be used to create a kernel data file from an image. This script normally takes a gray-scale image, but if a multi-colored image is given each channel of the image is converted as a separate kernel data file.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                Here I create the <a href="#user">User kernal data</a> from a small flag image (&nbsp;<img src="../images/flag.gif" align="bottom">&nbsp;), then use "<code><a href="../scripts/kernel2image">kernel2image</a></code>" to convert that data back into an enlarged 'kernel image' for display.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   image2kernel -qgm flag.gif  flag_kernel.dat
   kernel2image -6.1 -m  -ml "Flag"  @flag_kernel.dat  kernel_flag.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="kernel_flag.gif"><img src="kernel_flag.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>ASIDE: I could have generated the 'enlarged' version of the small image more directly with a similar script "<code><a href="../scripts/enlarge_image">enlarge_image</a></code>, but that would have been displaying the image, and not the Kernel Data, "<code><a href="flag_kernel.dat">flag_kernel.dat</a></code>". <a name="multi-kernel" id="multi-kernel"></a>
          <h3>Multiple Kernel List Handling</h3>
          <h4>Generating Multiple Kernels</h4>As of IM v6.6.2-0 you can specify multiple kernels which will be applied to the image one at a time. To specify multiple kernels you would just append each kernel definition together, separated by a semicolon '<code>;</code>'. A final semicolon at the end is optional. For example, here I define a special kernel list containing a list that can be used for 'pattern matching' corner pixels.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code not_an_executable="">
     3: 0,0,- 0,1,1 -,1,-  ;      
     3: -,0,0 1,1,1 -,1,-  ;
     3: -,1,- 1,1,0 -,0,0  ;
     3: -,1,- 0,1,1 0,0,-  ;
</code></pre>
                </td>
              </tr>
            </table>
          </div>Extra semicolons ('<code>;</code>') do not matter, as long as at least one is provided between kernel specifications. Nor does extra white space (including newlines), in any kernel specification. Here is a <a href="#showkernel">Show Kernel Output</a> of this definition.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" err="k_multi.txt">
  magick xc: -define morphology:showkernel=1 -morphology Dilate:0 \
             " 3: 0,0,- 0,1,1 -,1,-  ;
               3: -,1,- 1,1,0 -,0,0  ;
               3: -,0,0 1,1,1 -,1,-  ;
               3: -,1,- 0,1,1 0,0,-  ; " null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_multi.txt"><img src="k_multi.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>And here is a <a href="#kernel2image">Kernel Image</a> of these four kernel using the special "<code><a href="../scripts/kernel2image">kernel2image</a></code>" script.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="kernel_multi.gif">
   kernel2image -20.2 -ml '' -mt x1 \
             " 3: 0,0,- 0,1,1 -,1,-  ;
               3: -,1,- 1,1,0 -,0,0  ;
               3: -,0,0 1,1,0 -,1,-  ;
               3: -,1,- 0,1,1 0,0,-  ; "  kernel_multi.gif
</code></pre>
                </td>
              </tr>
            </table><a href="kernel_multi.gif"><img src="kernel_multi.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
          </div>Now this definition actually consists of just the one kernel which has been expanded to form a set of 4 kernels each rotated by 90 degrees. ASIDE: This definition is almost equivalent to the the special '<code><a href="#corners">Corners</a></code>' pattern matching kernel (see below). except that it limits itself to corners of the actual shape, and not just any corner, background or foreground. <a name="rotated_kernels" id="rotated_kernels"></a>
          <h4>Expanding to a Rotated Kernel List</h4>As of IM v6.2.2-0 you can ask IM to expand a single kernel into a list of rotated kernels by using one of three special flags, in either named or user-defined kernels. The three special flags are...
          <blockquote>
            <table>
              <tr valign="top">
                <td>'<b><code>@</code></b>'&nbsp;&nbsp;&nbsp;</td>
                <td>Cyclically rotate 3x3 kernels in 45-degree increments, producing a list of up to 8 rotated kernels. (mnemonic: '<code>@</code>' is circular)</td>
              </tr>
              <tr valign="top">
                <td>'<b><code>&gt;</code></b>'</td>
                <td>Rotate (square or linear kernels only) in 90-degree increments. (mnemonic: the '<code>&gt;</code>' is right angled).</td>
              </tr>
              <tr valign="top">
                <td>'<b><code>&lt;</code></b>'</td>
                <td>Also produce 90-degree rotations but in a 'mirror' sequence (rotation angles of 0, 180, -90, +90 ). This special form of rotation expansion works better for morphology methods such as '<code><a href="#thinning">Thinning</a></code>'. (mnemonic: '<code>&lt;</code>' is a mirror of a right angle).</td>
              </tr>
            </table>
          </blockquote>For example that same kernel above be specified more simply as...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code not_an_executable="">
    ' 3&gt;:  0,0,-  0,1,1  -,1,- '
</code></pre>
                </td>
              </tr>
            </table>
          </div>This defines one kernel, which the '<code>&gt;</code>' flag then tells IM to expand into a 90 degree rotated list. And here is an image of the resulting multi-kernel list
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   kernel2image -20.2 -ml '' -mt x1 \
                '3&gt;: 0,0,- 0,1,1 -,1,- '  kernel_rotated_list.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="kernel_rotated_list.gif"><img src="kernel_rotated_list.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
          </div>And here I rotate a 3x3 kernel in a 'cyclic' 45 degree rotation, expanding it to a list of 8 kernels.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   kernel2image -20.2 -ml '' -mt x1 \
                '3@: -,1,- -,0,- 1,1,1 '  kernel_rotated_list2.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="kernel_rotated_list2.gif"><img src="kernel_rotated_list2.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
          </div>You can also do the same for any 'single' built-in named kernel IM, using the same flags in the argument section of those kernels. For example, here I take a symmetrical '<code><a href="../convolve/#blur">Blur</a></code>' kernel and expand it into a 90 degree rotated list using a '<code>&gt;</code>' flag.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   kernel2image -12.1 -n -ml ''   "Blur:0x1&gt;"  blur_kernels.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="blur_kernels.gif"><img src="blur_kernels.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
          </div>Note that only 2 kernels were generated as a third kernel, would just reproduce the first kernel exactly. This is discovered and the generation of rotated kernels stops. However if the 'origin' is off centered, then the full sequence of 4 rotated kernels would have been generated as while the kernel 'shape' matches, the origin location would not be the same. Many built-in kernel definitions automatically generate a multi-kernel list, so you do not need to specify any flags for that purpose. That is, the rotation expansion is also 'built-in' to the specific kernel definition. Such kernels typically also provide 'sub-types' of the original single kernel definition, so that you can pick and choose specific kernels for specific purposes. <a name="kernel_compose" id="kernel_compose"></a>
          <h3>Multiple Kernel Result Merging: Re-iterate or Compose</h3>When you have defined multiple kernels, the morphology method also needs to know how it should merge the results generated by multiple kernels. This can be controlled by the use of a global <a href="../basics/#define">Define</a>...
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code not_an_executable="">
    -define morphology:compose={<i>compose_method</i>}    
</code></pre>
                </td>
              </tr>
            </table>
          </blockquote>The default for most morphology methods is a setting of '<code>None</code>'. This means that after each kernel has been applied using the morphology method given, the resulting image should be used as the source for next kernel. That is simply '<i>re-iterate</i>' or reuse the resulting image from applying one kernel, for the next kernel. For example, if I <a href="../convolve/#convolve">Convolve</a> using 2, 90 degree rotated '<code><a href="../convolve/#blur">Blur</a></code>' kernels we get the following. <!--<CODE EXECUTE>
   kernel2image -12.1 -n -ml '' "Blur:0x1"    blur_kernel.gif
   kernel2image -12.1 -n -ml '' "Blur:0x1+90" blur_kernel2.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif  -morphology Convolve "Blur:0x1&gt;" \
          -auto-level  blur_re-iterate.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel.gif"><img src="blur_kernel.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/comma.gif" align="middle" width="20" height="20" alt=","> <a href="blur_kernel2.gif"><img src="blur_kernel2.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_re-iterate.gif"><img src="blur_re-iterate.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see both kernels were applied to the image one after the other, so that each kernel works with the result of the previous kernel. That is, it '<i>re-iterates</i>' the result of one kernel with the next kernel, in sequence. This is equivalent to doing the two steps like this.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif -morphology Convolve "Blur:0x1" -auto-level blur_1.gif
  magick blur_1.gif -morphology Convolve "Blur:0x1+90" \
          -auto-level blur_re-iterate.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel.gif"><img src="blur_kernel.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_1.gif"><img src="blur_1_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel2.gif"><img src="blur_kernel2.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_re-iterate.gif"><img src="blur_re-iterate.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Actually this is how the <a href="../blur/#blur">Blur Operator</a> really works, to generate image blurs more quickly. See <a href="../convolve/#gaussian_vs_blur">Gaussian vs Blur Kernels</a> which demonstrates this use more throughly.<br>
          By setting the '<code>{<i>compose_method</i>}</code>' to any method other than '<code>None</code>', the operation will NOT be <i>re-iterated</i>. Instead each kernel will be applied <i>to the original image</i>, and the resulting images will be then be <a href="../compose/">Composited</a> together using the '<code>{<i>compose_method</i>}</code>' method specified. For example if I use a '<code><a href="../compose/#lighten">Lighten</a></code>' morphology method to generate a <a href="../compose/#set_theory">Union</a> of the separate results, we would get..
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code no_execute="">
  magick pixel.gif -define morphology:compose=Lighten \
                     -morphology Convolve "Blur:0x1&gt;" \
          -auto-level blur_union.gif
</code></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel.gif"><img src="blur_kernel.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/comma.gif" align="middle" width="20" height="20" alt=","> <a href="blur_kernel2.gif"><img src="blur_kernel2.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_union.gif"><img src="blur_union_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>That was equivalent to doing...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick pixel.gif -morphology Convolve "Blur:0x1"  -auto-level blur_1.gif
  magick pixel.gif -morphology Convolve "Blur:0x1+90" -auto-level blur_2.gif
  magick blur_1.gif blur_2.gif -compose Lighten -composite \
          -auto-level blur_union.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel.gif"><img src="blur_kernel.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_1.gif"><img src="blur_1_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a><br>
            <a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" alt="*"> <a href="blur_kernel2.gif"><img src="blur_kernel2.gif" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_2.gif"><img src="blur_2_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a><br>
            <a href="blur_1.gif"><img src="blur_1_mag.gif" width="88" height="88" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/union.gif" align="middle" width="20" height="20" alt="U"> <a href="blur_2.gif"><img src="blur_2_mag.gif" width="88" height="88" align="middle" vspace="HSPACE=0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="blur_union.gif"><img src="blur_union_mag.gif" width="88" height="88" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--
  magick blur_1.gif -scale 800% blur_1_mag.gif
  magick blur_2.gif -scale 800% blur_2_mag.gif
  magick blur_union.gif -scale 800% blur_union_mag.gif
-->
          If you are not sure what IM is actually doing during a morphology, turn on the <a href="#verbose">Verbose Output of Changes</a>. For example, here the verbose output of re-iterating with each kernel...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="blur_re-iterate.txt">
  magick pixel.gif -define morphology:compose=None \
         -define debug=true -morphology Convolve "Blur:0x1&gt;" null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="blur_re-iterate.txt"><img src="blur_re-iterate.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>And here is the verbose output of a <a href="../compose/#set_theory">Union</a> (<a href="../compose/#lighten">Lighten Composition</a>) of each kernel result....
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" err="blur_union.txt">
  magick pixel.gif -define morphology:compose=Lighten \
         -define debug=true -morphology Convolve "Blur:0x1&gt;" null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="blur_union.txt"><img src="blur_union.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Both of which clearly shows what ImageMagick is doing to generate the final image. The number after the decimal point represents the kernel number that is being applied, at each step. Followed at the end by how it composes the images together according to the '<code>morphology:compose</code>' setting. Many of the <a href="../compose/#math">Mathematical Composition Methods</a> and their equivelent <a href="../compose/#set_theory">Set Theory</a> type operations, can also be used to merge the results of applying each kernel to the original image. In summery this setting defines how the individual kernels of a multi-kernel list will be applied to the given image. The default is the compose value of '<code>None</code>' meaning to simply 're-iterate' results, otherwise it will merge all the results based on the compose method given.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="basic" id="basic"></a>
          <h2>Basic Morphology Methods</h2>Morphological Methods is an image processing technique for the finding, and analysis of shapes of objects withing an image. Expanding, shrinking, locating specific shapes, and so on. It was original developed with binary (pure black and white) images in mind, and because of this it most commonly applied to <a href="../quantize/#threshold">Thresholded</a> images containing simple black and white shapes. By convention white in a binary image represents foreground, while black represents background. The method names are thus described according to this convention. That is, not to say the operators will not work with gray-scale image, or in some cases color images, but their original purpose was to handle binary shapes. The basic <a href="#man_kernels">Shape Kernels</a> already looked at above, are the most commonly used neighbourhood defining 'shapes', for morphological methods. Such kernels are often called 'Structure Elements' as they are typically used to determine the structure of the shapes within the image. <a name="erode" id="erode"></a>
          <h3>Erode &nbsp; <font size="5">( <img src="../img_www/mph_erode.gif" align="absmiddle"> )</font></h3>As the name implies the '<code><b>Erode</b></code>' method 'eats away' the white shape, from any background pixel making it smaller. You can also think of it as expanding the black areas of the image. For example, here is a simple binary 'man-like' shape that has been eroded using a '<code><a href="#octagon">Octagon</a></code>' kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Erode Octagon  erode_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_erode.gif" align="middle" width="20" height="30" alt="-"> <a href="kernel_octagon.gif"><img src="kernel_octagon.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="erode_man.gif"><img src="erode_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Its basic effects is to make any protuberances or points the image may have thinner, or remove them completely, but it also makes any holes that is present (such as caused by this images 'arm') in an image larger. In general the size of kernel, determines how many pixels are removed. <a name="dilate" id="dilate"></a>
          <h3>Dilate &nbsp; <font size="5">( <img src="../img_www/mph_dilate.gif" align="absmiddle"> )</font></h3>The '<code><b>Dilate</b></code>' method is the dual of '<code>Erode</code>'. It expands the white shapes, making a shape bigger according to the kernel (and the number of iterations) specified. Of course that also means it will 'erode' the black areas of the image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Dilate Octagon  dilate_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_dilate.gif" align="middle" width="20" height="30" alt="+"> <a href="kernel_octagon.gif"><img src="kernel_octagon.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="dilate_man.gif"><img src="dilate_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Notice how the shape not only becomes larger, but its outlined becomes smoother. The large indent between the 'legs' has been filled in, as was the small single pixel 'hole' the image contained. The size and shape of the kernel determines how many pixels were are added around the edges of the image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The '<code>Dilate</code>' and '<code>Erode</code>' are dual. That is, (at least with a symmetrical kernel) by negating the image before and after the applying the morphological method, you will actually perform the other form of the operator. For example, here I perform an erosion by using '<code>Dilate</code>' on the <a href="../color_mods/#negate">Negated Images</a>.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -negate \
             -morphology Dilate Octagon   -negate dilate_man_neg.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dilate_man_neg.gif"><img src="dilate_man_neg.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="open" id="open"></a>
          <h3>Open &nbsp; <font size="5">( <img src="../img_www/mph_open.gif" align="absmiddle"> )</font></h3>Here is the effect of the '<code><b>Open</b></code>' method, but this time using much larger '<code><a href="#disk">Disk</a></code>' kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Open Disk  open_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_open.gif" align="middle" width="20" height="30" alt="o"> <a href="kernel_disk.gif"><img src="kernel_disk.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_man.gif"><img src="open_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As a result you will see that '<code>Open</code>' smoothed the outline, by rounding off any sharp points, and remove any parts that is smaller than the shape used. It will also disconnect or 'open' any thin bridges. However it does not remove any 'holes', or gaps that may be present in the image. such as between the shapes 'legs'. Also it does not make the basic 'core' size of the shape larger or smaller. In actual real terms, what it does is to '<code><a href="#erode">Erode</a></code>' an image then '<code><a href="#dilate">Dilate</a></code>' it again using the same kernel that was provided
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif         -morphology Erode  Disk  open_erode.gif
  magick open_erode.gif  -morphology Dilate Disk  open_man_2.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_erode.gif"><img src="open_erode.gif" align="middle" vspace="2" hspace="10" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_man_2.gif"><img src="open_man_2.gif" width="100" height="125" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a>
          </div>Note that performing a '<code>Open</code>' on a shape that has already been opened, with the same kernel will result in no further change to the shape. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick open_man.gif  -morphology Open Disk  open_man_twice.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_man.gif"><img src="open_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_man_twice.gif"><img src="open_man_twice.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>That is, repeating a '<code>Open</code>' operation, with the same kernel, has no effect on the result.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Because of this, any <i>iteration</i> count provided will be applied to the individual dilate and erode sub-methods, and not to the method as a whole, so that the iteration can be used to 'expand' the effective kernel, rather than uselessly repeating the compound operation. That is, a '<i>Open:2</i>' iteration will actually be applied as a '<code>Erode:2</code>, followed by an '<code>Dilate:2</code>' to the image. This has the general effect of making the effective 'neighbourhood' defined by the kernel larger.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Open:2  Disk  open_man_x2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="open_man_x2.gif"><img src="open_man_x2.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Here you can see that the resulting larger neighbourhood resulted in both the man's 'head' and 'feet' extremities being removed. The main body of the shape basically intact, though also smoother in appearance, while the leg gap remains untouched. This is the same effect as doubling the size of the kernel, though its exact shape may not be exactly the same as a kernel of double the radius. <a name="close" id="close"></a>
          <h3>Close &nbsp; <font size="5">( <img src="../img_www/mph_close.gif" align="absmiddle"> )</font></h3>The basic use of the '<code><b>Close</b></code>' method is to reduce or remove any 'holes' or 'gaps' about the size of the kernel 'Structure Element'. That is 'close' parts of the background that are about that size.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif    -morphology Close Disk   close_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_close.gif" align="middle" width="20" height="30" alt="."> <a href="kernel_disk.gif"><img src="kernel_disk.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="close_man.gif"><img src="close_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>The basic effect of this operator is to smooth the outline of the shape, by filling in (closing) any holes, and indentations. It also will form connecting 'bridges' to other shapes that are close enough for the kernel to touch both simultaneously. But it does not make the basic 'core' size of the shape larger or smaller. In actual real terms, what it does is to '<code><a href="#dilate">Dilate</a></code>' the image then '<code><a href="#erode">Erode</a></code>' it again using the same kernel that was provided, causing the image to become first larger, then smaller. This is the opposite order of what '<code><a href="#open">Open</a></code>' does.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif           -morphology Dilate Disk  close_dilate.gif
  magick close_dilate.gif  -morphology Erode  Disk  close_man_2.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="close_dilate.gif"><img src="close_dilate.gif" align="middle" vspace="2" hspace="10" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="close_man_2.gif"><img src="close_man_2.gif" width="100" height="125" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a>
          </div>The results is that the external points of the image will be left as is, but any 'bays' smoothed and thickened, and 'holes' and 'gaps' closed. Disconnected objects that are very close together can be come linked together. as with '<code><a href="#open">Open</a></code>', repeating the '<code><a href="#close">Close</a></code>' method with the same kernel does not make any further changes to the image. Using an '<i>iteration</i>' with the operator will however repeat the internal sub-methods, so as to produce a stronger rounding effect, similar to using a larger kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                And just as with the '<code><a href="#dilate">Dilate</a></code>' and '<code><a href="#erode">Erode</a></code>' methods, the '<code><a href="#open">Open</a></code>' and '<code><a href="#close">Close</a></code>' methods are duals. You can reproduce the effect of the other 'dual' by <a href="../color_mods/#negate">Negating</a> the image before and after the operation.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -negate -morphology Close Disk -negate   close_man_neg.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="close_man_neg.gif"><img src="close_man_neg.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="smooth" id="smooth"></a>
          <h3>Smooth</h3>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                The '<code><b>Smooth</b></code>' method applies a '<code><a href="#open">Open</a></code>' followed by a '<code><a href="#close">Close</a></code>' of the shape, which first removes any 'small objects' then fills in and 'holes' or 'gaps' about the size of the kernel 'Structure Element'. Here we smooth the image using a mid-range '<code><a href="#octagon">Octagon:3</a></code>' kernel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif  -morphology Smooth  Octagon:3  smooth_man.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="smooth_man.gif"><img src="smooth_man.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see all the 'indents', 'gaps', 'holes', and 'points' have been smoothed and rounded off according to the size and shape of the kernel. The '<code><a href="#smooth">Smooth</a></code>' operator is also often repeated with slowly increasing sized Structure Elements, so as to slowly remove noise from images. If the parts removed are preserved, you get a morphological 'decomposition' of the image which can be used for further study. See <a href="#granularity">Granularity</a> below. The method is particularly good for cleaning up scanned documents. Note that this is actually applying 4 separate 'primitive' operations to the original image. It is thus 4 times slower than just a simple '<code><a href="#erode">Erode</a></code>' or '<code><a href="#dilate">Dilate</a></code>'. <a name="greyscale_flat" id="greyscale_flat"></a>
          <h3>Flat Grey-scale Morphology</h3>While essentially all four of the Basic Morphological Methods, and later ones which are defined in terms of these four methods, are specifically designed to work with binary images, they can be applied to both grey-scale and color images (though color images may generate some odd color effects). <i>Practical Example of Grey-scale Operation Wanted Here</i>However the kernel itself will always be regarded as a simple 'on' or 'off' neighbourhood. Any kernel value that is either a 'nan' or less than '<code>0.5</code>' will be regards as outside the 'neighbourhood' that it defines. In summery, the above operators apply a 'flat' kernel without any 'height' or '3-dimensional' features, but can still be applied to gray-scale images. <a name="greyscale" id="greyscale"></a>
          <h3>True Gray-scale or 3-dimensional Morphology</h3>True gray-scale or 3-dimensional morphology (as one library put it) will actually add or subtract the values found in the kernel from the neighbouring pixels in the image, before looking for the maximum/minimum values as the result. What this means is that it treats a gray-scale image as a 'height field' of a 3-dimensional morphology object and the gray-scale shape of the kernel the smoothing shape to adjust that height field. While the implementation details of true gray-scale morphology is well documented, is usage in practical situations is not. That is, I have not found any useful example of using true grey-scale morphology beyond 'flat shaped kernels', other than a comment about its use in 'photometric' processing. Because of this I have not implemented true 3-dimensional grey-scale morphology. However if people really do need such non-flat grey-scale morphological operators, please let me know, and I will implement the appropriate operators. Note the special '<code><a href="#distance">Distance</a></code>' method (see below) is actually similar to how true gray-scale morphology works, in that it adds the kernel's value to each pixel value, before taking the smallest 'minimum' value. However this method does not match either 3D erode (subtract and take minimum) or dilate (add and take maximum) morphology definitions. It is however very closely related, and probably could be implemented using those methods. <a name="intensity" id="intensity"></a>
          <h3>Intensity Variant for Color Images</h3>As the above four methods, are grey-scale <a href="#channel">Channel</a> methods, using them on color images can generate off color effects where one channel is modified, but another isn't. They are really not designed for use with multi-channel color images, only with grey-scale and binary images. The result is that for color images, the colors become distorted, becoming a brighter or darker shade depending on the operation. With this in mind I have created 'Intensity' versions of these methods. '<code>ErodeIntensity</code>', '<code>DilateIntensity</code>', '<code>OpenIntensity</code>', '<code>CloseIntensity</code>'. These compare the pixels within the defined 'neighbourhood', and replaces the current pixel color according to the pixels intensity. That is, the whole color pixel is copied, and not just the individual channel values. As a result...
          <div align="center">
            <b>Intensity Variants do not generate any 'new' colors in images.</b>
          </div>Because of their nature the <a href="#intensity">Intensity Methods</a> will ignore the current "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting completely. For example, here I use the binary and intensity variants of '<code><a href="#dilate">Dilate</a></code>' Morphology (expand bright areas), on the built-in "<code>rose:</code>" image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -morphology Dilate          Octagon:3  rose_dilate.gif
  magick rose: -morphology DilateIntensity Octagon:3  rose_dilate_intensity.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/rose.gif"><img src="../images/rose.gif" width="70" height="46" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="rose_dilate.gif"><img src="rose_dilate.gif" width="70" height="46" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a> <a href="rose_dilate_intensity.gif"><img src="rose_dilate_intensity.gif" width="70" height="46" align="middle" vspace="2" hspace="10" border="1" alt="[IM Output]"></a>
          </div>As you can see the normal '<code><a href="#dilate">Dilate</a></code>' method can generate different shades in each of the large dilated spots, as each channel is separately handled. The second intensity dilation however preserves the full color of the brightest spots, expanding them according to the boolean kernel shape. The intensity methods also has a short hand naming scheme, by replacing the word '<code>Intensity</code>' with just a '<code>I</code>'. As such here I use a '<code>CloseIntensity</code>' method but use the short hand name of '<code>CloseI</code>'. For example, here are the results of using each of the four 'Intensity' variants on the built-in rose image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -morphology ErodeI Octagon:3 rose_erode_intensity.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rose_erode_intensity.gif"><img src="rose_erode_intensity.gif" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
<br>  magick rose: -morphology DilateI Octagon:3 rose_dilate_intensity.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rose_dilate_intensity.gif"><img src="rose_dilate_intensity.gif" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -morphology OpenI Octagon:3 rose_open_intensity.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rose_open_intensity.gif"><img src="rose_open_intensity.gif" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -morphology CloseI Octagon:3 rose_close_intensity.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rose_close_intensity.gif"><img src="rose_close_intensity.gif" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The last two may be particularly suitable as a replacement operator for the <a href="../transform/#paint">Paint Operator</a>. <i>These methods are classed as experimental</i>, and comments or problems with its use is welcome. If I do not hear comments, nothing more will be added! <a name="alturnative" id="alturnative"></a>
          <h2>Alternative Basic Morphology Techniques</h2>
          <pre>

For people with versions of IM older than v6.5.9-0 you can still implement
some basic morphology methods.

You can generate a kernel that is all ones. For example a 7x7 array of 1's
(radius=3), by use an extremely large sigma and specify the appropriate radius,
using a Gaussian blur.

As such
    -convolve 1,1,1,1,1,.....
for a total of 49 ones is equivalent to
    -gaussian-blur 3x65535

This allows you to generate a simple square kernel for binary morphological
methods.

'Dilate'   for a 3x3 square kernel (radius=1) is thus
    -gaussian-blur 1x65535 -threshold 0
'Erode'  is thus
    -gaussian-blur 1x65535 -threshold 99.999%

As previously shown above
'Open' is a 'Dilate' followed by a 'Erode'
'Close' is a 'Erode' followed by a 'Dilate'
and Smooth is a 'Open' followed by a 'Close'

Larger square kernels can be specified using larger radii.

Unfortunately the other built-in kernel shapes are not available,
without using the convolve operator to manually define their shape.

This also only truly works for binary morphology. To implement a
flat-greyscale morphology, you will need to use a different technique of
generating a separate image for each pixel in the kernel, and rolling
it for the pixels position.

Both the thresholded-convolve and roll-shift composition methods have been
implemented in Fred Weinhaus's script "morphology", which was created long
before the "-morphology" operator was added to ImageMagick.

See and Download Fred's Weinhaus "Morphology" Script from
  http://www.fmwconcepts.com/imagemagick/morphology/index.php
</pre>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="difference" id="difference"></a> <a name="subtractive" id="subtractive"></a>
          <h2>Difference Morphology Methods</h2>The next level of morphological methods is something I term difference morphology. That is, the results of these morphology methods is the difference between one of the previous basic morphology methods, and the original image, or some other morphological method. Essentially they return the changes that was made to the original image by one of the simpler methods, giving you the outlines, the additions or subtractions between the images. They are essentially a '<code><a href="../compose/#difference">Difference</a></code>' or '<code><a href="../compose/#minus">Minus</a></code>' image compositions of the image results. <a name="edgein" id="edgein"></a>
          <h3>EdgeIn</h3>The '<code><b>EdgeIn</b></code> method, also called a '<i>Internal Gradient</i>', find the pixels that an the <a href="#erode">Erosion</a> removes from the original. As a result the pixels that are closest to the edge, but which were part of the original shape is returned.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology EdgeIn Octagon  edgein_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="erode_man.gif"><img src="erode_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="edgein_man.gif"><img src="edgein_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>The resulting edge is about half the size of the kernel given, which for a '<code><a href="#octagon">Octagon</a></code>' kernel is rather thick. More typically the you would use a much smaller '<code><a href="#diamond">Diamond</a></code>' or '<code><a href="#square">Square</a></code>' kernel, to produce a single pixel pixel outline of the shape. An example of using '<code><a href="#edgein">EdgeIn</a></code>' with the alpha channel, to extract edge pixels is shown in <a href="../canvas/#sparse_fill">Sparse Color as a Fill Operator</a>. <a name="edgeout" id="edgeout"></a>
          <h3>EdgeOut</h3>The '<code><b>EdgeOut</b></code>' method, also called '<i>External Gradient</i>', finds the pixels that was added to the original image by a <a href="#dilate">Dilation</a> of that image. As a result the background pixels immediately next to the shape is returned.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology EdgeOut Octagon  edgeout_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="dilate_man.gif"><img src="dilate_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="edgeout_man.gif"><img src="edgeout_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>An example of using '<code><a href="#edgeout">EdgeOut</a></code>' with the alpha channel, is shown in <a href="../masking/#outline">Outline or Halo Transparency</a>. <a name="edge" id="edge"></a>
          <h3>Edge or Morphological Gradient</h3>The '<code><b>Edge</b></code>' method returns a '<i>Morphological Gradient</i>', which can be described as either the addition of the last two 'edge' methods, or more specifically the difference between the <a href="#erode">Eroded</a> shape from its <a href="#dilate">Dilated</a> shape.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Edge Octagon  edge_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="dilate_man.gif"><img src="dilate_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/minus.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="erode_man.gif"><img src="erode_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="edge_man.gif"><img src="edge_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As before the size and shape of the kernel defines the thickness of the eroded image. Its thickness is essentially equivalent to that kernel size, minus the center pixel. As such a kernel of radius 3 will generally produce a '<code>Edge</code>' which 6 pixels thick (kernel size is 7 pixels thick)
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                Here for example is the '<code>Edge</code>' outline of the shape using the minimal '<code><a href="#diamond">Diamond</a></code>' kernel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="">
  magick man.gif  -morphology Edge Diamond  man_outline.gif
</code></pre>
                    </td>
                  </tr>
                </table>The edge is two pixels thick as it contains the pixels that lie on either side of the actual 'pixel edge' of the original shape. The only way to make this edge thinner is actually to offset the whole image diagonally by half-a-pixel.
              </td>
              <td>
                <a href="man_outline.gif"><img src="man_outline.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
          </table>For more details of getting outlines of shapes in various ways see the section on <a href="../transform/#edge">Edge Detection</a>. <i>Future: generating the edge using a 'diagonal line'.</i> <a name="top-hat" id="top-hat"></a>
          <h3>Top-Hat</h3>The '<code><b>TopHat</b></code>' method, or more specifically '<i>White Top Hat</i>', returns the pixels that were removed by a <a href="#open">Opening</a> of the shape, that is the pixels that were removed to round off the points, and the connecting bridged between shapes.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology TopHat Disk  tophat_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="open_man.gif"><img src="open_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="tophat_man.gif"><img src="tophat_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see the pixels often form small highly disjoint islands, with no set of pixels any thicker that the kernel used. The methods name '<i>Top Hat</i>' actually refers to the operators use when applied using the method for gray-scale 3-dimensional morphology, and not with binary images as we have done here. This operator is more commonly used with greyscale images. <i>FUTURE: Example of greyscale top-hat</i> <a name="bottom-hat" id="bottom-hat"></a>
          <h3>Bottom-Hat</h3>The '<code><b>BottomHat</b></code>' method, also known as '<i>Black TopHat</i>' is the pixels that a <a href="#close">Closing</a> of the shape adds to the image. That is, the the pixels that were used to fill in the 'holes', 'gaps', and 'bridges'.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology BottomHat Disk  bottomhat_man.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="close_man.gif"><img src="close_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="bottomhat_man.gif"><img src="bottomhat_man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Again you can see that it also results in highly disjoint 'islands' of pixels, none of which is thicker that the kernel used. However they are always a completely different set of islands to the previous method. <i>FUTURE: Example of greyscale bottom-hat</i>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="using" id="using"></a>
          <h2>Using Low Level Morphology Methods</h2><a name="channel" id="channel"></a>
          <h3>Basic Morphology and Channels</h3>All the above basic morphology methods are channel methods, as such they are applied to the individual channels of an image according to the current "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting. This means you can apply these methods to color images, provided you are not too fussy about 'color leakage' from undefined transparent areas. For example lets '<code><a href="#erode">Erode</a></code>' the alpha channel of the original 'man figure' image, without modifying the color channels. <!--<CODE EXECUTE>
  kernel2image -10.1 -m "Diamond:3"   kernel_diamond_3.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick figure.gif -channel A  -morphology Erode Diamond:3 \
          +channel   figure_erode.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/figure.gif"><img src="../images/figure.gif" width="100" height="125" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/mph_erode.gif" align="middle" width="20" height="30" alt="-"> <a href="kernel_diamond_3.gif"><img src="kernel_diamond_3.gif" align="middle" vspace="2" hspace="15" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="figure_erode.gif"><img src="figure_erode.gif" width="100" height="125" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
          </div>As you can see it works fine. For other examples see <a href="../canvas/#sparse_fill">Sparse Color as a Fill Operator</a>, using the '<code><a href="#edgein">EdgeIn</a></code>' method to find the edge pixels of an image. Also <a href="../masking/#outline">Outline or Halo Transparency</a> using '<code><a href="#edgeout">EdgeOut</a></code>' to expand the edges of an image with a specific color. <a name="searching" id="searching"></a>
          <h3>Search for Specific Shapes</h3>
          <pre>
Knowledge about an object depends on the manner in which we probe (observe)
it.                    -- Georges Matheron, The Father of Morphology

Using Erode to locate specific shapes from a large correction of shapes. Taken
to extreme this creates <a href="#skeletons">Skeletons</a>, see also <a href="#thinning_skeleton">Thinning Skeletons</a>.

Restoring objects using Open (smoothed result) or <a href="#dilate_conditional">Conditional Dilation</a>.

Needs some sort of Connected Component Analysis, (Segmentation) to properly
count objects found within an image.

</pre><a name="granularity" id="granularity"></a>
          <h3>Granularity of a collection of Shapes</h3>By using a series of '<code><a href="#open">Open</a></code>' operations in an image of slowly increasing size structuring elements, and measuring the resulting area, you can quickly get a summery of number of such shapes that can be found in the image. By taking the derivative (slope) of that result you get a 'spectrum' of the number and size those shapes that form the image. This graph is the '<b>granularity</b>' of the image for some particular shape. See <a href="http://en.wikipedia.org/wiki/Granulometry_%28morphology%29">Granulometry (morphology), Wikipedia</a>. The differences from one size to the next will also let you separate and count specific elements based on size, and in turn separate areas containing different sized and shaped elements. The result is a method of texture segmentation. <i>Demonstration of determining the number and size a collection of shapes. However this requires a 'counting' method (to be added) to implement fully.</i> <b>Historical note...</b>This usage was in fact the original driving force behind the original creation of morphology methods, at a Paris mining company, in the 1960's. It allowed the creators to create an automated system to analyze the grain structure of microscopic photos of mineral samples to determine their suitability for mining. That is, locate and count the size and amount of mineral in samples. For example: Two mineral ores may have the same amount of desired mineral (usually as grains or crystals in the rock), but only the ore with larger grains could be effectively mined as it allowed you to more easily separate the large pure mineral from the surrounding ore bearing rock. This was a very labour intensive task, which morphology made a lot easier. <a name="asymmetric" id="asymmetric"></a>
          <h3>Asymmetric Kernel Effects <font size="-1">(Basic Method Tests)</font></h3>Lets have a look at how these basic method work when used with a kernel which is not symmetrical. For example, here I apply an user defined 'L' shape against a special morphological test image (enlarged for viewing individual pixels).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" script="">
  for method in  erode dilate open close; do
    magick test_morphology.gif \
             -morphology $method  '2x3+1+1: 1,-  1,-  1,1 '  test_$method.gif
  done
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="test_mag.gif"><img src="test_mag.gif" width="156" height="102" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE SCRIPT>
 for method in  '' _erode _dilate _open _close; do
   magick test$method.gif -scale 156x102 test${method}_mag.gif
 done
</CODE> -->
          Which has the following results...
          <p><a href="test_erode.gif"><img src="test_erode_mag.gif" width="156" height="102" align="right" vspace="0" hspace="5" border="1" alt="[IM Text]"></a> <b>'<code><a href="#erode">Erode</a></code>'</b> results in any exact match of the kernel shape, becoming a single white pixel at the matching point 'origin'. It will also expand any single pixel 'hole' into that same shape but 'reflected' around the 'origin', that is as if the kernel had been rotated 180 degrees.<br clear="all"></p><a href="test_dilate.gif"><img src="test_dilate_mag.gif" width="156" height="102" align="right" vspace="0" hspace="5" border="1" alt="[IM Text]"></a> <b>'<code><a href="#dilate">Dilate</a></code>'</b> As expected produces that same results but for a 'negative' and 'reflected' form of either the image or the kernel. A single white pixel expands to the kernel shape, while any matching 'reflected' shaped hole, shrinks down to a single pixel 'hole'.<br clear="all">
          Note also that the boundary between positive and negative halves of the test image does move as consequence of applying the above basic morphological methods. That is, to be expected. This brings up a specific point about these two methods. To convert a '<code><a href="#erode">Erode</a></code>' methods into a '<code><a href="#dilate">Dilate</a></code>' or visa-versa, you not only need to <a href="../color_mods/#negate">Negate</a> the images before and after, but you also need to rotate or reflect the kernel about the origin. Normally this second aspect can be ignored, as most kernels are 'symmetrical'. It only becomes important with user defined asymmetrical kernels. <a href="test_open.gif"><img src="test_open_mag.gif" width="156" height="102" align="right" vspace="0" hspace="5" border="1" alt="[IM Text]"></a> <b>'<code><a href="#open">Open</a></code>'</b> as mentioned before, generally does not remove any 'holes' in the image, however an exactly matching shape will remain unchanged. Larger shapes (such as the negative half of the test image, may also remain, but perhaps slightly modified.<br clear="all">
          <a href="test_close.gif"><img src="test_close_mag.gif" width="156" height="102" align="right" vspace="0" hspace="5" border="1" alt="[IM Text]"></a> <b>'<code><a href="#close">Close</a></code>'</b> is an exact negative result of the previous, but is defined such that it does not need the kernel to be reflected (as it is reflected by its internal definition), only the image negated.<br clear="all">
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="hmt" id="hmt"></a> <a name="hitmiss" id="hitmiss"></a> <a name="hitandmiss" id="hitandmiss"></a>
          <h2>Hit And Miss (HMT) Pattern Matching</h2>
          <h3>Hit-And-Miss &nbsp; <font size="5">( <img src="../img_www/mph_hitmiss.gif" align="absmiddle"> )</font></h3>The '<code>Hit-And-Miss</code>' morphology method, also commonly known as "<i>HMT</i>" in computer science literature, is a high level morphology method that is specifically designed to find and locate specific patterns in images. It does this by looking for a specific configuration of 'foreground' and 'background' pixels around the 'origin'.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As of IM v6.6.9-4, you can use any of the method names '<code>HitAndMiss</code>', '<code>Hit_N_Miss</code>' or just '<code>HMT</code>', and the variants, to specify this morphology method. Before this version only the '<code>HitAndMiss</code>' method name could be used.</i></font></td>
            </tr>
          </table>For example we could look for a 'foreground' pixel, which has a 'background' pixel immediately to its right. <!--<CODE EXECUTE>
  kernel2image -30.2 -m "2x1:1,0"    kernel_right.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Hit-and-Miss '2x1:1,0'  hmt_right.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_hitmiss.gif" align="middle" width="20" height="30" alt="o"> <a href="kernel_right.gif"><img src="kernel_right.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_right.gif"><img src="hmt_right.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see the small 2 element kernel only matched the pixels, that were on the right side of the image. That is, the method only returned a specific pixel which matched the given pattern. The 'Kernel' or 'Structuring Element' used can contain a pattern of 3 types of elements only: a value of '<code>1</code>' meaning 'foreground', a value of '<code>0</code>' meaning 'background', and also a third element which can be specified as either '<code>Nan</code>', or '<code>-</code>' or a value of '<code>0.5</code>' which means 'I Don't Care' or 'Any Pixel' What value you use for the 'origin' is very important as it will define whether you only want to 'hit' the foreground shape, or the background pattern. But if you specifically set the 'origin' value to a value of 'I Don't Care', then you can match either foreground and background pixels who has the correct surrounding neighbourhood. For example if I use a structured element like... <!--<CODE EXECUTE>
  kernel2image -30.2 -m "3x1:1,-,0"    kernel_right2.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Hit-and-Miss '3x1:1,-,0'  hmt_right2.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_hitmiss.gif" align="middle" width="20" height="30" alt="o"> <a href="kernel_right2.gif"><img src="kernel_right2.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_right2.gif"><img src="hmt_right2.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>You get any right edge pixels which are either inside or outside. As such you are now marking both sides of the shape boundary, and extracting a 2 pixel wide edge. However not all pixels match the patten, so not ever pixel is doubled, but in general that is what you get. The use of a 'I Don't Care' value for the 'origin' is actually very common, especially when we later look at <a href="#thicken">Thicken</a> and <a href="#thinning">Thinning</a> methods, which restrict themselves to either adding or removing pixels. By 'Not Caring' the same kernel definition could be used for either operation, as the operation itself defines what type of 'hits' you are interest in.<br>
          Here is another example, but this time I again limit my 'hits' to pixels that fall inside the shape but which form a North-West facing corner. <!--<CODE EXECUTE>
  kernel2image -30.2 -m "3:0,0,- 0,1,1 -,1,-"    kernel_nw_corner.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology HMT "3:0,0,- 0,1,1 -,1,-" hmt_nw_corner.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_hitmiss.gif" align="middle" width="20" height="30" alt="o"> <a href="kernel_nw_corner.gif"><img src="kernel_nw_corner.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_nw_corner.gif"><img src="hmt_nw_corner.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>By expanding this single corner to a set of 90 degree Rotated Corners by adding a '<code>&gt;</code>' flag, we can find all corners that appear within the shape. <!--<CODE EXECUTE>
  kernel2image -20.2 -ml '' -mt x1 "3>:0,0,- 0,1,1 -,1,-" \
       kernel_hmt_corners.gif
</CODE>-->
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="center">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif  -morphology HMT "3&gt;:0,0,- 0,1,1 -,1,-" hmt_corners.gif
</samp></pre>
                    </td>
                  </tr>
                </table><a href="kernel_hmt_corners.gif"><img src="kernel_hmt_corners.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
              <td>
                <a href="hmt_corners.gif"><img src="hmt_corners.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the '<code><a href="#hmt">Hit-And-Miss</a></code>' method locates and returns ALL the pixel positions which match any of the kernel patterns provided.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>If you were to examine the <a href="#verbose">Verbose Output</a> of the "<code><a href="../option_link.cgi?morphology">-morphology</a></code>" operation above, you will find that the '<code><a href="#hmt">Hit-And-Miss</a></code>' uses a '<code><a href="../compose/#set_theory">Lighten</a></code>' composition method to create a 'union' of all the pixels that match each of the pattern kernels provided.<br>
              <br>
              Unfortunately the 'changed' pixel count is of all the pixels which are turned off by each kernel application. In other words the number of pixels in the shape, minus the number of pixels that were matched by each kernel.<br>
              <br></i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>By the same token, repeating a the <a href="#hitmiss">Hit-And-Miss Method</a> with the results of itself is usually useless as the image would have change so much you will probably end up with no matches afterward.<br>
              <br>
              You can, and as you see, use the results to modify the original image so as to generate a slightly different image.</i></font></td>
            </tr>
          </table>You can use a set of kernels that are more selective of what you are specifically interested in. For example suppose you are interested in the points where three lines meet. Then you can use the '<code><a href="#linejunctions">LineJunctions</a></code>' kernel set, which is designed specifically for this purpose.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick lines.gif -morphology HMT LineJunctions hmt_junctions.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="lines.gif"><img src="lines.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_junctions.gif"><img src="hmt_junctions.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see only a sprinkling of locations match any of the kernels in that set. However the results can make it very difficult to actually see where the matching locations were in the original image. This is especially bad if you are dealing with a grey-scale image. One solution is to expand the matches using '<code><a href="#dilate">Dilate</a></code>' with some <a href="man_kernels">Shape Kernel</a>, such as a '<code><a href="#ring">Ring</a></code>'. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="center">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick lines.gif \( +clone \
             -morphology HMT LineJunctions \
             -morphology Dilate Ring \
             -background red -alpha shape \
          \) -composite              hmt_junctions_rings.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="hmt_junctions_rings.gif"><img src="hmt_junctions_rings.gif" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can now clearly see locations where this particular set of kernels found Junctions of 3 or more lines. Each of the kernels in '<code><a href="#linejunctions">LineJunctions</a></code>' may only match a couple of specific locations, as such pattern matching in this way can be slow. Still it is very precise and works very well. Another similar '<code><a href="#hitmiss">Hit-And-Miss</a></code>' kernel set is the '<code><a href="#lineend">LineEnds</a></code>' kernel which can be used to find the free ends of all the lines in the image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="center">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick lines.gif \( +clone \
             -morphology HMT LineEnds \
             -morphology Dilate Ring \
             -background red -alpha shape \
          \) -composite                  hmt_lineends_rings.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="hmt_lineends_rings.gif"><img src="hmt_lineends_rings.gif" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><i>HitandMiss - with foreground pixels only -&gt; erode</i><i>HitandMiss - with background only -&gt; negated dilate</i><a name="hitmiss_greyscale" id="hitmiss_greyscale"></a>
          <h4>Hit And Miss with Gray-scale Images</h4>When the '<code><a href="#hitmiss">Hit-And-Miss</a></code>' method is applied to a gray-scale image, that actual value returned will be the difference between the minimum 'foreground' value and the maximum 'background' value. If a negative result occurs (no math) the result is 'clipped to zero' as negatives have no real meaning. In other words it returned the '<i>minimum separation</i>' of values between the two sets of pixels. For Boolean shapes, that will be either '<code>0.0</code>' (black) or '<code>1.0</code>' (white). But for gray-scale images this is equivalent to the 'gradient' of the matching pixels. It can for example be used to identify just how much contrast is present between a particular foreground and background in the matching pattern. If you really only want a Boolean (on/off) result of what pixels actually match the pattern in a grey-scale image, you should add a "<code><a href="../option_link.cgi?threshold">-threshold</a> 0</code>" option after the command. <a name="thicken" id="thicken"></a>
          <h3>Thicken <!--&nbsp <FONT SIZE=5>(
<IMG SRC="../img_www/mph_thicken.gif" ALIGN=absmiddle>
)</FONT> &nbsp; -->
          <font size="3">(Adding Pixels to a Shape)</font></h3>The '<code>Thicken</code>' method will add pixels to the original shape at every matching location. For example, here I look for a background pixel that is two pixels away from the right edge of the shape. <!--<CODE EXECUTE>
  kernel2image -30.2 -m "3x1+2+0:1,0,0"    kernel_right_out.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Thicken '3x1+2+0:1,0,0'  thick_right.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_hitmiss.gif" align="middle" width="20" height="30" alt="o"> <a href="kernel_right_out.gif"><img src="kernel_right_out.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="thick_right.gif"><img src="thick_right.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                As you can see you ended up with a line of pixels just outside the shapes original boundary. You can <a href="#iteration">Iterate</a> this '<code>Thicken</code>' method a few times to continue the sequence.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Thicken:4 '3x1+2+0:1,0,0'  thick_right2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="thick_right2.gif"><img src="thick_right2.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However as pixels are being added, the origin of the pattern matching kernel should NOT match foreground pixel, or you will essentially be adding a pixel, where a pixel is already present. In the above set the origin pixel to a background pattern, so only background patterns will actually match. An alternative is to always set the origin to a 'Do Not Care' element value. By doing this you will be able to use the same kernel pattern for thicken '<code><a href="#thicken">Thicken</a></code>', and as you will see later for '<code><a href="#thinning">Thinning</a></code>' as well. So the better rule is set origin to 'Do Not Care'.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%">
                <font size="-1"><i>Another way to generate a '<code><a href="#thicken">Thicken</a></code>' operation is to generate a <a href="../compose/#set_theory">Union</a> of the results of '<code><a href="#hitmiss">Hit-And-Miss</a></code>' of this kernel with the special '<code><a href="#unity">Unity</a></code>' kernel so as to include the original image in the results.<br>
                <br>
                For example...</i></font>
                <div align="center">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -define morphology:compose=Lighten \
                  -morphology HitAndMiss 'Unity ; 3x1+2+0:1,0,0' hmt_thicken.gif
</samp></pre>
                      </td>
                    </tr>
                  </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_thicken.gif"><img src="hmt_thicken.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </div><font size="-1"><i>Actually the <a href="#kernel_compose">Multi-Kernel Composition Setting</a> in the above example is not needed as the '<code><a href="#hitmiss">Hit-And-Miss</a></code>' method specifically sets this composition setting by default, when not defined by the user.<br>
                <br></i></font>
              </td>
            </tr>
          </table><br>
          Typically '<code><a href="#thicken">Thicken</a></code>' is used to enlarge shapes such as lines, but without making the lines longer. A special set of kernels known as the '<code><a href="#convexhull">ConvexHull</a></code>' kernel, allows you to do this For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black -fill none -stroke white \
          +antialias   -draw 'line 10,20 70,60'     man_line.gif
  magick man_line.gif   -morphology Thicken ConvexHull  thick_line.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_line.gif"><img src="man_line.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="thick_line.gif"><img src="thick_line.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div><a name="thicken_convexhull" id="thicken_convexhull"></a>
          <h4>Thicken - Octagonal Convex Hull</h4>The actual '<code><a href="#convexhull">ConvexHull</a></code>' kernel is really designed to work with image shapes, and will expand a shape into a '<i>Octagonal Convex Hull</i>'. That is, it will try to fill in all the gaps between the extremes until it produces a 'octagonal shaped' object.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -morphology Close Diamond \
                  -morphology Thicken:-1 ConvexHull \
                  -morphology Close Diamond       man_hull_full.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_hull_full.gif"><img src="man_hull_full.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a><br>
            <font size="-2">See '<code><a href="#convexhull">ConvexHull</a></code>' kernel definition for more details, and why the two '<code><a href="#close">Close</a></code>' methods are needed.</font>
          </div>You can watch the iterations being performed by turning on the <a href="#verbose">Verbose Output Setting</a>. However this will show that the above is very very slow. Each '<code><a href="#thicken">Thicken</a></code>' iteration will only actually add a few pixels to the shape on each iteration. As such it can take a lot of iterations before the full 'hull' is completed. In this specific case, the image required 80 '<code><a href="#thicken">Thicken</a></code>' iterations, with a 8 kernel '<code><a href="#convexhull">ConvexHull</a></code>'. That means the above actually required 640 primitive iterations, plus another 4 primitive iterations needed to do the two '<code><a href="#close">Close</a></code>' methods. That can take quite a large amount of time. Basically iterating using <a href="#hmt">Hit And Miss Pattern Matching</a> can be very very '<i>slow</i>', and if an alternative technique can be found, it should be used instead. You can use this to also find the what points of the original image caused the creation of this octagonal shape, by getting an intersection (<a href="../compose/#darken">Darken Composition</a>) and the edge of the convex hull and the original shape.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man_hull_full.gif \
              -morphology EdgeIn Diamond man_convex_edge.gif
  magick man.gif man_convex_edge.gif \
          -compose Darken -composite man_extremities.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_convex_edge.gif"><img src="man_convex_edge.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/intersection.gif" align="middle" width="20" alt="n"> <a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_extremities.gif"><img src="man_extremities.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Any connected shape that fits inside the convex hull, but also includes at least one pixel on every edge of the above convex hull, will generate the same octagonal convex hull. <a name="thicken_greyscale" id="thicken_greyscale"></a>
          <h4>Thicken with Gray-scale Images</h4>When handling a gray-scale image '<code><a href="#thicken">Thicken</a></code>' will <b>add</b> the '<code><a href="#hitmiss">Hit-And-Miss</a></code>' foreground and background separation result to the origin pixel. This can thus be used to make the matching pixels brighter, even when the 'origin' pixel is not in the 'background' set. For example, lets repeat the corner-find example from above but with a 50% grey version of the shape.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -evaluate multiply 0.5   man_grey.gif
  magick man_grey.gif  -morphology Thicken Corners  thick_corners.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_grey.gif"><img src="man_grey.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="thick_corners.gif"><img src="thick_corners.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>When using a <a href="../basics/#hdri">HDRI version of Imagemagick</a> with '<code><a href="#thicken">Thicken</a></code>' it is probably a good idea to "<code><a href="../option_link.cgi?clamp">-clamp</a></code>" or "<code><a href="../option_link.cgi?auto-level">-auto-level</a></code>" the results to prevent it overflowing the image pixel value range limits.<br>
          <a name="thinning" id="thinning"></a>
          <h3>Thinning &nbsp; <font size="5">( <img src="../img_www/mph_thinning.gif" align="absmiddle"> )</font> &nbsp; <font size="3">(Subtracting Pixels from a Shape)</font></h3>The '<code>Thinning</code>' method is the dual of '<code><a href="#thicken">Thicken</a></code>'. Rather than adding pixels, this method subtracts them from the original image. For example lets remove any pixel that is 4 pixels in from the right edge. <!--<CODE EXECUTE>
  kernel2image -20.2 -m "5x1+0+0:1,1,1,1,0"    kernel_right_in.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -morphology Thinning '5x1+0+0:1,1,1,1,0' thin_right.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_thinning.gif" align="middle" width="20" height="30"> <a href="kernel_right_in.gif"><img src="kernel_right_in.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="thin_right.gif"><img src="thin_right.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>For '<code>Thinning</code>' to work properly the pattern matching kernel should have an origin containing a foreground pixel, otherwise the method has no matching pixel to remove from the shape.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%">
                <font size="-1"><i>Another way to generate a '<code><a href="#thinning">Thinning</a></code>' operation is to <a href="../compose/#set_theory">Relative Complement</a> (using a <a href="../compose/#minussrc">MinusSrc</a> composition) the results of '<code><a href="#hitmiss">Hit-And-Miss</a></code>' from the original image. You can include that image at the start of the kernel list (to 'subtract' from) by using a '<code><a href="#unity">Unity</a></code>' kernel.<br>
                <br>
                For example...</i></font>
                <div align="center">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -define morphology:compose=MinusSrc \
          -morphology HMT 'Unity ; 5x1+0+0:1,1,1,1,0' hmt_thinning.gif
</samp></pre>
                      </td>
                    </tr>
                  </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_thinning.gif"><img src="hmt_thinning.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </div><font size="-1"><i>This is an 'intersection' style of thinning, removing all the specified pixels of all the kernels in a single step, rather than 'iterative' style, that removes the pixels from each kernel in sequence. See <a href="#thinning_style">Thinning Style</a> for more info.<br>
                <br></i></font>
              </td>
            </tr>
          </table>
          <h4>Line Connected-ness</h4><i>FUTURE: 4-connected verses 8-connected lines</i>See discussion in IM forums, <a href="../forum_link.cgi?f=1&amp;t=21253">From 8-connected to 4-connected lines</a>. <a name="thinning_edgedet" id="thinning_edgedet"></a>
          <h4>Thinning Edge Detector Output</h4>One of the most common uses of thinning is to reduce the threshold output of an <a href="../convolve/#edgedet">Edge Detector</a> such as <a href="../convolve/#sobel">Sobel Convolution</a>, to lines of a single pixel thickness, while preserving the full length of those lines. <i>Example using a Distance Gradient Image</i>. <a name="thinning_skeleton" id="thinning_skeleton"></a>
          <h4>Thinning down to a Skeleton</h4>'<code><a href="#thinning">Thinning</a></code>' images is actually more commonly used than '<code><a href="#thicken">Thicken</a></code>', as it is used to reduce the shapes into more manageable forms, such as <a href="#skeletons">Skeletons</a>. Which, as will be discussed later, are meant to be the center line of pixels between any two (or more) edges of the shape.A skeleton is important as it provides a very good description of a very complex shape. For example processing the image to find the number of loops, line segments, and how they are arranged, will tell you a lot about the shape that you have. So lets produce a '<i>Thinned Skeleton</i>' by '<code><a href="#thinning">Thinning</a></code>' the edges of the man shape down repeatedly, until only the center lines are left.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif  -morphology Thinning:-1 Skeleton  man_raw_thinned.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_raw_thinned.gif"><img src="man_raw_thinned.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>A <a href="#verbose">Verbose</a> report on the above would have shown that 18 iterations, with 8 kernels, totalling 144 primitive iterations in total. this is actually a lot faster than finding its <a href="#thicken_convexhull">Convex Hull</a> (above), as the thinning kernels remove whole rows and columns of pixels with each iteration, and not just a few at a time. Note how the '<code><a href="#skeleton">Skeleton</a></code>' kernel set failed to expand the hole, so that it did not find the center line between the hole and the outside edge. This is a serious failing of this specific skeleton thinning kernel, and is caused by the kernels all requiring at least background pixels before they will make any thinning match. You can use sets of skeleton thinning kernels to solve this problem. A simplier solution is to <a href="#erode">Erode</a> the image slightly to give the kernels something to work with. I will also only erode and thin the 'Red' and 'Green' channels, so as to leave original shape in blue.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG -morphology Erode Diamond  man_erode.gif
  magick man_erode.gif -channel RG \
          -morphology Thinning:-1 Skeleton +channel  man_skeleton.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_erode.gif"><img src="man_erode.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_skeleton.gif"><img src="man_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>You can also see that any hole in the image has now expanded to produce larger continuous loop of pixels around it.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is a close up of loop around the eroded hole.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_skeleton_zoom.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_skeleton_zoom.gif"><img src="man_skeleton_zoom.gif" width="120" height="120" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that it did not produce an exact center-line between the hole and the edge. Also as the shape was eroded, the lines do not go right the edge of the original the shape but stop one pixel short. That is, the end of lines have been 'pruned' slightly. That is, the disadvantage of the 'erode' soltion. The skeleton is also limited to octagonal lines, which means it is missing a lot of detail, though in this case that simplification can be a good thing. See the section on <a href="#skeletons">Skeletons</a> below. This is a traditional '<code><a href="#skeleton">Skeleton</a></code>' kernel, which as you can see produces 'thick' diagonal lines, so that all parts of the skeleton are '4-connected' or 'diamond connected'. There are other variations of '<code><a href="#skeleton">Skeleton</a></code>' kernels, which will produce other variations in the resulting '<i>Thinned Skeleton</i>'. <a name="thinner_skeleton" id="thinner_skeleton"></a> <b>Thinner, 8 Connected, Skeleton</b>This 'traditional' skeleton as mentioned has thick diagonals. But often this is not 'thin' enough. In some situations what you want is a slightly thinner skeleton. That is, you want an '8-connected' skeleton rather than '4-connected' skeleton.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                One solution is to use a different skeleton generation variant, such as generated using a '<code><a href="#skeleton2">Skeleton:2</a></code>' kernel, (found on the <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">HIPR2 Graphic Tutorial Website</a>). For example...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif   -channel RG  -morphology Erode Diamond \
          -morphology Thinning:-1 Skeleton:2 +channel  man_skeleton_hipr.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_skeleton_hipr.gif"><img src="man_skeleton_hipr.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                And here is a zoom of the loop area, showing how the resulting skeleton is 8-connected, with thinner diagonals.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton_hipr.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_skeleton_hipr_zoom.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_skeleton_hipr_zoom.gif"><img src="man_skeleton_hipr_zoom.gif" width="120" height="120" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However I have found such skeletons to not be as accurate as the 'traditional' skeleton. Basically in test cases I have found that the diagonals were 'thinned' on the wrong side. Basically because the side of the diagonals that is removed is controlled purely by the order of the 'corner' thinning kernel in the kernel set, and not by any decision due to the nature of the shape.<br>
          The alternative is to take a 'traditional' skeleton, and thin it so that the diagonals are always thinned on the 'outside' of the diagonal, as defined by the end points of the diagonal. The special '<code><a href="#diagonals">Diagonals</a></code>' thinning kernel, is designed to do this, with a '<code><a href="#corners">Corners</a></code>' kernel being used afterward to 'finish'. So lets thin the previous 'traditional' skeleton further..
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -channel RG \
          -morphology Thinning:-1 Diagonals \
          -morphology Thinning Corners   man_thin_skeleton.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_skeleton.gif"><img src="man_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_thin_skeleton.gif"><img src="man_thin_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>This technique of thinning a traditional 4-connected skeleton, is slightly slower, than simply directly using the '<code><a href="#skeleton2">Skeleton:2</a></code>' variant. The extra thinning required 8 thinning iterations of the 8 kernels, or 64 primitive iterations. Alternately you can just use the '<code><a href="#corners">Corners</a></code>' kernel only, though that will just generate the 'HIPR' variant, with just a 'random' choice of which side of the diagonals was thinned. However it will only take 1 pass of all 4 kernels, and as such it much much faster than using '<code><a href="#diagonals">Diagonals</a></code>'. In any case by starting with a 'traditional' 4-connected skeleton, you can then generated an 8-connected version (of some kind), Very easily. <a name="skeleton_info" id="skeleton_info"></a>
          <h4>Skeleton Information</h4>When you have a skeleton (perhaps even both a 4 and 8 connected version) the next step is usually to find out more information about the skeleton. For example how many 'free end of lines', 'line junctions', and 'line loops' are present. <i>Number of Line Ends</i>Here I use the a <a href="#hitmiss">Hit And Miss Search</a> for '<code><a href="#lineends">LineEnds</a></code>' on the skeleton we generated previously (extracting it from the 'red' channel). I then <a href="#dilate">Dilate</a> those line ends into <a href="#ring">Rings</a> and color them before merging with the original skeleton, to make their locations highly visible.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -channel R -separate +channel \
          -morphology HMT LineEnds man_ends.gif
  magick man_ends.gif -morphology Dilate Ring -background Red -alpha Shape \
          man_skeleton.gif +swap -composite man_ends_marked.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_skeleton.gif"><img src="man_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_ends.gif"><img src="man_ends.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_ends_marked.gif"><img src="man_ends_marked.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Note that the lines all connect each other, or to the loop of pixels were not found. Only the free line ends were indicated. If you did a pixel count (using a <a href="../files/#histogram">Histogram Output</a>) you would see that this skeleton generated 12 line ends. <i>Number of Line Junctions</i>You can get a rough count count of the number of line junctions in an image by using the '<code><a href="#linejunctions">LineJunctions</a></code>' kernel with a <b>8-connected skeleton</b>, preferably one that was thinned down from the original skeleton used for counting line-ends. Do not mix two different skeleton generation variants.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man_thin_skeleton.gif -channel R -separate +channel \
            -morphology HMT LineJunctions  man_junctions.gif
  magick man_junctions.gif -morphology Dilate Ring \
          -background Red -alpha Shape \
            man_thin_skeleton.gif +swap -composite man_junctions_marked.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_thin_skeleton.gif"><img src="man_thin_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_junctions.gif"><img src="man_junctions.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_junctions_marked.gif"><img src="man_junctions_marked.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>If you did try try this kernel directly with a traditional 4-connected skeleton, you will get multiple matches for some of the '<code>T</code>' junctions, making the count very inaccurate. The result as you can see are 12 line junctions, which for this specific shape is correct. However for some junctions the '<code><a href="#linejunctions">LineJunctions</a></code>' kernel is inaccurate. For example a 4-line diagonal '<code>X</code>' junction will only produce 1 match, while an orthogonal '<code>+</code>' junction, will produce 4 matches. Both of these special junctions should produce 2 matches, to keep the line junction count correct. As such to get an accurate count you will need to add 1 more value for every '<code>X</code>' junction, and subtract 2 counts for every '<code>+</code>' junction.<br>
          For a skeleton that has no loops the number of junctions should be 2 less than the number of line ends. However if the number of line ends equals the number of line junctions it means you have one or more loops in the skeleton. Now this skeleton has 12 line ends and 12 junctions. so it contains at least one continuous loop of pixels somewhere in the image. <i>Number of Loops</i><i>FUTURE: Connected Object Labeling</i> <a name="thinning_pruning" id="thinning_pruning"></a>
          <h4>Pruning Lines</h4>So you know this image has at least one loop. Suppose you want to simplify the shape to just those loop(s). The solution to to '<i>Prune</i>' all the line ends repeatedly until you have removed them all. For a 4-connected skeleton such as this you can even use a smaller set of '<code><a href="#lineends_subtypes">LineEnds</a></code>' kernels to make process about twice as fast.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -channel G \
          -morphology Thinning:-1 'LineEnds:1&gt;' man_loop.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man_skeleton.gif"><img src="man_skeleton.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_loop.gif"><img src="man_loop.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>A <a href="#verbose">Verbose</a> report on this would have shown that this took 75 iterations with 4 kernels, resulting in 300 primitive integrations to '<i>Prune</i>' all the lines with free ends from the image. That is, about twice as many operations as was used to find the skeleton, which shows how much more intensive this operation can be. Using a full set of '<code><a href="#lineends">LineEnds</a></code>' kernels (8 kernels), would also have taken 75 iterations, but with twice as many kernels, making this 600 primitive iterations. <a name="thinning_prune_fast" id="thinning_prune_fast"></a>
          <h4>Fast Pruning of Lines</h4>
          <pre>Fast Complete pruning technique..

  1/  Find line ends, and line junctions.
  2/  Delete the line junctions to completely disconnect all line segments.
  3/  Flood fill, or use contitional dilate to remove 'line end' segments.
  4/  Restore line junctions.
  5/  use that as a map on original image to restore 'loops'.

</pre>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                We have already covered the first step... resulting in...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code do_not_execute="" already="" done="">
  magick man_skeleton.gif -channel R -separate +channel \
          -morphology HMT LineEnds man_ends.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_ends.gif"><img src="man_ends.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>To disconnect (or separate) all the line segments you can use a '<code><a href="#linejunctions">LineJunctions</a></code>' kernel. However the default kernel set will not completely disconnect '<code>T</code>' junctions (just locate them).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                To properly disconnect all line segment you will also need to add orthogonal '<code>T</code>' kernels to the kernel set, and it is also best to include a '<code>+</code>' junction too. For example.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -channel R -separate +channel \
      -morphology HMT 'LineJunctions;LineJunctions:3&gt;;LineJunctions:5' \
      man_disconnect.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_disconnect.gif"><img src="man_disconnect.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Thinning with these matches will actually disconnect the segments, however you must do this all in one step, (see <a href="#thinning_style">Thinning Style</a>), or it will not work correctly.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man_skeleton.gif -channel R -separate +channel \
      -define morphology:compose=Darken \
      -morphology Thinning 'LineJunctions;LineJunctions:3&gt;;LineJunctions:5' \
      man_line_segments.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_line_segments.gif"><img src="man_line_segments.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is a zoom of the 'loop' showing the disconnected segments.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man_line_segments.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_line_segments_zoom.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_line_segments_zoom.gif"><img src="man_line_segments_zoom.gif" width="120" height="120" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>At this point we can now remove any line segment that contains a match with the previously discovered 'line end'. This can be done either by 'flood filling' from those 'seed' points, to delete them. However this only works for a 4 connected skeleton, which is what flood filling assumes. <i>Example Here</i>Alternatively we can use <a href="#cond_dilation">Conditional Dilatation</a> to find all all the points simultaneously, and remove them. <i>Example Here - when Conditional Dilate or Erode is available.</i>If you now restore the line junctions, do one prune, and remove any single pixels that are left, you will now have removed all the line segments quickly. Yes this seems like a lot of steps, but believe me it is still a lot faster than having to '<i>prune the end of lines</i>' 300 times to get the same result. <a name="thinning_style" id="thinning_style"></a>
          <h4>Thinning Style - Sequential or Simultaneous</h4>If you were to do one single 'pruning' of the end of the line segments, and compare it to the original image you will find that more often than not a line segment was pruned anywhere from 2 to 4 times, depending on the exact shape and orientation of the lines. For example (resulting image enlarged) is is a default line ends thining
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 10x10 xc:black -fill white \
          +antialias  -draw 'line 1,7 8,3' line.gif
  magick line.gif -channel GB \
          -morphology Thinning LineEnds  line_seqential.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="line_mag.gif"><img src="line_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="line_seqential_mag.gif"><img src="line_seqential_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--
  magick line.gif -scale 800% line_mag.gif
  magick line_seqential.gif -scale 800% line_seqential_mag.gif
-->
          That is, because by default each of the '<code><a href="#thinning">Thinning</a></code>' kernels is applied against the results of previous kernel, in <i>sequence</i>. That is, it removes all the pixels selected by one kernel, before appling the next kernel to that result, which may (and does) select more pixels from the same end of line. In other words it will, by default, thin the end of the lines multiple times for one complete 'iteration' though all the kernels provided. That means you can not rely on the <a href="#verbose">Verbose Output</a> to get an exact idea of how long all the lines were by counting the number of pixels removed by a single iteration of this operator. However you can modify how '<code><a href="#thinning">Thinning</a></code>' works, so that it removes only the set of pixels a single '<code><a href="#hitmiss">Hit-And-Miss</a></code>' iteration through all the kernel would find. In other words apply all the kernels to the same image at the start of the interation, merge them, then remove just those pixels, once only for all kernels. That is, remove all the HMT selected pixels <i>simultaniously</i>. Basically you set the <a href="#kernel_compose">Multi-Kernel Composition Setting</a> to use a '<code><a href="../compose/#darken">Darken</a></code>' compose method, which will do exactly that. Specifically merging all the selected pixels for a single removal of selected pixels. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick line.gif -channel GB -define morphology:compose=darken \
          -morphology Thinning LineEnds  line_simultaneous.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="line_simultaneous_mag.gif"><img src="line_simultaneous_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!--
  magick line_simultaneous.gif -scale 800% line_simultaneous_mag.gif
-->
          What happened here is that each kernel of the <a href="#pattern_kernels">Pattern Matching Kernels</a> will applied only to the original image. Any pixels that matched the original, will then be collected together. That is, we will only remove a 'intersection' of the results of all kernels against the original, by using a 'darken' composition. But the removal is done all in one step for any one iteration through all the kernels. The result is that a line end will only ever get matched one time, even if multiple kernels could match that line end. And thus only the single pixel on the end will be removed, rather than 2 or more pixels, by different kernels. In summary, adding a '<code><a href="../compose/#darken">Darken</a></code>' <a href="#kernel_compose">Multi-Kernel Composition Setting</a>, will ensure the '<code><a href="#thinning">Thinning</a></code>' method does '<i>Simultaneous Thinning</i>' (all kernels simultaneously), rather than '<i>Sequential Thinning</i>' (one kernel at a time - the default).<br>
          However, while this will make the pruning of line ends more well-behaved, it will make it slower, and can change the overall result of a thinning. Take the case of '<code><a href="#thinning">Thinning</a></code>' some boxes by thinning both the left and right edges simultaneously.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 10x10 xc:black -fill white -draw 'rectangle 4,1 5,7' rect.gif
  magick rect.gif -channel GB -define morphology:compose=darken \
          -morphology Thinning Edges  rect_simultaneous.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="rect_mag.gif"><img src="rect_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="rect_simultaneous_mag.gif"><img src="rect_simultaneous_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--
  magick rect.gif -scale 800% rect_mag.gif
  magick rect_simultaneous.gif -scale 800% rect_simultaneous_mag.gif
-->
          The 'Simultaneous Thinning' actually deleted the center rectangle completely! What is happening is that the shape was thinned down to a two pixel thickness, and then both sides of the 'thick' center-rect matched the pattern and both sides were 'thinned'. The same thing will happen if you do this when <a href="#thinning_skeleton">Thinning down Skeletons</a>. The default 'Sequential Thinning' on the other hand produced...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rect.gif -channel GB \
          -morphology Thinning Edges rect_seqential.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rect_seqential_mag.gif"><img src="rect_seqential_mag.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!--
  magick rect_seqential.gif -scale 800% rect_seqential_mag.gif
-->
          As you can see it preserved one of the pixels (on the right) to be a skeleton center line. That is, because one set of kernels first thinned down one side of a 'thick' center-line, but the later kernels did not match this 'thinner' line, so it was not removed. Essentially there are situations where '<i>Sequential Thinning</i>' (the default), is better than the special '<i>Simultaneous Thinning</i>', and visa-versa.<br>
          <a name="pattern_kernels" id="pattern_kernels"></a>
          <h3>Pattern Matching Kernels</h3>As mentioned a 'Pattern Matching' or '<code><a href="#hitmiss">Hit-And-Miss</a></code>' kernel can contain 3 different types of elements, foreground, background, and 'don't care'. A value of '<code>1.0</code>' or (white) matches foreground pixels. A value of '<code>0.0</code>' or (black) matches background pixels. You can use either a value of '<code>0.5</code>' or the special value of '<code>Nan</code>' or '<code>-</code>' to represent pixel elements that are not part of the neighbourhood and thus you 'don't care' about. The '<code><a href="#hitmiss">Hit-And-Miss</a></code>' will only match places where the smallest (minimum) foreground pixel is larger than the largest (maximum) background pixel. It will then return the difference between these two values, or zero. <!--<CODE EXECUTE>
   kernel2image -10.1 -m "Peaks"         kernel_peaks.gif
</CODE>-->
          <a href="kernel_peaks.gif"><img src="kernel_peaks.gif" align="right" border="0" alt="[IM Output]"></a> <a name="peaks" id="peaks"></a>
          <h4>Peaks</h4>The '<code>Peaks</code>' kernel is an extension of the '<code><a href="#ring">Ring</a></code>' kernel shown previously. Two radii arguments will generate a 'ring' of background pixels, surrounding a single foreground pixel in the at the central 'origin'. Here are some examples of some of the more useful '<code>Peak</code>' kernels... <!--<CODE EXECUTE>
   kernel2image -20.1 -m "Peaks:1"         kernel_peaks_01.gif
   kernel2image -20.1 -m "Peaks:1.9"       kernel_peaks_02.gif
   kernel2image -15.1 -m "Peaks:2"         kernel_peaks_03.gif
   kernel2image -15.1 -m "Peaks:2.5"       kernel_peaks_04.gif
   kernel2image -15.1 -m "Peaks:2.9"       kernel_peaks_05.gif
   kernel2image  -8.1 -m "Peaks:4.3,5.3"   kernel_peaks_06.gif
</CODE>-->
          <div align="center">
            <a href="kernel_peaks_01.gif"><img src="kernel_peaks_01.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_peaks_02.gif"><img src="kernel_peaks_02.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_peaks_03.gif"><img src="kernel_peaks_03.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_peaks_04.gif"><img src="kernel_peaks_04.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_peaks_05.gif"><img src="kernel_peaks_05.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <a href="kernel_peaks_06.gif"><img src="kernel_peaks_06.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The above kernels can be used to either definitively locate a single pixel 'peak' value in a sea of darker pixels, or find any small shape that completely fits inside the larger ring. They are especially useful to improve the contrast of a <a href="../convolve/#correlate_search">Correlation Pattern Match Search</a>. <a name="edges" id="edges"></a>
          <h4>Edges</h4><br clear="all">
          The '<code>Edges</code>' kernel set, will match any pixel on a flat edge of a shape. It does not match pixels on a sharp ninety degree corner, though it will match a corner pixel on an octagonal shape.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -20.1 -ml '' -mt x1 "Edges"  miff:- | \
     magick -background LightSteelBlue  - label:Edges \
             -gravity center -append    kernel_edges.gif
</CODE>-->
            <a href="kernel_edges.gif"><img src="kernel_edges.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>As you can see all the 90 degree rotations are generated, but they are ordered in a 'flip-flop' mirror ordering that generally produces better results. Typically this kernel is used as a type of image '<code><a href="#thinning">Thinning</a></code>' kernel, however as it stands it will fail to thin diagonal edges, or generate a proper skeleton of an image. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 Edges   thin_edges.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="thin_edges.gif"><img src="thin_edges.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>See the '<code><a href="#skeleton">Skeleton</a></code>' kernels below. <a name="corners" id="corners"></a>
          <h4>Corners</h4>The '<code>Corner</code>' kernels locate any diagonal corner pixel around the edges of an image. See '<code><a href="#hitmiss">Hit-And-Miss</a></code>' above for an example of its use.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -20.1 -ml '' -mt x1 "Corners"  miff:- | \
     magick -background LightSteelBlue  - label:Corners \
             -gravity center -append    kernel_corners.gif
</CODE>-->
            <a href="kernel_corners.gif"><img src="kernel_corners.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>Here for example I used it to try and thin all diagonal edges...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 Corners  thin_corners.gif
</samp></pre>
                    </td>
                  </tr>
                </table>It can be combined with the '<code><a href="#edges">Edges</a></code>' kernel to produce one method skeleton thinning. See the '<code><a href="#skeleton">Skeleton</a></code>' kernels below, for an example of this.
              </td>
              <td>
                <a href="thin_corners.gif"><img src="thin_corners.gif" width="100" height="125" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="diagonals" id="diagonals"></a>
          <h4>Diagonals</h4>The '<code>Diagonals</code>' kernel is an alternative to simply using a '<code><a href="#corners">Corners</a></code>' kernel to thin 4-connected diagonal lines down to a 8-connected diagonal lines. This can be used to thin 4-connected lines, by removing the outside set of pixels from a corner toward the center until complete.
          <div align="center">
            <!-- <CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 "Diagonals"  miff:- | \
     magick -background LightSteelBlue  - label:Diagonals \
             -gravity center -append    kernel_diagonals.gif
</CODE> -->
            <a href="kernel_diagonals.gif"><img src="kernel_diagonals.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>Note the results should be completed by using a '<code><a href="#corners">Corners</a></code>' kernel, to locate and thin 90-degree corners. See <a href="#thinner_skeleton">Thinner Skeleton</a> for an example of usage. <a name="diagonals_subtypes" id="diagonals_subtypes"></a> <b>Diagonals Sub-Types</b>By providing a '<i>type</i>[,<i>angle</i>]' argument to the kernel you can select specific sub-types that was used to make up the above kernel set.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -25.2 -m "Diagonals:1"  kernel_diagonals1.gif
   kernel2image -25.2 -m "Diagonals:2"  kernel_diagonals2.gif
</CODE>-->
            <a href="kernel_diagonals1.gif"><img src="kernel_diagonals1.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a> <a href="kernel_diagonals2.gif"><img src="kernel_diagonals2.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a>
          </div>This will let you specify your own specific set of kernels, to thin diagonals in exactly the way you want them thinned. For example, you could separately thin each of the four types of diagonals (using both the above kernels with the same <i>angle</i> value). By doing this you can do an iterative reducing of each type of diagonal one at a time, aborting as soon as all those specific diagonals has been thinned, and thus reducing the overall number of '<i>primitive morphology steps</i>' that are performed. <i>example needed</i>As it is given, the default kernel set will simply try to thin all the diagonals simultaneously and repeatedly until they have all been thinned. That means the all the kernel will be applied until all the diagonals have been thinned, rather than just the diagonals that need thinning. That means it perform many '<i>primitive morphology steps</i>' that are no longer needed, with most kernels making no changes to the image during each loop. <i>full example needed</i>Remember each of the four diagonals should still be performed using both pairs of kernels (for each specific angle) so that both ends of each specific diagonal are thinned together, such as when the diagonal is part of an 'arc'. There is a related discussion about this type of thinning/thickening operation in the IM forum, <a href="../forum_link.cgi?f=1&amp;t=21253">From 8-connected to 4-connected lines</a>. <a name="lineends" id="lineends"></a>
          <h4>LineEnds</h4>The '<code>LineEnds</code>' kernel set, as shown in <a href="#thin_pruning">Pruning Ends of Lines</a> above, is designed to locate the end of lines. More specifically it find the ends of sharp points.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 "LineEnds"  miff:- | \
     magick -background LightSteelBlue  - label:LineJunctions \
             -gravity center -append    kernel_lineends.gif
</CODE>-->
            <a href="kernel_lineends.gif"><img src="kernel_lineends.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>As you can see, it will only match lines that have at least two pixels, with the matching pixel 'capped' or 'surrounded' by background pixels. For example, here we use '<code><a href="#hitmiss">Hit-And-Miss</a></code>' to find all the line ends.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick lines.gif -morphology HMT LineEnds  hmt_lineends.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="lines.gif"><img src="lines.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_lineends.gif"><img src="hmt_lineends.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_lineends_rings.gif"><img src="hmt_lineends_rings.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Yes there is a lot of line ends in this image. But you should note that lines which end in a 'loop' of some kind will not produce a match. Note that if you are '<code><a href="#thinning">Thinning</a></code>' an image using this kernel using an 'iterative thinning' style (the default), successive kernels could match the same end of a line two or more times, thus shrinking the line many times during a single iteration of the whole '<code><a href="#thinning">Thinning</a></code>' method. See <a href="#thinning_style">Thinning - Sequence vs Simultaneous</a> for more details. <a name="lineends_subtypes" id="lineends_subtypes"></a> <b>Line End Sub-Types</b>You can also this kernel give a '<i>type</i>[,<i>angle</i>]' arguments, which will return one of the single kernel definitions that was used to generate the above '<code><a href="#lineends">LineEnds</a></code>' kernel set.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -20.2 -m "LineEnds:1"  kernel_lineends1.gif
   kernel2image -20.2 -m "LineEnds:2"  kernel_lineends2.gif
   kernel2image -20.2 -m "LineEnds:3"  kernel_lineends3.gif
   kernel2image -20.2 -m "LineEnds:4"  kernel_lineends4.gif
</CODE>-->
            <a href="kernel_lineends1.gif"><img src="kernel_lineends1.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a> <a href="kernel_lineends2.gif"><img src="kernel_lineends2.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a> <a href="kernel_lineends3.gif"><img src="kernel_lineends3.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a> <a href="kernel_lineends4.gif"><img src="kernel_lineends4.gif" align="middle" hspace="25" border="0" alt="[IM Output]"></a>
          </div>These can then be <a href="#kernel_rotations">Expanded into a Rotated Kernel List</a> as you require, or rotated to a specific '<i>angle</i>', as needed. The default '<code><a href="#lineends">LineEnds</a></code>' set, actually uses the kernel definition.
          <div align="center">
            '<code>LineEnds:1&gt; ; LineEnds:2&gt;</code>'
          </div>The '<code>LineEnds:3</code>' is the orthogonal equivalent to the diagonal '<code>LineEnds:2</code>', which will only find the line ends well away from any diagonal corner or junction. The '<code>LineEnds:4</code>' is a traditional line end kernel, which is rotated in cyclic fashion to produce 8 kernels (for example '<code>LineEnds:4@</code>). However it will fail to locate the last pixel of a line connecting to an orthogonal 'T' junction. The default '<code><a href="#lineends">LineEnds</a></code>' set, as defined above, does however find that final pixel at 'T' junctions, using the same number of kernels. <a name="linejunctions" id="linejunctions"></a>
          <h4>LineJunctions</h4>Where '<code><a href="#lineends">LineEnds</a></code>' find the ends of a group of lines, '<code>LineJunctions</code>' will find points that form a junction of 3 or more lines.
          <div align="center">
            <!--<CODE EXECUTE SCRIPT IMAGE=kernel_linejunctions.gif>
   ( kernel2image -15.1 -ml '' -mt x1 "LineJunctions:1@"  miff:-
     kernel2image -15.1 -ml '' -mt x1 "LineJunctions:2>"  miff:-
   ) |
   magick -background LightSteelBlue  - label:LineJunctions \
           -gravity center -append    kernel_linejunctions.gif
</CODE>-->
            <a href="kernel_linejunctions.gif"><img src="kernel_linejunctions.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>For example, here we use '<code><a href="#hitmiss">Hit-And-Miss</a></code>' to find all the line junctions.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code do_not_execute="" example="" done="" previously="">
  magick lines.gif -morphology HMT LineJunctions hmt_junctions.gif
</code></pre>
                </td>
              </tr>
            </table><a href="lines.gif"><img src="lines.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_junctions.gif"><img src="hmt_junctions.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="hmt_junctions_rings.gif"><img src="hmt_junctions_rings.gif" width="80" height="80" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>The '<code><a href="#linejunctions">LineJunctions</a></code>' kernel is generally used for two purposes.
          <ul>
            <li>Count the number of line junctions in an image, and thus work toward a count of the number of line segments in the skeleton.</li>
            <li>Disconnect all line segments from each other.</li>
          </ul>Note however that at the 'T' and '+' junctions in the above image, the 'Y' junction kernel matches points that is one pixel one pixel away from the actual intersection. Because of this junction counts may not be exactly as expected, especially at the '+' where four matches were found rather than just the required two for a junction count. Caution is recommented. See <a href="#skeleton_info">Skeleton Information</a>, and <a href="#thinning_prune_fast">Fast Line Pruning</a> for more details of these two aspects. The kernel actually only defines foreground pixels as such it can be applied simply as a '<code><a href="#erode">Erode</a></code>' method, instead of as a '<code><a href="#hitmiss">Hit-and-Miss</a></code>' method. <a name="linejunctions_subtypes" id="linejunctions_subtypes"></a> <b>Line Junction Sub-Types</b>This kernel also provides access to the various sub-types, by specifying '<i>type</i>[,<i>angle</i>]' arguments. This can be used to search for specific types of line junctions.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -25.2 -m "LineJunctions:1"  kernel_linejunctions1.gif
   kernel2image -25.2 -m "LineJunctions:2"  kernel_linejunctions2.gif
   kernel2image -25.2 -m "LineJunctions:3"  kernel_linejunctions3.gif
   kernel2image -25.2 -m "LineJunctions:4"  kernel_linejunctions4.gif
   kernel2image -25.2 -m "LineJunctions:5"  kernel_linejunctions5.gif
</CODE>-->
            <a href="kernel_linejunctions1.gif"><img src="kernel_linejunctions1.gif" align="middle" border="0" alt="[IM Output]"></a> <a href="kernel_linejunctions2.gif"><img src="kernel_linejunctions2.gif" align="middle" border="0" alt="[IM Output]"></a> <a href="kernel_linejunctions3.gif"><img src="kernel_linejunctions3.gif" align="middle" border="0" alt="[IM Output]"></a> <a href="kernel_linejunctions4.gif"><img src="kernel_linejunctions4.gif" align="middle" border="0" alt="[IM Output]"></a> <a href="kernel_linejunctions5.gif"><img src="kernel_linejunctions5.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>The kernels '<code>LineJunctions:2</code>' can also be specified using '<code>LineJunctions:3,45</code>', and similarly '<code>LineJunctions:5</code>' and '<code>LineJunctions:4,45</code>' are equivilent. The default '<code><a href="#linejunctions">LineJunctions</a></code>' kernel set only uses the first two junction definitions (the '<code>Y</code>' and diagonal '<code>T</code>' junctions), in the following way...
          <div align="center">
            '<code>LineJunctions:1@ ; LineJunctions:2&gt;</code>'
          </div>This is appropriate for a 8-connected line junctions. As discussed in IM Forums "<a href="../forum_link.cgi?f=1&amp;t=22776">Kernels used by LineJunctions</a>" if you want to test for 4-connected line junctions only, you would need to look for orthogonal 'T' junctions, and a '+' junctions.
          <div align="center">
            '<code>LineJunctions:3&gt; ; LineJunctions:5</code>'
          </div>However as the 'T' kernels will also hit a '+', you can cut the above down to just...
          <div align="center">
            '<code>LineJunctions:3&gt;</code>'
          </div>A separate image test for just 4-way '+' junction can be used to separate them from 3 way 'T' junctions, if that is needed for determining line segment counts. <a name="ridges" id="ridges"></a>
          <h4>Ridges</h4>The '<code>Ridges</code>' kernels are used to locate ridges and thin lines of pixels, such as in a <a href="#distance">Distance Gradient</a> image. <i>These Kernels are experimental and may change.</i> The default is designed to locate a single pixel thick ridge lines.
          <div align="center">
            <!--<CODE EXECUTE>
  kernel2image -20.2 -ml '' -mt x1 "Ridges"  miff:- | \
    magick -background LightSteelBlue  - label:Ridges \
            -gravity center -append    kernel_ridges.gif
</CODE>-->
            <a href="kernel_ridges.gif"><img src="kernel_ridges.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div><a name="ridges2" id="ridges2"></a> <b>Ridges:2</b>A special expanded subtype that is designed to find two pixel thick ridge lines. The complexity is caused by the need to locate and mark a slanted line of this sort, including mirrors of those lines.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x3 "Ridges:2"  miff:- | \
      montage -label Ridges:2 -  -background LightSteelBlue \
              -geometry +0+0  kernel_ridges2.gif
</CODE>-->
            <a href="kernel_ridges2.gif"><img src="kernel_ridges2.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>This set of kernels is important as a 'Morphological Skeleton' actually consists both 1 and 2 pixel thick lines. <a name="convexhull" id="convexhull"></a>
          <h4>ConvexHull</h4>The '<code>ConvexHull</code>' kernel set, is designed to thicken shapes so as to produce a 'Octagonal Convex Hull' of the shape. That is, the smallest octagonal shape that can contain the whole of the shape.
          <div align="center">
            <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x2 "ConvexHull"  miff:- | \
      montage -label ConvexHull -  -background LightSteelBlue \
              -geometry +0+0  kernel_convexhull.gif
</CODE>-->
            <a href="kernel_convexhull.gif"><img src="kernel_convexhull.gif" align="middle" border="0" alt="[IM Output]"></a>
          </div>There are two sets of 90 degree rotated kernels, one the mirror image of the other. As the origin is actually a 'background' element, it is really only meant to be used as a '<code><a href="#thicken">Thicken</a></code>' pattern kernel. However the kernel will fail for images containing horizontal or vertical 'slots', such as we have in the 'man' shape.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel R \
          -morphology Thicken:-1 ConvexHull  man_hull.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_hull.gif"><img src="man_hull.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                The solution is to '<code><a href="#close">Close</a></code>' these slots (and the central hole) before using '<code><a href="#convexhull">ConvexHull</a></code>'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code do_not_execute="" this="" was="" done="" above="">
  magick man.gif -morphology Close Diamond \
                  -morphology Thicken:-1 ConvexHull \
                  -morphology Close Diamond       man_hull_full.gif
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="man_hull_full.gif"><img src="man_hull_full.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note in the above I also repeated the '<code><a href="#close">Close</a></code>' after using '<code><a href="#convexhull">ConvexHull</a></code>'. The reason is that any large 'holes' in an image will also be reduced by the '<code><a href="#thicken">Thicken</a></code>' down down to single pixels, or orthogonal 'slots'. Repeating the '<code><a href="#close">Close</a></code>' removes those holes without effecting the final shape.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Here is another example, where the original shape (white) was expanded using a convex hull thickening (red).
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick circles.gif -channel R \
          -morphology Thicken:-1 ConvexHull  circles_hull.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="circles_hull.gif"><img src="circles_hull.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the result is an octagonal shape, while the central hole was reduced down to a two pixel slot, ready to be closed. <a name="skeleton" id="skeleton"></a>
          <h4>Skeleton</h4>Generating 'skeletons' by thinning of a particular shape is not an easy matter. Even with the same kernel set, re-ordering the kernels can generate a different variation on the final 'skeleton'. Because of this I have not implemented just one '<code>Skeleton</code>' kernel set, but a number of them, which can be selected by giving a '<i>type</i>' argument number. <a name="skeleton1" id="skeleton1"></a>
          <h4>Skeleton:1</h4>The first and default set, '<code><b>Skeleton:1</b></code>', is a traditional thinning kernel, as what was first used. This is basically exactly like the '<code><a href="#edges">Edges</a></code>' kernel above, but cyclically rotated in 45 degree increments.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="center">
                <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:1"  miff:- | \
      montage -label "Skeleton:1 (Traditional)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton1.gif
</CODE>-->
                <a href="kernel_skeleton1.gif"><img src="kernel_skeleton1.gif" align="middle" border="0" alt="[IM Output]"></a>
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 Skeleton   thin_skeleton1.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="thin_skeleton1.gif"><img src="thin_skeleton1.gif" width="100" height="125" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The result is a reasonable 'thinned skeleton' of a shape, though diagonals tend to remain a little thick on one side. basically the skeletion produced is 4-connected, which will allow you to use a <a href="#thinning_prune_fast">Fast Pruning</a> technique. Also note that this kernel set does not correctly expand single pixel hole in the image. In other words the skeleton around that hole is not even close to the center line between the hole and the rest of the image. For more details see <a href="#thinning_skeleton">Thinning Down to a Skeleton</a>. <a name="skeleton2" id="skeleton2"></a>
          <h4>Skeleton:2</h4>The '<code><b>Skeleton:2</b></code>' variant is almost exactly the same as the traditional '<code>Skeleton:1</code>' version. It was found in the <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm">HIPR2 Image Processing Resources</a> documentation.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="center">
                <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:2"  miff:- | \
      montage -label "Skeleton:2 (HIPR2)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton2.gif
</CODE>-->
                <a href="kernel_skeleton2.gif"><img src="kernel_skeleton2.gif" align="middle" border="0" alt="[IM Output]"></a>
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 Skeleton:2   thin_skeleton2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="thin_skeleton2.gif"><img src="thin_skeleton2.gif" width="100" height="125" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>If you compare this with the previous set, you will notice that the internal pixel of the corners have been removed. This will then allow the thinning operation to remove the extra thickening from the diagonals. However this diagonal thinning is not symmetrical, and highly dependant of the shape of the image, and the order in which the kernels are applied. <a name="edge-corner" id="edge-corner"></a> The '<code>Skeleton:2</code>' variant is very closely related to just using a combined '<code><b>Edges;Corners</b></code>' kernel list.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="center">
                <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Edges;Corners"  miff:- | \
      montage -label 'Edges ; Corners' - \
              -background LightSteelBlue -geometry +0+0  kernel_edge-corner.gif
</CODE>-->
                <a href="kernel_edge-corner.gif"><img src="kernel_edge-corner.gif" align="middle" vspace="5" border="0" alt="[IM Output]"></a>
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 'Edges;Corners' thin_edge-corner.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="thin_edge-corner.gif"><img src="thin_edge-corner.gif" width="100" height="125" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The only difference between this and what '<code>Skeleton:2</code>' uses is the ordering of the kernels in the list. Note how the resulting skeleton also differs, even though the same set of kernels was used. This shows that generating skeletons by thinning is actually rather fragile, as just a simple change of order can produce different results in the connected skeleton. <a name="skeleton3" id="skeleton3"></a>
          <h4>Skeleton:3</h4>The '<code><b>Skeleton:3</b></code>' was developed in a formal study of using Thinning Kernels (See <a href="thinse">ThinSE Kernels</a> below), in a research paper "<a href="http://www.leptonica.com/papers/conn.pdf">Connectivity-Preserving Morphological Image Transformations</a>" by Dan S. Bloomberg, 1991. He developed quite a number of such skeletons, and tabled the results of the study. The following is the best one he was able to come up with, that will generate a 4 connected skeleton. However unlike previous skeletons this requires the use of 3 rotated kernels (12 total).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="center">
                <!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:3"  miff:- | \
      montage -label "Skeleton:3 (Bloomberg)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton3.gif
</CODE>-->
                <a href="kernel_skeleton3.gif"><img src="kernel_skeleton3.gif" align="middle" border="0" alt="[IM Output]"></a>
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -channel RG \
          -morphology Thinning:-1 Skeleton:3   thin_skeleton3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="thin_skeleton3.gif"><img src="thin_skeleton3.gif" width="100" height="125" align="middle" vspace="0" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>It should be noted that the first group of rotated kernels contains just a single background pixel. That means this skeleton was able to open up the single pixel hole that is present in the 'man' shape, and produce a center line oriented skeleton. It does not generate too may branches, produces clean smooth lines, and also thins down completely. All in all this is one of the better skeleton thinning kernels. <a name="thinse" id="thinse"></a>
          <h4>ThinSE</h4>The same research paper "<a href="http://www.leptonica.com/papers/conn.pdf">Connectivity-Preserving Morphological Image Thansformations</a>" by Dan S. Bloomberg, actually developed from first principles a complete range of minimal 3x3 'Thinning Structure Elements' that were all designed to preserve either 4-connected line or 8-connected lines. The '<code><b>ThinSE:</b>{<i>type</i>}</code>' kernel set is a list of all those structuring elements, and are listed below sorted into groups based on connectivity and strength in preservation. The '<code>{<i>type</i>}</code>' is a number based on the super-script (connected-ness) and sub-script element numbers used in the research paper. As such kernel '<code><b>ThinSE:41</b></code>' is the first of the 4-connected line preserving elements. You can also add a rotation angle, or generate a set of rotated or mirror-rotated flags to the given kernel definition. <!--<CODE EXECUTE SCRIPT>
  flags="-tile x1 -background LightSteelBlue -geometry +0+0"
  for i in `seq 41 44`; do
      kernel2image -15.1 -m -ml $i  "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Strong 4-connected" - \
      -font ArialB $flags kernel_thinse_4strong.gif

  for i in `seq 45 49`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Weak 4-connected" - \
      -font ArialB $flags kernel_thinse_4weak.gif

  for i in `seq 81 84`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Strong 8-connected" - \
      -font ArialB $flags kernel_thinse_8strong.gif

  for i in `seq 85 89`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Weak 8-connected" - \
      -font ArialB $flags kernel_thinse_8weak.gif

  for i in 423 823; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags -geometry +15+0 miff:- |
    montage -label "Weak, Combined 2 and 3" - \
      -font ArialB $flags -geometry +25+0 kernel_thinse_23comb.gif

  for i in 481 482; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags -geometry +15+0 miff:- |
    montage -label "General 4 & 8 Conection Preserving" - \
      -font ArialB $flags -geometry +25+0 kernel_thinse_48gen.gif
-->
          <div align="center">
            <a href="kernel_thinse_4strong.gif"><img src="kernel_thinse_4strong.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a> <a href="kernel_thinse_4weak.gif"><img src="kernel_thinse_4weak.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a><br>
            <a href="kernel_thinse_8strong.gif"><img src="kernel_thinse_8strong.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a> <a href="kernel_thinse_8weak.gif"><img src="kernel_thinse_8weak.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a><br>
            <a href="kernel_thinse_23comb.gif"><img src="kernel_thinse_23comb.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a> <a href="kernel_thinse_48gen.gif"><img src="kernel_thinse_48gen.gif" align="middle" vspace="2" hspace="20" border="0" alt="[IM Output]"></a>
          </div>The very last '<i>General Thinning Kernel</i>, '<code><b>ThinSE:482</b></code>', you may recognise as the being same kernel used to define the set of <a href="#edge">Edge Detection Kernel</a>. This general kernel is actual the core kernel from which all the other thinning kernels shown above were developed. It is the default kernel of the set. Note that both general kernels '<code>ThinSE:481</code>' and '<code>ThinSE:482</code>' are the only kernels rotationaly related. That is '<code>ThinSE:481x45</code>' is equivalent to '<code>ThinSE:482</code>'. Many of the other built-in HMT kernel sets are actually internally defined in terms of these kernels. For example, the kernel set '<code><b>ThinSE:41 ; ThinSE:42 ; ThinSE:43</b></code>', and its rotated expansion, will produce the 12 kernels used to create the '<code><a href="#skeleton3">Skeleton:3</a></code>' set. This skeleton and was listed in the paper as being the best kernel set found to produce good thinned skeleton. The other skeleton generating thinning kernels are also defined using the above kernels.<br>
          Be warned however that some kernels, such as '<code>ThinSE:44</code>', which while designed to preserve 'connected-ness', does not actually preserve line ends, and as such will cause a skeleton to be pruned down to a single point, or set of connected rings. All the kernels do not define the central origin value, which means you can these 'thinning kernels' are not only for '<a href="#thinning">Thinning Shapes</a>', but also can be used '<a href="#thicken">Thicken Shapes</a>' as well, to generate SKIZ (zones of influence). If you look carefully, you will probably note that each of the 4-connected kernels are actually also present in a negative and 180 rotated form in the 8-connected set, and visa-versa. For example '<code>ThinSE:41</code>' and '<code>ThinSE:84</code>' are negated rotations of each other. The reason is that 4 and 8 connectivity is closely related to each other via the duality of thinning and thicken morphological methods (using negated images). Essentually, a 4-connection preserving 'thinning kernel', which is then used to thicken an image, will result in a 8-connected background skeleton (unpruned SKIZ) around the shape, and visa-versa. So by using the negated forms (so thicken and thin methods are swapped) you can generate the other form of connected-ness for the same operation.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="distance" id="distance"></a>
          <h2>Distance Gradient Morphology</h2>The '<code>Distance</code>' morphology method is the first of the many specialized methods that is possible. What it does is use a specialized kernel to measure the distance of each foreground pixel from the shapes 'edge'. More specially it measures the pixels distance from a 'zero' or 'black' color value. It however only works with pure binary (white on black) shapes, though as you will see later you can modify an anti-aliased shape to work with the distance method. And only with specially designed <a href="#distance_kernels">Distance Kernels</a>. The distance kernel is applied to the image so that each pixel is assigned the smallest pixel value plus the kernel value for that distance. This is applied all over the image simultaneously, using an algorithm that does not require multiple iterations, as we saw in previous morphology methods. Because of this it is about as fast as a single primitive morphological operation, which is blindingly fast compared to say a <a href="#thinning_skeletion">Thinning Skeleton</a> morpholgical method. As it is applied across the whole image, no '<i>iteration</i>' argument is needed, as repeating (iterating) the same kernel operation will result in no further change to the result.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Before IM v6.6.9-4, a '<code>-1</code>' iteration count was needed, as the kernel was applied using a technique similar to a normal <a href="#erode">Erode</a>. This is no longer needed, and any 'iteration' argument given, other than zero (no action), is now simply ignored.</i></font></td>
            </tr>
          </table>Here is an example of using the '<code>Distance</code>' method, on our 'man' shape.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% \
          -morphology Distance Euclidean:4 \
          +depth  distance.png
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance.png"><img src="distance.png" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Well that was real exciting, <font size="+1">NOT</font>! The problem is that the final images color is very very dark. But if you have a good monitor, and can look closely, you may see a very dark 'ghost' like shape where the 'man' was. What happened is that, at least for this small image, all the pixels are 'close' to the edge, and so do not get a very large 'distance' value.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>A PNG image is recommended for any use of the '<code>Distance</code>' method. That is, because it provides can provide greater output value 'depth' than for example GIF, without any color loss like JPEG.<br>
              <br>
              It is also the reason why the <a href="../basics/#depth">Depth Setting</a> "<code>+depth</code>" was used to ensure the output is reset to 16-bit depth (for my Q16 version of IM) even though I read in an 8-bit GIF source image.<br>
              <br>
              For users with a Q8 version of IM, I suggest you read about the 'scale' distance kernel option in <a href="#distance_kernels">Distance Kernels</a> (below) to adjust the 'scaling values' used (see next section below). Using Q8 versions of IM with non-interger distance kernels (like this <a href="#euclidean">Euclidean Distance Kernel</a>) is not recommended, though will produce a less accuriate result.<br>
              <br>
              See IM Examples section on <a href="../basics/#depth">Quality and Depth</a>, for a better understanding of these two aspects.<br>
              <br></i></font></td>
            </tr>
          </table>By default the built-in <a href="#distance_kernels">Distance Kernels</a> will apply a color value of "100 × {<i>pixel_distance</i>}" to each pixel. If a pixel is brighter that this, it is set to that value so that the smallest distance from a pixel to any edge is assigned. The result is that pixels along the very edge of a shape will be assigned a 100 unit value more than background color. The next pixel further in will be given 100 units more. Exactly how many units will be assigned is given by the <a href="#distance_kernels">Distance Kernel</a> that is used. So lets look at the largest color value that was set in the above image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="distance_max.txt">
  magick identify -verbose distance.png | grep max:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="distance_max.txt"><img src="distance_max.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>That is, the largest color value in the resulting image was '<code>1616</code>' making the 'brightest' pixel in the image a very dark 2.5% grey, and its distance from the nearest edge, 16.16 pixels away. In other words, we see a very dark, but not really completely black image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                Lets use the mathematical "<code><a href="../option_link.cgi?auto-level">-auto-level</a></code>" to adjust the resulting color values so the brightest, or most distant pixel from an edge is set to white. This way we can actually see the full effect of the 'distance gradient' generated.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick distance.png -auto-level  distance_man.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
                <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
                  <tr valign="top">
                    <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                    <td align="justify" width="100%"><font size="-1"><i>As we no longer care about the exact 'distance' values generated for this image, just the visible effect of the distance, the image can now be saved and displayed using the GIF image file format.</i></font></td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_man.gif"><img src="distance_man.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This is what the '<code>Distance</code>' method does. Generate a gradient across the given shape defining how far each pixel is from the nearest edge, according to the specific <a href="#distance_kernels">Distance Kernel</a> used.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                Another way of making the resulting 'distance' image brighter is to actually use a larger distance kernel '<i>scale</i>' value, for example a value of 3000 units (Q8 users can probably use a value of 20).
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,3000     distance_scaled.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_scaled.gif"><img src="distance_scaled.gif" width="100" height="125" align="middle" vspace="0" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Note that the distance gradient did not cover from black to white, with it reaching a peak at some grey-scale value. As we already know the 'distance of the peak, we can calculate that maximum peak to be <code>16.16 * 3000 =&gt; 48480</code> or about 74% grey. You can also use a percentage scaling factor, for example use a 8% color range value for each pixel distance from the edge.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,8%    distance_scale_percent.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_scale_percent.gif"><img src="distance_scale_percent.gif" width="100" height="125" align="middle" vspace="0" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see this time we reached our maximum value limit before reaching the maximum distance. You can calculate that maximum distance that the distance gradient can cover is <code>(100% at maximum range) / (8% per pixel) =&gt; 12.5 pixel_distance</code>. Of course if you were using a <a href="../basics/#hdri">HDRI version of ImageMagick</a> the full distance values will be kept in memory, at least until you <a href="../basics/#clamp">Clamp</a> it value, or save it into a non-floating point image file format. You can also directly specify the maximum pixel distance you are interested in by using the special <a href="#distance_scaling_flags">Distance Scaling Flag</a>, '<code>!</code>'.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                As we already know out shape as a maximum distance from edge of 16.16. least request a limit of 18 pixel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,'18!'   distance_range.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_range.gif"><img src="distance_range.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The '<code>!</code>' flag will scale the the distance so as to give 'n' grey-scale values before the color range limit is reached. As such a value of 1 will only 'feather' (or make gray) only the pixels that are a direct neighbour to the edge of the image. As you can see all the scaling methods however depend heavily on the actual size of the shape you are performing the '<code>Distance</code>' method on. Too small and it is very dark and may not be accurate for your needs. Too large and the distance may get 'clipped' by the maximum posible color value of your ImageMagick's <a href="../basic/#quality">Compile Time Quality</a>. For more details on the '<i>scale</i>' factor in the kernel, see <a href="#distance_kernels">Distance Kernel</a> section below. I would like to make one final note about the man-like 'shape' used in these examples. The shape contains a single pixel 'hole' that created a sort of 'gradient well' around it. This results in a very strong effect on upper half of the resulting 'distance gradient' image. One solution to this is to remove that hole, by using '<code><a href="#close">Close</a></code>', so as to make the shape 'clean n smooth'. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -morphology Close Diamond  man_clean.gif
  magick man_clean.gif   -morphology Distance Euclidean \
                                    -auto-level   distance_clean.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_clean.gif"><img src="man_clean.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_clean.gif"><img src="distance_clean.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Of course this also has the effect of also 'closing' the gap between the shapes 'legs' too, which effects the lower half of the final result. An alternative solution is to use a <a href="../color_basics/#floodfill_draw">Floodfill</a> method to extract the outside of the image, and magick that into new mask. The result is that any holes have been closed, but the outside boundary of the image has been preserved. For example..
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -gamma 0,1,1 -bordercolor black -border 1x1 \
          -fill red -floodfill +0+0 black -shave 1x1 \
          -channel R -separate +channel -negate  man_floodfill.gif
  magick man_floodfill.gif    -morphology Distance Euclidean \
                                    -auto-level   distance_floodfill.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_floodfill.gif"><img src="man_floodfill.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_floodfill.gif"><img src="distance_floodfill.gif" width="100" height="125" align="middle" vspace="2" hspace="15" border="1" alt="[IM Output]"></a>
          </div><a name="distance_kernels" id="distance_kernels"></a>
          <h3>Distance Kernels</h3>The kernel given is very special, as it is used to define the actual distance measurements that is to be assigned to each pixel. For example, here the <a href="#showkernel">Show Kernel</a> output of one of the built-in 'Distance Kernels'.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_chebyshev_3.txt">
  magick xc: -define morphology:showkernel=1 -precision 3 \
          -morphology Distance:0 Chebyshev:3     null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_chebyshev_3.txt"><img src="k_chebyshev_3.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>The important thing to note is that the 'origin' (in this case the exact center of the kernel) has a value of zero. This is very important. That 'origin' is then surrounded by larger values, which increase linearly with greater distance from that 'origin'. If the kernel is not defined in this specific way, unexpected and strange effects may result. The value given in the kernel is the actual 'value' that will be added to an already 'known' distance, assigned to a pixel if that value is smaller than what is already assigned. The result is that 'white' pixels are made darker the closer they are to an edge, and linearly brighter (adding to previously assigned values) the further it gets from the edge. All the provided built-in Distance kernels can take two optional <i>k_arguments</i>...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
     {<i>distance_kernel</i>}[:{<i>radius</i>}[,{<i>scale</i>}[%][!]]]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The first argument like all the <a href="#kernels">Shape Kernels</a> is the kernels <i>radius</i> which defines how big to make the generated kernel. By default the <i>radius</i> is set to '<code>1</code>' for the built-in distance kernels, resulting in a very small 3 by 3 kernel, which in most cases works quite well. The second argument '<i>scale</i>' sets the distance scale used to represent the distance of one pixel length. As shown in the example above it defaults to a value of '<code>100</code>'. That is, a pixel which is given a final pixel or grey-scale value of say '<code>300</code>' should be exactly '3 pixels' away from the edge. <a name="distance_scaling" id="distance_scaling"></a> <b>Distance Scaling</b>As mentioned previously, a large '<i>scale</i>' value is used so that you can use 'fractional' distances for more 'exact' distance measurements. However only the provided '<code><a href="#euclidean">Euclidean</a></code>' distance kernel uses such 'fractional' values. In the previous examples, the 'largest distance' value assigned was '<code>1700</code>', which would overflow a Q8 version of ImageMagick (See <a href="../basic/#quality">Quality, in memory bit depth</a>). An IM Q8, only allows color values to reach a maximum value of 255 (2<sup>Q</sup> =&gt; 2<sup>8</sup> =&gt; 256 color values, ranging from 0 to 255). As such using a smaller <i>scale</i> such as '<code>10</code>' or '<code>20</code>' will work better for users using the IM Q8 compile time variant. Though it is far less accurate when used with a '<code><a href="#euclidean">Euclidean</a></code>' kernel. Because of this it is recommended that user with Q8 versions of IM, restrict themselves to using the other 'integer' distance kernels, with a scale factor of '<code>1</code>'. <a name="distance_scaling_flags" id="distance_scaling_flags"></a> You can also specify the distance scaling as a percentage of the full color range by including a '<code>%</code>' in the scaling factor. That means if you use a scale of '<code>12.5%</code>' of the color value range, then you will be able to get a distance metric of about 8 pixels before the distance overflows the color range limits of the IM version you are using. Alternatively you can instead use a '<code>!</code>' which means the scale is a divisor of the color range. That is, if you specify a scale of '<code>20!</code>' the distance scaling will be set so that the color range limit will be reached 20 pixels from the edge of the image. However even with these 'special scaling flags' you will still have severe range accuracy limitation in Q8 versions of IM. It just does not have the range for the data values needed for may distance operations. Of course any <i>scale</i> (including full floating point) can be accurately used for a <a href="../basic/#hdri">HDRI</a> versions of IM, as the resulting color values are also stored as floating-point values. Just be sure to rescale the color range appropriately before attempting to save such an image to non-floating point image file formats.<br>
          A number of different distance measuring kernels are provided, with one that can be used in a two different ways. Each kernel provides to with different resulting 'distance metrics' for specifying the pixel distance from the edge, and basically define what is to be considered the 'nearest edge'. <a name="chebyshev" id="chebyshev"></a>
          <h4>Chebyshev (Chessboard) Distance Kernel</h4>The '<code><b>Chebyshev</b></code>' distance kernel is the simplest, and specifies that all pixel around the 'origin' is simply 1 distance unit from its neighbours. That is, all 8 neighbours are 'next' to each other. As such only are the immediate four neighbours a distance of 1 unit, but the diagonal neighbours are also exactly 1 unit away. This is often likened to the distance in squares that a 'King' or 'Queen' chess piece moves of a chessboard, and hence is often also known as a '<i>Chessboard</i>' distance metric. Note however that distance kernels have use a default <i>{scale}</i> factor of 100 distance units, per pixel of distance. As such the distance is 100 units for every step away from the origin. This was also the kernel that was used in the previous examples above. Here is the actual kernel it generates...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_chebyshev.txt">
  magick xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Chebyshev       null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_chebyshev.txt"><img src="k_chebyshev.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>The name of this kernel is that of the Russian mathematician Pafnuty Chebyshev who first mathematically described this form of distance measurement. You can find out more about this measure on <a href="http://en.wikipedia.org/wiki/Chebyshev_distance">Wikipedia, Chebyshev Distance</a>. Using a '<code>Chebyshev</code>' distance measure, the final distance of a pixel is the largest X or Y value to the closest edge. However as the diagonal distance is only 1 unit, the maximum distance within an image is usually smaller than you would expect. Lets generate a 'distance gradient' using this kernel 'metric'. However so we can see what is going on lets use a slower '<code>Iterative Distance</code>' morphology method using an infinite iteration count.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="chebyshev_distance.txt" err="chebyshev_gradient.txt">
  magick man.gif -threshold 50% +depth \
          -define debug=true -morphology IterativeDistance:-1 Chebyshev \
          chebyshev_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' chebyshev_gradient.png
  magick chebyshev_gradient.png -auto-level chebyshev_gradient.gif
  rm chebyshev_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="chebyshev_gradient.gif"><img src="chebyshev_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="chebyshev_gradient.txt"><img src="chebyshev_gradient.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a><br>
                      <a href="chebyshev_distance.txt"><img src="chebyshev_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The '<code>Iterative Distance</code>' morphology method calculates distance by applying the distance kernel repeatally until no more changes in value are seen.<br>
              <br>
              This is much slower than the more normal '<code>Distance</code>' method, which uses a two pass method to set the distance across the image as a whole. However the verbose output of '<code>Distance</code>' method is far less interesting.<br>
              <br></i></font></td>
            </tr>
          </table>I turned on the <a href="#verbose">Verbose</a> flag so that the command will output how many pixels were changed (all white pixels) by the operation, during each interation (pass) through the image. Then I extracted the 'maximum' distance generated ('<code>1400</code>'), before adjusting the result (normalizing) into an image where you can see the resulting gradient. The maximum distance '<code>1400</code>', is value of the brightest pixels in the image (actually it is a cluster of 4 such pixels). This information is the most important result of this distance kernel (metric), as it represents the size of the largest square that will fit within this shape. Specially 14 pixel radius or a square of approximately (R-1)*2+1 =&gt; 27 pixels per side, centered on those 4 maximum pixels. As all the distances units in this kernel are always multiples of '100' then this final distance value should always be a multiple of '100', and will never have any fractional component. Basically this kernel will produce an integer distance, and you can a simple '1 unit' <i>scale</i> with this kernel without loss of any distance information. This is recommended if you are using a <a href="../basics/#quality">Q8 version of ImageMagick</a>, or are applying this to very very large images.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient between the shapes 'legs' which highlights the features of the distance gradient generated.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick chebyshev_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% chebyshev_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="chebyshev_magnify.gif"><img src="chebyshev_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the '<code><a href="#chebyshev">Chebyshev</a></code>' distance kernel produces a very square like gradient. This is a specific feature of this simple form of distance metric, and directly reflect the square nature of the distance kernel itself. The above also shows the 4 maximum distance pixels in the figures 'belly' close to the top of the image. By centering a square on any of these 4 point you can generate the largest odd sized square that is wholly contained within the figure. However be warned that there may be a number of such 'peaks'. <a name="manhattan" id="manhattan"></a>
          <h4>Manhattan (Taxi Cab) Distance Kernel</h4>The '<code><b>Manhattan</b></code>' distance kernel, measures the distance by adding the X and Y values to the closest edge. It is basically the distance you need to travel when you are restricted to only grid-like movements, such as a taxi cab on the streets of large cities like Manhattan, New York. Because of this other more common names for this measure is '<i>Taxi Cab</i>' or '<i>City Block</i>' distance metric. You can find out more on <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Wikipedia, Manhattan Distance</a>. Here is the actual kernel it generates...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_manhattan.txt">
  magick xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Manhattan     null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_manhattan.txt"><img src="k_manhattan.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Note that the diagonals now have a value of '200' or 2 units from the center. That is, to reach a diagonal pixel you would have to travel through two pixels in the gird-like movements mentioned. As a result of this, diagonals tend to be larger than expected, as such the final distance measurements also tends to be larger. Lets again get extract the maximum distance and the 'distance gradient' image using this 'metric'.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="manhattan_distance.txt">
  magick man.gif -threshold 50% +depth \
          -morphology Distance Manhattan      manhattan_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' manhattan_gradient.png
  magick manhattan_gradient.png -auto-level manhattan_gradient.gif
  rm manhattan_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="manhattan_gradient.gif"><img src="manhattan_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="manhattan_distance.txt"><img src="manhattan_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>I did not use '<code>Iterative Distance</code>' this time, and even if I did the total count of pixels changed would not be accurite. Only the previous '<code><a href="#chebyshev">Chebyshev</a></code>' kernel will set a pixel distance once and only once. Note how the final maximum distance for the image is much larger, at '<code>1700</code>' distance units, making the maximum pixel(s) within the shape 17 pixels from the edge. This distance kernel is also a 'integer' kernel and as such you can set the <i>scale</i> to just '1 unit' without loss of information.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick manhattan_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% manhattan_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="manhattan_magnify.gif"><img src="manhattan_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the '<code><a href="#manhattan">Manhattan</a></code>' distance kernel generated a diamond-like gradient, which is basically what this simple distance metric represents, as eflected by the actual kernel values. <a name="octagonal" id="octagonal"></a>
          <h4>Octagonal Distance Kernel</h4>The '<code><b>Octagonal</b></code>' distance kernel is a little different than the other two. It is created by generating first a <a href="#manhattan">Manhattan</a> distance for the pixels on the very edge, then using <a href="#chebyshev">Chebyshev</a> for the pixels that are 2 units distance from the edge. It then repeats using <a href="#manhattan">Manhattan</a> distance for the 3 unit distance pixels, and so on. The result is an 'interleaving' or 'averaging' of distance resulting from using the two simpler kernels. As this kernel is based on an interleaving of two integer distance kernels, it is also an integer distance kernel. As such a <i>scale</i> of '1 unit' can be used to produce smaller values, for lower quality ImageMagick versions, or very large distance measurements. The distance shape is also a mixture of the two kernels and as such produces a the equivalent of the '<code><a href="#octagon">Octagon</a></code>' shaped kernel. Here is the actual kernel it generates...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_octagonal.txt">
  magick xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Octagonal     null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_octagonal.txt"><img src="k_octagonal.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Note that the kernel has a minimum and default size of radius 2, forming a 5x5 pixel kernel. This slightly bigger kernel is needed to generate the 'interleaving' of the kernels. The overall distance will generally be very slightly smaller than a true distance. Here we again calculate the maximum distance...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="octagonal_distance.txt">
  magick man.gif -threshold 50% +depth \
          -morphology Distance Octagonal  octagonal_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' octagonal_gradient.png
  magick octagonal_gradient.png -auto-level octagonal_gradient.gif
  rm octagonal_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="octagonal_gradient.gif"><img src="octagonal_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="octagonal_distance.txt"><img src="octagonal_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The result of '<code>1500</code>' is an 'integer' distance, and actually falls between the too-small Chebyshev Distance, and the too-large Manhattan Distance. However in general it should be reasonably close to the real actual distance to the center of the shape, while remaining an 'integer' value.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick octagonal_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% octagonal_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="octagonal_magnify.gif"><img src="octagonal_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can clearly see the 'octagonal' distances that have developed around the top of the leg gap. You can also see that the diagonal was generated using an interleaving of thick and thin diagonal lines. <a name="fractional_octogon" id="fractional_octogon"></a>
          <h4>Fractional Octogon Distance Kernel</h4><i>A named distance kernel has not been provided. But it fits into the distance kernel sequence we are studing nicely at this point.</i> You can generate another type of integer distance kernel using an octagonal shape. However the integer distance in this case uses an unit value of 2 per pixel, so really the distance values generated needs to be halved, generating a frational value from the small integers that are generated. This the name "Fractional Octogon". To do this we use an integer distance of 2 between neighbouring pixels, and 3 for the diagonal.
          <pre>'3: 3,2,3
    2,0,2
    3,2,3'</pre>As 'half integers' can be generated the smallest minimal scale that can be used is '2 units'. and while not as accurate a 'knights move' it does work well. The octogon of this kernel has 'points' in the orthogonal direction, rather than 'flats' as the previous kernel generates. It is related to, but not quite the same as the next 'Knights Move' kernel, and could be considered a sort of 'near integer' form of the '<code>knights</code>' kernel. If you want to scaling this the same as previous IM distance kernels you can use. this kernel.
          <pre>'3: 150,100,150
    100, 0 ,100
    150,100,150'</pre>Here is an example
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="fractional_distance.txt">
  magick man.gif -threshold 50% +depth \
          -morphology Distance '3:3,2,3 2,0,2 3,2,3' \
          fractional_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' fractional_gradient.png
  magick fractional_gradient.png -auto-level fractional_gradient.gif
  rm fractional_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="fractional_gradient.gif"><img src="fractional_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="fractional_distance.txt"><img src="fractional_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The result of '<code>34</code>' is an 'integer' distance, but needs to be divided by 2 to produce an actual maximum distance result of 17. however while this is also an integer, it could just as easilly come out as being a fractional distance of 16.5. This fractional aspect of distance results is why most kernels are defined using units of 100, and will in later kernels become more prevelent as we move away from purely integer distance kernels.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick fractional_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% fractional_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="fractional_magnify.gif"><img src="fractional_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                The gradient (if you study the results carfully) is an octagonal shape. But it is hard to see the pixels that have common distance values. To see the shape more clearly, I have taken the above image and colored one set of pixels with the same color value, red.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick fractional_magnify.gif -fill red -opaque gray53 \
          fractional_magnify_shape.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="fractional_magnify_shape.gif"><img src="fractional_magnify_shape.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see pixels of the same value are generally separated in a 'knight's move' pattern, but form lines that generate an octagonal shape. The octogon is however rotated 45 degrees from the <a href="octagonal">Octagonal Distance Kernel</a> It is also this shape difference that causes the final maximum distance to be larger. Essentually a larger octagon rotated in this way fits into the shape better, thus the larger maximal distance result. Another fractional distance 'interger' kernel that can be used is this one, though the distance is in terms of 3 units instead of 2. That is, the results need to be divided by 3 to get the distance in terms of pixel size, which is not really a great divisor to use. It is however another octagonal type distance metric.
          <pre>'3: 4,3,4
    3,0,3
    4,3,4'</pre>The <a href="#knight">Euclidean (Knights Move) Distance Kernel</a> below also generates an octagonal style of shape (all 3x3 distance kernels do), but tries to be as accurite as posible along the diagonals. This may or may not be the best idea, but it is the most mathematically logical octagonal distance kernel of this type. <a name="chamfer" id="chamfer"></a>
          <h4>Chamfer Distance Kernels</h4><i>A named distance kernel has not been provided. But it fits into the distance kernel sequence we are studing nicely at this point.</i> A 'Chamfer' Distance kernel (not yet implemented), is defined using just the numbers (typically integers) that is to be used to fill in the distance matrix. You can for example give it 2 numbers to define any 3x3 'octagonal' type distance kernel, as described above. Here are the definitions of the pervious interget kernels,
          <table align="center">
            <tr>
              <td>Chebyshev</td>
              <td>Chamfer:1,1</td>
            </tr>
            <tr>
              <td>Manhattan</td>
              <td>Chamfer:1,2</td>
            </tr>
            <tr>
              <td>Fractional Octagon &nbsp;</td>
              <td>Chamfer:2,3 &nbsp;</td>
              <td>&nbsp; /2</td>
            </tr>
          </table>
          <table>
            <tr>
              <td>Fractional Octagon Alturnative &nbsp;</td>
              <td>Chamfer:3,4 &nbsp;</td>
              <td>&nbsp; /3</td>
            </tr>
          </table>All these kernals are simple radius 1 kernels. The values give can be regarded as the actual 'distance scaling' values it should be using. Note however that the previous Integer <a href="#octagonal">Octagonal</a> kernel requires a 3 number radius 2 Chamfor Kernel to define it. The most well known Chamfer kernel is as radius 2 kernel, 'Chamfer:5,7,11', which generates a very accurate distance, and also generates an integer distance values making it well suited for Q8 users. Traditionally the kernel (chamfor 5,7,11) is of the form...
          <pre>'5:  -   11   -   11   -
    11    7   5   7    11
     -    5   0   5    -
    11    7   5   7    11
     -   11   -   11   -'</pre>OR multiply the above by 20, to produce the same pixel distance scaling (100) used normally by ImageMagick for distance kernels....
          <pre>'5:  -   220   -   220   -
    220  140  100  140  220
     -   100   0   100   -
    220  140  100  140  220
     -   220   -   220   -'</pre>Note how the kernel does not actually fill in ALL the kernel distances. That is because those values will get their distances from the other values already provided. that is you don't actually need to fill out the whole 2-diamentional array to fully define a distance kernel, though it is typically done for easier processing. Here is a list of other known Chamfer kernels (only using integer values) that I have found in my research.
          <table align="center">
            <tr>
              <td>Chamfer:3,4 &nbsp;</td>
              <td>&nbsp; /3</td>
            </tr>
            <tr>
              <td><b>Chamfer:5,7,11</b> &nbsp;</td>
              <td>&nbsp; /5</td>
            </tr>
            <tr>
              <td>Chamfer:99,141,221 &nbsp;</td>
              <td>&nbsp; /100</td>
            </tr>
            <tr>
              <td>Chamfer:987,1414,2206 &nbsp;</td>
              <td>&nbsp; /1000</td>
            </tr>
            <tr>
              <td>Chamfer:12,17,27,38,43 &nbsp;</td>
              <td>&nbsp; /12</td>
            </tr>
          </table>
          <div align="center">
            <font size="-2"><img src="../img_diagrams/chamfor_values.png" width="100" height="100" border="0" hspace="0" vspace="0" alt="[diagram]"><br>
            How 5 values are placed to define a radius 3 Chamfor kernel</font>
          </div>The kernel highlighted in the above table is the most well known and commonly used Chamfor Distance Kernel. It generates image using only small integer values, as such the large distance gradent images can be stored without loss of precision. It is also very accurite, at least enough for just about every imaginable purpose. As a bonus the distance results do not create recursive decimal places just a single digit fraction when normalized. This is another reason why it is often selected by many image processing packages. <i>The "Chamfer:5,7,11" should be regarded as the default "Chamfor" Distance kernel.</i> <a name="knight" id="knight"></a>
          <h4>Euclidean (Knights Move) Distance Kernel</h4>The '<code><b>Euclidean</b></code>' kernel is generated using exact floating point distance numbers. But to make this work with non-HDRI versions of ImageMagick requires the use of a fractional diagonal distances. Such as the diagonal which has a value of the square root of 2, a value of about 1.4142 distance units. To allow this to work the distances are scaled by a value of 100 (as in all the above kernels), to produce a fractional percentage distance. Here is the default kernel it generates...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_knight.txt">
  magick xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Euclidean    null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_knight.txt"><img src="k_knight.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Now by using the default <i>radius</i> of 1, while a big improvement on the previous kernels in terms of accuracy, still has some limitations. Basically, it provides a distance in terms of just 45 degree diagonals and orthogonal (X and Y) moves. That is, the distances are somewhat like a '<i>Knight's Move</i>' in the game of chess. Here is the maximum distance and the 'distance gradient' image that was created using the default '<code>Euclidean</code>' or 'Knight Move' kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="knight_distance.txt">
  magick man.gif -threshold 50% +depth \
          -morphology Distance Euclidean    knight_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' knight_gradient.png
  magick knight_gradient.png -auto-level knight_gradient.gif
  rm knight_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="knight_gradient.gif"><img src="knight_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="knight_distance.txt"><img src="knight_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>As you can see for this specific shape, you also get a distance value of '<code>1700</code>' distance units. Normally the result would be some fractional distance, between the smaller '<code><a href="#chebyshev">Chebyshev</a></code>' distance, or the larger '<code><a href="#manhattan">Manhattan</a></code>' distance. It is just plain luck that it came out as a simple multiple of '<code>100</code>' and that it also happened to be the same as the '<code><a href="#manhattan">Manhattan</a></code>' distance. The actual distance to a pixel is actually the sum of the diagonal distance, plus the orthogonal (axis) distance. That is, not quite a perfect Euclidean distance, but it is the closest to it you can get while using the smallest distance kernel posible (of radius 1).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient between the shapes 'legs'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick knight_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% knight_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="knight_magnify.gif"><img src="knight_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the gradient has a much more rounded look to it, without the onion-like 'levels' or 'terraces' effect that you get in a 'integer' distance kernel. This is because each pixel is more likely to be assigned individual fractional distance from the edge. The final shape of the gradient however is actually roughly 'octagonal' in shape, though with points like a compass, rather than flats top and bottom as you get with the previous '<code><a href="#octagonal">Octagonal</a></code>' distance kernel. For general distance work (such as 'feathering') this default '<code>Euclidean</code>' or 'Knights Move' kernel provides a good result. However as you do not get 'integer' distances, you can not use this using a distance scale factor of '<code>1</code>', making it less useful for Q8 versions of ImageMagick. <a name="euclidean" id="euclidean"></a>
          <h4>Larger Euclidean Distance Kernel</h4>By increasing the '<i>radius</i>' of the generated '<code>Euclidean</code>' kernel and you produce an even more accurate 'Pythagorean' or true 'Euclidean' distance metric. The larger the <i>radius</i> the more accurate the result, but it will take longer for the morphological '<code><a href="#distance">Distance</a></code>' method method to run, though fewer such iterations will be needed. Beyond a radius of 4 however you will not get much more accuracy, but you will get a much greater loss of speed. See <a href="#distance_anti-alias">Distance with an Anti-Aliased Shape</a> below for some examples of using very large '<code>Euclidean</code>' kernels to improve accuracy. Here is a true '<code>Euclidean</code>' kernel using the recommended radius of 4, which generates a larger 9×9 kernel...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="k_euclidean.txt">
  magick xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Euclidean:4     null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="k_euclidean.txt"><img src="k_euclidean.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>The added advantage of using a radius of 4 is that the kernel also contains the Pythagorean Triangle, which has sides 3,4,5, or with the default kernel scale, units of 300,400,500. Though this can reduce the number of fractional components in the resulting image, it is really only a minor effect. Still it is a logical choice for more accuracy. Here is its application...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" out="euclidean_distance.txt">
  magick man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4     euclidean_gradient.png

<br>  magick identify -format 'Maximum Distance = %[max]' euclidean_gradient.png
  magick euclidean_gradient.png -auto-level euclidean_gradient.gif
  rm euclidean_gradient.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="euclidean_gradient.gif"><img src="euclidean_gradient.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="euclidean_distance.txt"><img src="euclidean_distance.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>As a result of using this larger radius '<code>Euclidean</code>' kernel, the final maximum distance is the most accurate maximum distance measurement yet. It also makes in unlikely for you to get more than one 'brightest' pixel in the image, unless the shape is very regular.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here is an magnification of the gradient between the shapes 'legs'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick euclidean_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% euclidean_magnify.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="euclidean_magnify.gif"><img src="euclidean_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the gradient produces a near-perfect circular gradient around the end of the 'leg gap'. The cost of using this kernel is as I said above, a marginally slower running time. <a name="distance_compare" id="distance_compare"></a>
          <h4>Comparison of Distance Kernels</h4>Here again is a side-by-side comparison of the magnifications. This clearly shows the very different gradients generated by each of each of the four distance metrics used.
          <div align="center">
            <table border="0" cellspacing="5" cellpadding="5" width="90%">
              <tr valign="top">
                <td align="center">
                  <a href="chebyshev_magnify.gif"><img src="chebyshev_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a><br>
                  Chebyshev<br>
                  <font size="-1">(Chessboard)</font>
                </td>
                <td align="center">
                  <a href="manhattan_magnify.gif"><img src="manhattan_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a><br>
                  Manhattan<br>
                  <font size="-1">(Taxi Cab)</font>
                </td>
                <td align="center">
                  <a href="octagonal_magnify.gif"><img src="octagonal_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a><br>
                  Octagonal<br>
                  <font size="-1">(Mixed)</font>
                </td>
                <td align="center">
                  <a href="knight_magnify.gif"><img src="knight_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a><br>
                  Euclidean<br>
                  <font size="-1">(Knights Move)</font>
                </td>
                <td align="center">
                  <a href="euclidean_magnify.gif"><img src="euclidean_magnify.gif" width="125" height="100" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a><br>
                  Euclidean<br>
                  <font size="-1">(radius=4)</font>
                </td>
              </tr>
            </table>
          </div>Here is another comparision this time getting the distance away from a single black pixel close to the lower left corner, without any magnification of the pixels.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="">
  magick -size 100x100 xc: -draw 'point 20,80'  distance_start.png

  for kernel in chebyshev manhattan octagonal euclidean euclidean:2 euclidean:4
  do
    magick distance_start.png    -morphology Distance $kernel \
            -auto-level  point_$kernel.png
  done
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%">
              <tr valign="top">
                <!--
<TD ALIGN=center>
  <A HREF="distance_start.png"
     ><IMG SRC="distance_start.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif"   WIDTH=20 HEIGHT=20
       ALIGN=middle VSPACE=45 HSPACE=5 BORDER=0 ALT="==>">
</TD> -->
                <td align="center">
                  <a href="point_chebyshev.png"><img src="point_chebyshev.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Chebyshev<br>
                  <font size="-1">(Chessboard)</font>
                </td>
                <td align="center">
                  <a href="point_manhattan.png"><img src="point_manhattan.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Manhattan<br>
                  <font size="-1">(Taxi Cab)</font>
                </td>
                <td align="center">
                  <a href="point_octagonal.png"><img src="point_octagonal.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Octagonal<br>
                  <font size="-1">(Mixed)</font>
                </td>
                <td align="center">
                  <a href="point_euclidean.png"><img src="point_euclidean.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Euclidean<br>
                  <font size="-1">(Knights Move)</font>
                </td>
                <td align="center">
                  <a href="point_euclidean:2.png"><img src="point_euclidean_2.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Euclidean<br>
                  <font size="-1">(radius=2)</font>
                </td>
                <td align="center">
                  <a href="point_euclidean:4.png"><img src="point_euclidean_4.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  Euclidean<br>
                  <font size="-1">(radius=4)</font>
                </td>
              </tr>
            </table>
          </div>These images clearly shows the lines along which pixels are thought to be closer to the starting pixel than you probably expect, and how the various kernels become smoother as they get more complex. Only the last shows no visible lines of 'closer pixels', but even at radius 4 they are present. For this kernel the lines only appear at a great distance from the source. A radius 7 produces even better results, but at a great cost in speed, though sometimes such accuracy is needed to avoid artifacts in the resulting image. Remember only the first three kernels will produce integer distances, which can be used on a Q8 version of ImageMagick (with appropriate scale adjustment, see the individual kernel description). And it is these that are typically what many image processing packages will use. Calculating distance from a single point will be looked at again later in <a href="#distance_constrainted">Constrainted Distance</a> examples below. <a name="distance_user" id="distance_user"></a>
          <h4>Special User defined Distance Kernels</h4>You are not limited to the distance kernels that have been provided for you. As long as you stick to the rules, of using a zero value at the 'origin', and an increasing distance value surrounding it, you can generate other very interesting distance effects.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example, here I apply a very small <a href="#user">User Defined Kernel</a> that simply says make any pixel to the right larger in value.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% +depth \
          -morphology Distance  '2x1+0+0: 0,100 ' \
          -auto-level    distance_linear.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_linear.gif"><img src="distance_linear.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Notice the effect of the gap between the legs, which 'resets' the slowly increasing gradient that it generates.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                And here I create a distance gradient from just the two sides, but with different scales for each side!
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -threshold 50% +depth \
          -morphology Distance  '3x1: 50,0,100 ' \
          -auto-level    distance_sides.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distance_sides.gif"><img src="distance_sides.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>These is just some examples of distance kernel variants that are possible. Can you think of others, please let me know. Note if your image comes out bad, your kernel origin setting is probably wrong, or the origin was not a 'zero' value. This is not checked for by the morphology distance function. <a name="distance_anti-alias" id="distance_anti-alias"></a>
          <h3>Distance with an Anti-Aliased Shape</h3>The Distance method works very well. But the best test of its functionality is to apply the distance function to a circle, and then <a href="../transform/#shade">Shade</a> it so as to highlight even the smallest error that may be generated by the function.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 129x129 xc: -draw 'circle 64,64 60,4' \
          -negate  circle_shape.png

  magick circle_shape.png  -morphology Distance Euclidean:4 \
          -auto-level cone_distance.png

  magick cone_distance.png -shade 135x30 -auto-level \
          +level 10,90%  cone_distance_shade.png
</samp></pre>
                </td>
              </tr>
            </table><a href="circle_shape.png"><img src="circle_shape.png" width="129" height="129" align="middle" vspace="10" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="cone_distance.png"><img src="cone_distance.png" width="129" height="129" align="middle" vspace="10" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="cone_distance_shade.png"><img src="cone_distance_shade.png" width="129" height="129" align="middle" vspace="10" hspace="2" border="1" alt="[IM Output]"></a>
          </div>You can see from the above that while you do get a 'conical' looking result, it is far from the smooth 'cone'. It is covered by a network of radial ridges starting at the edges. If closely looking at the edge of the shaded cone, you will see that the cone does not have a smooth circular base of the original shape. It is highly 'aliased' or 'stair-cased', and it is these 'steps' that are being reflected by the distance function to form the radial ridges that is seen. The problem is that the distance method has no idea about the small 'grey' anti-aliasing pixels the circle uses around the edge to give it that smooth look. In fact any 'grey' pixel is generally being thought of as a whole pixel rather than the anti-aliased partial edge pixel they represent.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                What we need to do is somehow include those grey edge values in the result, and this is done using a pre-processing step before the distance method is applied.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick circle_shape.png  -gamma 2 +level 0,100 -white-threshold 99 \
          -morphology Distance Euclidean:4   -auto-level \
          -shade 135x30 -auto-level +level 10,90%   cone_antialiased.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="cone_antialiased.png"><img src="cone_antialiased.png" width="129" height="129" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>What was done was to first magick all those grey pixels from a representation of how much of the pixel was inside the circle boundary, to a representation of how far the pixel was from the edge of the circle. As you can see from the result almost all the staircase edge errors have been fixed. The final errors that are visible only occur away from the edge, and become more visible toward center of the 'cone'. They are caused by the iteration of the distance function, every 4 pixel (the size of the euclidean distance kernel) over and over. As such the minor inaccuracies become enhanced as we get further from the edge.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                This is typically not a problem in most situations, but you can reduce, or possibly even eliminate even those small errors by using a larger Euclidean kernel, so as to produce a much more accurate and smoother result. However this does take longer to generate.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick circle_shape.png  -gamma 2 +level 0,100 -white-threshold 99 \
          -morphology Distance Euclidean:7   -auto-level \
          -shade 135x30 -auto-level +level 10,90%   cone_improved.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="cone_improved.png"><img src="cone_improved.png" width="129" height="129" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The result is an almost perfect distance function for an anti-aliased or smooth shape. Here is another example, this time using the two <a href="#distance_user">User Defined Distance Kernels</a> from the previous section.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   magick circle_shape.png -gamma 2 +level 0,100 -white-threshold 99 \
           -morphology Distance  '2x1+0+0:0,100'  -auto-level \
           circle_gradient.png

   magick circle_shape.png -gamma 2 +level 0,100 -white-threshold 99 \
           -morphology Distance  '3x1:50,0,100'  -auto-level \
           circle_ridge.png
</samp></pre>
                </td>
              </tr>
            </table><a href="circle_gradient.png"><img src="circle_gradient.png" width="129" height="129" align="middle" vspace="2" hspace="25" border="1" alt="[IM Output]"></a> <a href="circle_ridge.png"><img src="circle_ridge.png" align="middle" vspace="2" hspace="25" border="1" alt="[IM Output]"></a>
          </div>Without the special handling for anti-alised pixels, the above would not produce such a smooth gradient across the image. As it is we still need to restore the 'shape' of the original shape. <a name="distance_feather" id="distance_feather"></a>
          <h3>Feathering Shapes using Distance</h3>The above technique can be applied to the Alpha Channel of a shape so as to properly 'feather' the object. For example, here is a 10 pixel 'smoothed' feather around an shaped object.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   magick rose_orig.png \
           \( +clone -fill black -colorize 100% \
              -fill white -draw 'circle 114,75 110,2' \
           \) -alpha off -compose CopyOpacity -composite \
           -trim +repage rose_shape.png

   magick rose_shape.png \
           \( +clone -alpha extract -virtual-pixel black \
              -gamma 2 +level 0,100 -white-threshold 99 \
              -morphology Distance Euclidean:4,10! \
              -sigmoidal-contrast 3,0% \
           \) -compose CopyOpacity -composite \
           rose_feathered.png
</samp></pre>
                </td>
              </tr>
            </table><a href="rose_shape.png"><img src="rose_shape.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="rose_feathered.png"><img src="rose_feathered.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>This will preserve ALL edges exactly, unlike the simpler <a href="../blur/#feathering">Blurred Feathering</a> technique. I could have applied the above directly against the alpha channel except that some operators do not treat the transparency channel as 'alpha values' but as 'opacity values' (specifically "<code><a href="../option_link.cgi?white-threshold">-white-threshold</a></code>" operator). As such I extracted the alpha channel so as to handle it as a grey-scale image, before merge it back into the final image. The special distance kernel will do three iterations of a 4 pixel <a href="#euclidean">Euclidean Kernel</a>, to generate enough of a distance gradient close to the edge of the shape. The "<code><a href="../option_link.cgi?level">-level</a></code>" operator then magick that into a linear gradient form the edge ('<code>0</code>') to 10 pixels ('<code>1000</code>' units) into the shape.. The "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" setting is also provided to ensure the any shape that touches the edge of the rectangular image container is also thought to be surrounded by transparency. The result of the distance function in this case is a 'linear ramp' or 'bevel' which can produce some sharp looking effects. As such an a small "<code><a href="../option_link.cgi?sigmoidal-contrast">-sigmoidal-contrast</a></code>" modification will smooth this transition from transparency to opaque. The higher the strength ('<code>3</code>' in the above) the sharper the feathering will be at the edge. If you like to have the feather 'taper' more smoothly into transparency, replace the '<code>0%</code>' in the above code, with '<code>50%</code>' to place the 'shoulder' of the sigmoidal curve in the middle of the 10 pixel feather. <a name="distance_feather_bitmap" id="distance_feather_bitmap"></a> <b>Bitmap Shape Feathering</b>If the shape is a bitmap, such as from a GIF image, or a <a href="../masking/#masks">Image Masks</a>, then you can simplify the above feathering operation. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick figure.gif -channel A -virtual-pixel transparent \
          -morphology Distance Euclidean:4,3!  boolean_feathered.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/figure.gif"><img src="../images/figure.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="boolean_feathered.png"><img src="boolean_feathered.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The key changes is that you don't have far less pre- and post-processing the distance function you can simply specify a special distance unit using '<code>3!</code>'. Which will generate a 3 pixel linear gradient around the edge of the shape. Another example of this type of feathering (a larger 'linear feather') can be seen in <a href="../thumbnails/#soft_edges">Thumbnails, Soft Edges</a>. You can use "<code><a href="../option_link.cgi?sigmoidal-contrast">-sigmoidal-contrast</a></code>" operator in the above to smooth out larger feathers, but be warned that at this time it processes transparency as 'matte' values rather than alpha values. as such a value of '<code>100%</code>' should be used instead of '<code>05</code>' in the previous solution. For bitmap shapes, it may be better to apply a "<code>-blur 1x0.7</code>" to the alpha channel, to smooth it slightly, before applying the previous, more complex distance feather to those results.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="conditional" id="conditional"></a>
          <h2>Conditional or Constrained Morphology</h2>Here we look at techniques where the repeated morphology operations are constrained or limited to a particular area or region of an image. Basically techniques that can be used to ensure that you do not 'overflow' or grow beyond some limit or area of interest. This generally requires a 'mask' image of some kind, and is typically done using a <a href="../masking/#write_mask">Write Protect Mask</a>, to limit what pixels are updated. <a name="dilate_conditional" id="dilate_conditional"></a>
          <h3>Conditional Dilation</h3>The <a href="#dilate">Dilate Morphology Method</a> as you know will expand a specific shape according to a given kernel neighbourhood. '<b>Conditional Dilation</b>' is essentually the same thing, but sets a limit as to how far the dilation can spread when repeatedly applied to an image. A <a href="../color_basics/#floodfill_draw">Draw Flood-Fill</a> is in one sense the ultimate 'Conditional Dilation'. It will simply fill any orthogonal (<a href="#diamond">Diamond Kernel</a> neighbourhood) that happens to be the same color as the starting point. For example, we can select a single point in one of number of disks, and conditionally dilate (flood fill) until that disk has been completely recolored, seperating it from the other shapes.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick disks.gif -fill red -draw 'color 60,60 floodfill' \
          cond_dilate_draw.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/disks.gif"><img src="../images/disks.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="cond_dilate_draw.gif"><img src="cond_dilate_draw.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Similarly you can use the <a href="../color_basics/#floodfill">Floodfill Operator</a> to do the same thing but only if the start point also matches an user provided 'conditional color'.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick disks.gif \
          -fill green -floodfill +10+40 white \
          -fill blue  -floodfill +30+50 white \
          cond_dilate_floodfill.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="cond_dilate_floodfill.gif"><img src="cond_dilate_floodfill.gif" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>In this case the 'green' floodfill 'hit a disk' (and filled it), while the 'blue' flood fill operation, did not match, so no disk was filled. The problem with such 'flood-fill' methods is that you can only dilate from a single user provided point. It is however very fast, and works on the image as a whole. Repeated or iterated <a href="#dilate">Dilate</a> is the same as floodfill but can have multiple starting points, but has no understanding of limits or bounds to the fill operation it provides. To limit its effects we need to provide not only the 'starting points' but also the 'conditional bounds' of the fill. To do this we create a <a href="../masking/#write_mask">Write Protect Mask</a> (what parts of the image which are write protected).
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick disks.gif disks.gif -morphology Erode:7 Diamond disks_big_center.gif

  magick disks.gif -negate disks_mask.gif

  magick disks_big_center.gif -write-mask disks_mask.gif \
          -morphology Dilate:15 Diamond +write-mask disks_big_found.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/disks.gif"><img src="../images/disks.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="disks_big_center.gif"><img src="disks_big_center.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20" alt=" + "> <a href="disks_mask.gif"><img src="disks_mask.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="disks_big_found.gif"><img src="disks_big_found.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>In the above we first used a <a href="#erode">Erode Method</a> to locate any disk that is larger than a radius of 7 (diameter 7x2+1 =&gt; 15 pixels). We then 'Conditionally Dilate' the discovered points by the same amount so as to 'perfectly' restore the object found. Note that 'Conditional Dilatation' is very different to using an <a href="#open">Open Method</a> for object restoration. That method would have generated the internal 'diamond' shape of the kernel, rather that the exact shape of the original object. It also will not handle 'odd shaped' or 'off centered' seed points. The iteration number '<code>15</code>' is not critical, but should be large enough to completely restore the object.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Remember it is better to use a small kernel, such as a <a href="#diamond">Diamond</a> or <a href="#square">Square</a> with a <a href="#iteration">Iteration Count</a> when performing <a href="#basic">Basic Morphology Operations</a> than using a much larger kernel, such as a <a href="#disk">Disk</a> with a large radius.<br>
              <br>
              This becomes especially important when doing a <a href="#dilate_conditional">Conditional Dialation</a>, as large kernels could in effect 'jump' over gaps that separate multiple objects.<br>
              <br></i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Do not use a '<code>-1</code>' or (near) infinite iteration count with a write mask. IMv7 Morphology currently will not realize that pixels are un-writable, and as such will not abort when it sees no more changes to the image, as it always sees changes, (which never gets written) around the edges of the shape.<br>
              <br>
              This will be fixed with IMv7, which provided a major internal re-structure that will let the operator be a little smarter with regards to write protected pixels.<br>
              <br></i></font></td>
            </tr>
          </table>Here is another example of the versitility of using a <a href="../masking/#write_mask">Write Protect Mask</a>. Find the disks will be hit by a diagonal line across the image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black -fill white \
                        -draw 'line 0,0 79,79'   disks_line.gif

  magick disks_line.gif disks.gif \
          -compose Multiply  -composite    disks_line_find.gif

  magick disks_line_find.gif -write-mask disks_mask.gif \
          -morphology Dilate:15 Diamond +write-mask disks_line_found.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/disks.gif"><img src="../images/disks.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20" alt=" + "> <a href="disks_line.gif"><img src="disks_line.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="disks_line_find.gif"><img src="disks_line_find.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20" alt=" + "> <a href="disks_mask.gif"><img src="disks_mask.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="disks_line_found.gif"><img src="disks_line_found.gif" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note the extra masking step (using a <a href="../compose/#multiply">Multiply Composition</a>), ensures that only objects the line actually goes <i>though</i> will be 'found'. Without this step, objects that is also close to the line, that is within the kernel radius of the 'seed points' (just touching in the above), would also be 'dilated'. Of course if you are wanting to include 'near objects' then by all means dilate the line (making it wider) with a disk kernel of the appropriate radius, before doing the initial masking step. that will give you more 'near' control than relying on the square kernel radius. In summery a <a href="#dilate_conditional">Conditional Dialation</a> could be regarded as a multi-point <a href="../color_basics/#floodfill_draw">Draw Flood-Fill</a>, that while slower, can be more versitle in selecting exactly what should be filled, or 'discovered'. <a name="distance_constrainted" id="distance_constrainted"></a>
          <h3>Constrained Distance</h3>The <a href="#distance">Distance</a> morphology method can be easily used to find how far a point within an object is from an edge. But it can also be used to find how distant each point within the object is from another point. For example, here I discover how far each point is from a single 'seed' point (as the crow flys)...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
<br>  magick -size 100x100 xc: -draw 'point 20,80'  distance_start.png

  magick distance_start.png -morphology Distance Euclidean \
          -auto-level  distance_point.png

  magick -font Casual -pointsize 140 label:D \
          -trim +repage -gravity center -extent 100x100 \
          -threshold 20% distance_bounds.png

  magick distance_point.png \( distance_bounds.png -negate \)  \
          -compose multiply -composite  -auto-level distance_direct.png
</samp></pre>
                </td>
              </tr>
            </table><a href="distance_start.png"><img src="distance_start.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_point.png"><img src="distance_point.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_bounds.png"><img src="distance_bounds.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_direct.png"><img src="distance_direct.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>The distance from a point is masked by the shape of the object as these are the only points we are interested in. The problem is that distance gradient above represents a 'as the crow flys' or direct distance to the 'starting point'. Simply masking that gradient by the object does not change that. Unfortunatally this is typically not what an user wants in the way of a "distance from the start point". If the shape represented an island, you would get quite wet if you wanted to take the 'direct route' from one end of this island to the other. <a name="iterative_distance" id="iterative_distance"></a> What you really want is the distance that is limited to paths '<i>with-in the object</i>'. That is, you want the distance to be 'constrained' by the object itself, and follows the smallest path possible, inside the object.To do this we can set up a <a href="../maskng/#write_mask">Write Protect Mask</a> so that as the distance gradient is calculated it does not cross (write to) the 'no go' areas or background of the image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick distance_start.png -write-mask distance_bounds.png \
          -morphology IterativeDistance:150 Euclidean \
          +write-mask -fill black -opaque white -auto-level \
          distance_constrained.png
</samp></pre>
                </td>
              </tr>
            </table><a href="distance_start.png"><img src="distance_start.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_bounds.png"><img src="distance_bounds.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="distance_constrained.png"><img src="distance_constrained.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>The result as you can see is a correct 'distance across image' gradient, that clearly shows the largest distance (white) from the starting point is the other end of the island that is just a 'stones throw' across the gap in the object.<br>
          Note that I did not simply use a normal <a href="#distance">Distance Method</a> but a lower level '<code>Iterative_Distance</code>' morphology method. The normal <a href="#distance">Distance Method</a> is a special 2-pass FAST distance method that is applied to the image as a whole. Because of this the write mask will not restrict its actions along a 'row' of pixels, and as such the write mask will have little effect. The result is that '<code>Distance</code>' will have a tendency to 'jump' over horizontal gaps, regardless of the write mask. That is, the normal <a href="#distance">Distance Method</a> is not properly 'constrained'. The '<code>Iterative_Distance</code>' method however works more like a simpler <a href="#basic">Basic Morphology Method</a> and is only applied incrementally to the local neighbourhood. It is actually more like a gradient form of 'dilate', and is in fact closely related to a <a href="#greyscale">True Gray-scale Morphology</a> method. As it processes the image in smaller 'incremental steps' the '<code>Iterative_Distance</code>' method will be 'constrained' by the write mask. Unfortunatally it is much also much slower. Instead of 2 passes though the image, the above performs 150 passes, as given by the <a href="#iteration">Iteration Count</a> to the morphology method. It is best to try and keep this iterative count as small as possible, but large enough to cover the largest distance that will be found within the image.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Do not use a '<code>-1</code>' or (near) infinite iteration count with a write mask. IMv7 Morphology does not understand that some pixels are un-writable, as as such will not abort when it sees no more changes to the image, as it always sees changes to 'un-writable pixels' around the edges of the shape.<br>
              <br>
              This will hopefully be fixed with IMv7, which provides a major internal re-structure that will let the operator be a little smarter, by understanding that some pixels are not writable, and thus avoid calculating, or counting them as having been 'changed'.<br>
              <br></i></font></td>
            </tr>
          </table>Finally you will notice that I used a <a href="#distance_kernels">Distance Kernel</a> that only has a radius of 1, even though such kernels are not as accurate. This is important as a larger kernel could result in the distance gradient jumping across any gap that is smaller than its radius. See <a href="#dilate_conditional">Conditional Dilate</a> above. If more accuracy is needed, then you will need to ensure that their is no gaps that is smaller than the <a href="#distance_kernels">Distance Kernel</a> you want to use. That includes gaps due to a sharp bend in the image edge.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="skeletons" id="skeletons"></a>
          <h2>Generating Skeletons of shapes.</h2>
          <div align="center">
            <font size="+2"><b><img src="../img_www/const_barrier.gif" width="39" height="35" align="top"> Under Construction <img src="../img_www/const_hole.gif" width="144" height="50" align="middle"></b></font>
          </div>
          <pre>
From HIPR2 Morphology
http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm


The skeleton/MAT can be produced in two main ways. The first is to use some
kind of morphological thinning that successively erodes away pixels from the
boundary (while preserving the end points of line segments) until no more
thinning is possible, at which point what is left approximates the skeleton.

The alternative method is to first calculate the distance transform of the
image. The skeleton then lies along the singularities (i.e. creases or
curvature discontinuities) in the distance transform. This latter approach is
more suited to calculating the MAT since the MAT is the same as the distance
transform but with all points not part of the skeleton suppressed to zero.

Note: The MAT is often described as being the 'locus of local maxima' on the
distance transform. This is not really true in any normal sense of the phrase
'local maximum'. If the distance transform is displayed as a 3-D surface plot
with the third dimension representing the gray-value, the MAT can be imagined
as the ridges on the 3-D surface.



Definition??

Morphological Skeleton (by erosion?), (by thinning)

Skeletons are calculated either by repeated thinning,  or by distance
transform, and finding the 'creases', or ridges on the 3d surface (watershed
transform?).

   mat.gif -morphology HMT Ridges           -threshold 0
   mat.gif -morphology HMT LineEnds         -threshold 0
   mat.gif -morphology HMT Ridges\;LineEnds -threshold 0

   mat.gif -morphology HMT Ridges\;Ridges2  -threshold 0

   mat.gif -morphology TopHat Diamond              -threshold 0

   mat.gif -define morphology:compose=Lighten \
              -morphology TopHat '3@:-,1,- -,1,- -,-,-' -threshold 0


One definition of medial axis transform (MAT) uses the intensity of each point
to represent the distance ot the boundary.  That the skeleton was used as
a mask for the distance transform. The distance transform method is more
suited to this, and it is probably faster to calculate than by thinning.

SKIZ (Skeleton by Influence Zones) is a skeleton of the background, the
negative of the operation.  That is, dividing the regions closest to each
foreground object.  (generated by thickening)

Generally a SKIZ is pruned down to simple areas, or basins, by also eroding
end of line segments, unless they are attached to an image edge.

Identifying shape by their skeletons.
   distance between farthest 'end' points,
   number of 'loops' or regions in image,
   number of triple points.


</pre><a name="distance_skeleton" id="distance_skeleton"></a>
          <h3>Distance to Skeleton</h3>One quick and dirty way to generate a raw 'morphological skeleton' from an image is by applying the '<code><a href="#tophat">TopHat</a></code>' method to the distance gradient.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example, here is a skeleton of the shape after it is been <a href="#open">Opened</a> a little to smooth its outline a bit.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif \
          -morphology Open  Diamond \
          -morphology Distance  Chebyshev \
          -morphology TopHat Diamond \
          -auto-level    chebyshev_dist_skel.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="chebyshev_dist_skel.gif"><img src="chebyshev_dist_skel.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This is basically a morphological skeleton. It only shows the pixels where a maximal 'square' (more commonly known as a 'Maximal Ball') could be found, which is why it looks incomplete. However it is still a very raw result with many isolated pixels. Amazingly it does work. Without the '<code><a href="#open">Open</a></code>' the result is very bad, due to the shape having such a rough outline.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Using an Euclidean distance measure produces a better skeleton of the shape.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif \
          -morphology Open  Diamond \
          -morphology Distance Euclidean:4 \
          -morphology TopHat Diamond \
          -auto-level    euclidean_dist_skel.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="euclidean_dist_skel.gif"><img src="euclidean_dist_skel.gif" width="100" height="125" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>But as you can see you also get more noise and the skeleton while more complete is also very dirty with many gray-scale values.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Here is an enlargement of the 'head' of the skeleton, showing how it remains disjointed.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick euclidean_dist_skel.gif -crop 35x28+30+13 +repage \
          -scale 400%   euclidean_dist_skel_mag.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="euclidean_dist_skel_mag.gif"><img src="euclidean_dist_skel_mag.gif" width="140" height="112" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Of course the above could be thresholded and used as a mask with the actual distance gradient that was used to generate it. This will allow you to look up the actual size (distance radius) of the maximal disks that makes up the skeleton, letting you re-create the original shape. <a name="autotrace_skeleton" id="autotrace_skeleton"></a>
          <h3>Skeleton using Autotrace</h3>Another alternative to skeleton generation, is to use the "<code><a href="http://autotrace.sourceforge.net/">AutoTrace</a></code>" program and its special centerline option. Note that it assumes black on white for its processing due to it involvement with printing and font conversion. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick man.gif -negate man_at_prep.pgm
  autotrace -centerline -output-format svg man_at_prep.pgm |\
      magick SVG:-  man_centerline.gif
  magick man.gif man_centerline.gif \
          -compose multiply -composite man_at_skeleton.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="man.gif"><img src="man.gif" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_at_prep.png"><img src="man_at_prep.png" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_centerline.gif"><img src="man_centerline.gif" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="man_at_skeleton.gif"><img src="man_at_skeleton.gif" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note that the centerline generated is in the form of a smooth curve due to the vector nature of the process. It is also disconnected, with gaps in skeleton loops, and disconnected branches. However I have not looked at how "autotrace" actually generates this skeleton. For other example of using "<code><a href="http://autotrace.sourceforge.net/">AutoTrace</a></code>", see <a href="../draw/#svg_output">SVG Output Handling</a>, and <a href="../transform/#edge_vector">Raster to Vector Edging</a>.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
        </div>
      </div>
    </div>
  </main>
  <footer class="magick-footer">
    <div class="container-fluid">
      Created: 4 January 2010<br>
      Updated: 15 Feburary 2013<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Major Input: <a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a>, &lt;fmw at alink.net&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://imagemagick.org/Usage/morphology/</code>
    </div>
  </footer>
</body>
</html>
