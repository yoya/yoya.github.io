<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Canvas Creation -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/canvas/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Canvas Creation</h1>
        <div>
          <b>Index</b>
          <table cellspacing="0">
            <tr valign="top">
              <td colspan="2">
                <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
              </td>
            </tr>
            <tr valign="top">
              <td>
                <dl>
                  <dd>
                    <a href="#solid"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Solid Color Canvases</a>
                    <ul>
                      <li>
                        <a href="#solid">Direct Generation</a>
                      </li>
                      <li>
                        <a href="#blank">Blanking Existing Images</a>
                      </li>
                      <li>
                        <a href="#blank_pick">Blanking Image with Picked Color</a>
                      </li>
                      <li>
                        <a href="#specific">Overlay a Specific Color</a>
                      </li>
                      <li>
                        <a href="#other">Other Canvas Techniques</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#gradient"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Gradients of Colors</a>
                    <ul>
                      <li>
                        <a href="#gradient">Gradient Image Generator</a>
                      </li>
                      <li>
                        <a href="#radial-gradient">Radial Gradient Generator</a>
                      </li>
                      <li>
                        <a href="#gradient_transparent">Gradients with Transparency</a>
                      </li>
                      <li>
                        <a href="#gradient_histogram">Histogram Adjusted Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_functions">Evaluated Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_distort">Distorted Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_compose">Gradients by Composition</a>
                      </li>
                      <li>
                        <a href="#gradient_colorspace">Gradients in other Colorspaces</a>
                      </li>
                      <li>
                        <a href="#gradient_resize">Resized Image Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_interpolate">Interpolated Lookup Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_fx">Roll your own Gradient</a>
                      </li>
                      <li>
                        <a href="#gradient_complex">More Complex DIY Gradients</a>
                      </li>
                      <li>
                        <a href="#gradient_complex_hues">DIY Gradients and Hues</a>
                      </li>
                      <li>
                        <a href="#perfect_gradients">Generating the Perfect Gradient</a>
                      </li>
                    </ul>
                  </dd>
                  <dd>
                    <a href="#sparse-color"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Sparse Points of Color</a>
                    <ul>
                      <li>
                        <a href="#barycentric"><b>Barycentric</b> - The Triangle Gradient</a>
                        <ul>
                          <li><font size="-1"><a href="#two_color_gradients">Two Color Gradients</a></font></li>
                          <li><font size="-1"><a href="#diagonal_gradients">Diagonal Gradients</a></font></li>
                          <li><font size="-1"><a href="#two_point_gradients">Barycentric and Two Color Gradients</a></font></li>
                        </ul>
                      </li>
                      <li>
                        <a href="#bilinear"><b>Bilinear</b> - 4 Point Gradient</a>
                      </li>
                      <li>
                        <a href="#voronoi"><b>Voronoi</b> - Nearest Color</a>
                      </li>
                      <li>
                        <a href="#shepards"><b>Shepards</b> - Spotlights of Color</a>
                      </li>
                      <li>
                        <a href="#inverse"><b>Inverse</b> - Sharp Points of Color</a>
                      </li>
                      <li>
                        <a href="#shepards_power">Shepards Power Factor</a>
                      </li>
                      <li>
                        <a href="#sparse_summery">Summery of Sparse Color Methods</a>
                      </li>
                      <li>
                        <a href="#sparse_channel">Channel Setting and Sparse Color</a>
                      </li>
                      <li>
                        <a href="#sparse_fill">Sparse Color as a Fill Operator</a>
                      </li>
                      <li>
                        <a href="#sparse_blur">Sparse Color Shepards, a Blur Alternative</a>
                      </li>
                      <li>
                        <a href="#shepards_leakage">Shepards Method 'Leaks'</a>
                      </li>
                    </ul>
                  </dd>
                </dl>
              </td>
              <td>
                <dl>
                  <dd>
                    <a href="#plasma"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Plasma Images</a>
                    <ul>
                      <li>
                        <a href="#plasma_gradients">Plasma Gradients</a>
                      </li>
                      <li>
                        <a href="#plasma_fractal">Fractal Plasma</a>
                      </li>
                      <li>
                        <a href="#plasma_greyscale">Gray-scale Plasma</a>
                      </li>
                      <li>
                        <a href="#plasma_seeded">Seeded Plasma</a>
                      </li>
                      <li>
                        <a href="#plasma_problems">Problems using Plasma</a>
                      </li>
                    </ul>&nbsp;
                  </dd>
                  <dd>
                    <a href="#random"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Random Images</a>
                    <ul>
                      <li>
                        <a href="#random_noise">Raw Random Noise</a> <font size="-1">- pure random</font>
                      </li>
                      <li>
                        <a href="#plasma_gradients">Plasma Gradients</a>
                      </li>
                      <li>
                        <a href="#random_specks">Random Speckles</a> <font size="-1">- pixel dust</font>
                      </li>
                      <li>
                        <a href="#random_blur">Blurred Random Images</a> <font size="-1">- random blobs</font>
                      </li>
                      <li>
                        <a href="#granularity">Random Granularity</a> <font size="-1">- order in the chaos</font>
                      </li>
                      <li>
                        <a href="#random_flux">Random Flux</a> <font size="-1">- animated randomness</font>
                      </li>
                      <li>
                        <a href="#random_ripples">Random Ripples</a> <font size="-1">- dispersion maps</font>
                      </li>
                    </ul>&nbsp;
                  </dd>
                  <dd>
                    <a href="#tile"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Tiled Canvases</a>
                    <ul>
                      <li>
                        <a href="#tile">Tiled Canvas</a>
                      </li>
                      <li>
                        <a href="#tile-offset">Offset Tiling Canvases</a>
                      </li>
                      <li>
                        <a href="#tile_memory">Tiling with an Image In Memory</a>
                      </li>
                      <li>
                        <a href="#pattern">Modifying Built-in Patterns</a>
                      </li>
                      <li>
                        <a href="#tile_mod">Modifying Tile Images</a>
                      </li>
                      <li>
                        <a href="#tile_gen">Generating Tile Images</a>
                      </li>
                      <li>
                        <a href="#tile_random">Random Noise Tiles</a>
                      </li>
                      <li>
                        <a href="#tile_hex">Hexagonal Tiling</a>
                      </li>
                      <li>
                        <a href="#tile_triple_hex">Triple Hex Tiling</a>
                      </li>
                      <li>
                        <a href="#tile_diagonal">Diagonal Mirror Tiling</a>
                      </li>
                    </ul>
                  </dd>
                </dl>
              </td>
            </tr>
          </table>Canvases are used by ImageMagick both as a starting image for drawing on, backgrounds to overlay images with transparent areas, or even just as part of general image processing. They can be a solid color, or a range of colors, or even a tile of a smaller image. Here we look at just some of the methods that can be used to generate a whole range of canvas images.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="solid" id="solid"></a>
          <h2>Solid Color Canvases</h2>
          <h3>Direct Generation</h3>Generating a canvas of a specific color and size is very simple to do. You just specify "<code><a href="../option_link.cgi?size">-size</a></code>" (defaulting to "<code>1x1</code>" is no size given), and then use "<code>canvas:</code>" to generate an canvas of the color given. If no color is specified a '<code>white</code>' canvas is generated.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                For example... here I generate a '<code>khaki</code>' colors canvas.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 canvas:khaki  canvas_khaki.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="canvas_khaki.gif"><img src="canvas_khaki.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                More commonly a short hand (and more traditional) format of "<code>xc:</code>" (which meant "X Constant Image"). This is generally what I use. For example, here is an image using the X window color of '<code>wheat</code>'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:wheat  canvas_wheat.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="canvas_wheat.gif"><img src="canvas_wheat.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Using some fancy <a href="../files/#read_mods">Image Read Modifiers</a> we can just specify a solid color canvas image as a single argument. This technique means you can specify a 'xc' canvas image of a specific size and color as a single 'input image' argument to many ImageMagick Scripts.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick 'xc:Salmon[100x100!]'  canvas_salmon.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
                <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
                  <tr valign="top">
                    <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                    <td align="justify" width="100%"><font size="-1"><i>The '!' is needed as the numbers are resize values, otherwise you not get the size requested if it isn't square.</i></font></td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="canvas_salmon.gif"><img src="canvas_salmon.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                If you have already created a canvas, but need one in a different color you can replace that color using the "<code><a href="../option_link.cgi?opaque">-opaque</a></code>" operator.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick canvas_khaki.gif -fill tomato -opaque khaki canvas_tomato.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="canvas_tomato.gif"><img src="canvas_tomato.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can even grab a single pixel from an existing image, and expand it to the canvas size you want. We use "<code><a href="../option_link.cgi?scale">-scale</a></code>" for a simple and fast resizing of the single pixel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Here we grab a rose color from the built-in "<code>rose:</code>" image.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -crop 1x1+40+30 +repage -scale 100x100\! canvas_rose_red.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="canvas_rose_red.gif"><img src="canvas_rose_red.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="sized" id="sized"></a> <!-- check before removing -->
          <a name="blank" id="blank"></a>
          <h3>Create Image of same size</h3>One most basic techniques, when using ImageMagick, is to generate a canvas of the same size as some existing image. This can be done by converting that existing image into the canvas needed, but preserving the image's original size. Generally it is not just the images size that needs to be preserved, but all the images meta-data as well. That in things such as labels, comments, color profiles, time delays, as well as the save compression and depth. This meta-data can be important if you want to annotate such information onto the newly blanked canvas, or you plan to overlay the original image onto the new canvas, and need to preserve that information. Naturally IM provides a large number of ways to do this, usually as a side-effect of using various image operations. Only a few are very obvious about there use in clearing an image to a solid color.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">To the left is a test image... Don't worry above how I actually generated this image, it is not important for the exercise. I did design it to contain a range of colors, transparencies and other features, specifically to give IM a good workout when used. <i>If you are really interested in the commands used to generate this image you can look at the special script, "<a href="../scripts/generate_test">generate_test</a>", I use to create it.</i></td>
              <td>
                <a href="../images/test.png"><img src="../images/test.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="specific" id="specific"></a>
          <h3>Overlay a Specific Color</h3>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                As of IM v6.4.2-1 you can use the "<code><a href="../option_link.cgi?level_colors">+level-colors</a></code>" with a single color and no comma's, to set all the colors.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha Opaque +level-colors Sienna  color_levelc.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_levelc.gif"><img src="color_levelc.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note the use of the "<code><a href="../option_link.cgi?alpha">-alpha</a></code>" operator to set the transparency to something useful before (or after) the color has been added. Altrunativally you could use "<code>-channel All</code>" to ensure the transparency channel is also set by the color resetting operation. Another older technique is to use "<code><a href="../option_link.cgi?colorize">-colorize</a></code>" to overlay the fill color but with a fully opaque value. However before IM v6.7.9 it did not change the the original images alpha channel, so it is a good idea if to disable the alpha channel first, using "<code><a href="../option_link.cgi?alpha">-alpha</a> <a href="../masking/#alpha_off">Off</a></code>", or make it opaque with "<code><a href="../option_link.cgi?alpha">-alpha</a> <a href="../masking/#alpha_off">Opaque</a></code>" even though you would get the same result without it.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha off -fill Chocolate -colorize 100%  
color_colorize.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
                <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
                  <tr valign="top">
                    <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                    <td align="justify" width="100%"><font size="-1"><i>Note that "<code><a href="../option_link.cgi?alpha">-alpha</a> <a href="../masking/#alpha_off">Off</a></code>" (or the older equivelent "<code><a href="../option_link.cgi?matte">-alpha off</a></code>") only disables the alpha channel. if you turn it <a href="../masking/#alpha_on">On</a> again afterwards, the original alpha channel (which was preserved) will be restored. Before IM v6.7.9 alpha was preserved when using "<code><a href="../option_link.cgi?colorize">-colorize</a></code>".</i></font></td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_colorize.gif"><img src="color_colorize.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                As of IM v6.4.3-0 you can use the "<code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code>" operator to set some point to the color wanted, and have it spread to cover the whole image, using just about any coloring method it provides (see <a href="#sparse-color">Sparse Points of Color</a> below).
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha Off \
          -sparse-color Voronoi '0,0 Peru' color_sparse.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_sparse.gif"><img src="color_sparse.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                A more general way is to use "<code><a href="../option_link.cgi?draw">-draw</a></code>" to directly reset all the colors in the current image to the current "<code><a href="../option_link.cgi?fill">-fill</a></code>" color.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -fill Tan -draw 'color 0,0 reset' color_reset.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_reset.gif"><img src="color_reset.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This was the recommended method in ImageMagick version 5.<br>
          The major complaint about all the above 'simple' methods is that none simply resets the image to the current "<code><a href="../option_link.cgi?background">-background</a></code>" color. The next set methods make use of <a href="../compose/">Alpha Composition</a> to force various operators to replace the image with the desired color. These multi-image techniques work with operators that use "<code><a href="../option_link.cgi?compose">-compose</a></code>".
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                For example you can use the "<code><a href="../option_link.cgi?flatten">-flatten</a></code>" (See <a href="../layers/#flatten_bgnd">Flatten onto Background</a> example), which creates a canvas using the "<code><a href="../option_link.cgi?background">-background</a></code>" color.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png   -background Wheat \
            -compose Dst   -flatten   color_flatten.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_flatten.gif"><img src="color_flatten.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above as uses the '<code><a href="../compose/#Dst">Dst</a></code>' compose method to only read the background canvas, and ignore the pixel colors of the original image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="bottom">
              <td width="100%" align="justify">
                If you are just wanting to grab the original images meta-data (such as the comment or label data), but replace the image itself with a specific color and size of canvas image, then "<code><a href="../option_link.cgi?extent">-extent</a></code>" operator (See <a href="../crop/#extent">Extent, Direct Image Size Adjustment</a>) may be the best solution. Again the <code><a href="../compose/#Dst">Dst</a></code>' compose method is used to have it ignore the original image pixel data, so as to onlyuse the "<code><a href="../option_link.cgi?background">-background</a></code>" color.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png   -background LemonChiffon \
            -compose Dst   -extent 100x100   color_extent.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_extent.gif"><img src="color_extent.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Or you can use "<code><a href="../option_link.cgi?border">-border</a></code>" (See <a href="../crop/#border">Adding a Border</a>), using the "<code><a href="../option_link.cgi?bordercolor">-bordercolor</a></code>" as the color source.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png   -bordercolor Khaki \
            -compose Dst   -border 0   color_border.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_border.gif"><img src="color_border.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This last method has the added advantage of also letting you slightly enlarge the image canvas, relative to the original images size.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?border">-border</a></code>" method of generating canvases will not work with versions of IM before version 6.1.4. Before this the background generated by the "<code><a href="../option_link.cgi?border">-border</a></code>" operator was not a simple solid color, but a black canvas surrounded by the border color. Not very useful.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                A more flexible (but very slow) method of canvas generation was provided by the "<code><a href="../transform/#fx">FX, DIY Operator</a></code>" operator. You will also need to turn off the input image's transparency channel as by default "<code><a href="../option_link.cgi?fx">-fx</a></code>" will not touch the transparency channel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha off -fx Gold  color_fx_constant.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_fx_constant.gif"><img src="color_fx_constant.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                The "<code><a href="../option_link.cgi?fx">-fx</a></code>" operator will even let you do a little color mathematics. For example how about a 70% darker gold color...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha off -fx "Gold*.7"  color_fx_math.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_fx_math.gif"><img src="color_fx_math.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>All the above methods cannot only fill using a fully-opaque color, but can also use semi-transparent colors. However it is a good idea to ensure the image you have a transparency channel before hand.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Here for example we create a canvas with a semi-transparent red. However when overlaid on the web pages 'bluish' background we get an off purple-pink color.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha set -fill '#FF000040' -draw 'color 0,0 reset' \
            color_semitrans.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_semitrans.png"><img src="color_semitrans.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Also note that when using "<code><a href="../option_link.cgi?fx">-fx</a></code>" operator with transparency, you will need to set "<code><a href="../option_link.cgi?channel">-channel</a></code>" to modify all four '<code>RGBA</code>' color channels. <a name="blank_pick" id="blank_pick"></a>
          <h3>Blanking Image with Picked Color</h3>Blanking images using a color from the original image is also posible, though can be tricky. It is an useful technique when you want to use a specific pixel as a 'background color'. For example pixel 0,0 is a common choice.<a href="../images/rose.png"><img src="../images/rose.png" width="70" height="46" align="right" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> In the following examples I will select colors from various pixels from the built in rose image (shown left), as I blank the image. The most obvious (though slow) method is to simply use the "<code><a href="../transform/#fx">FX, DIY Operator</a></code>" to select the pixel to use color blanking.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -fx 'p{0,0}'  color_pick_fx.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_pick_fx.png"><img src="color_pick_fx.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However this can be speed up by only selecting the pixel once. This can be done by using the fx formula as an argument for <a href="#sparse-color">Sparse Color</a>. It may seem less simple, but it is much faster.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -sparse-color voronoi '0,0 %[pixel:p{40,30}]' 
color_pick_sparse.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_pick_sparse.png"><img src="color_pick_sparse.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Another more complex method is to crop out that one pixel and tile it across the image, using techniques described later in detail in <a href="#tile_memory">Tiling with an Image already In Memory</a>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: \( +clone -crop 1x1+64+22 -write MPR:pixel +delete \) \
          -fill mpr:pixel  -draw 'color 0,0 reset' \
          color_pick_draw.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_pick_draw.png"><img src="color_pick_draw.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -set option:distort:viewport '%wx%h+0+0' \
          -crop 1x1+10+25 +repage     -distort SRT 0 \
          color_pick_distort.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="color_pick_distort.png"><img src="color_pick_distort.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><br>
          <a name="other" id="other"></a>
          <h3>Other Canvas Techniques</h3>Their lots of other ways of generating canvases of very specific colors, but they are rather obtuse. As such without some heavy commenting, it may not be obvious what you are actually doing when you look at your IM script months or years later. I don't recommend these techniques, but are useful to know if you are using older less flexible versions of IM. <a name="black" id="black">
          <h4>Black Canvas</h4>-threshold", and then turn off the transparency channel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Traditionally you can create a black canvas by using "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -threshold 100% -alpha off  black_threshold.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_threshold.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-level" operator with the same argument for both 'black' and 'white' points will have the same effect.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Providing the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -level 100%,100% -alpha off  black_level.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_level.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-fx" operator provides a more obvious way of creating a black canvas by clearing all the pixels to zero. However you will also need to reset the alpha channel to make it fully opaque.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">The "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -fx 0 -alpha off   black_fx.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_fx.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-evaluate" version of this should be faster, particularly on larger images.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">However the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -evaluate set 0  -alpha off  black_evaluate.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_evaluate.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-gamma" operator to make an image all black.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">You can also mis-use the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -gamma 0  -alpha off  black_gamma.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_gamma.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table><img src="black_posterize.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                A less obvious way is to 'posterize' the image with too few color levels, resulting in only one color being used, black.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -posterize 1 -alpha off black_posterize.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td></td>
            </tr>
          </table>Alpha Operator
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">You can ensure the image is fully transparent then '<code>extract</code>' the images mask, using the</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha transparent -alpha extract  black_alpha.png
</samp></pre>
              </td>
            </tr>
          </table><img src="black_alpha.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table></a><a name="white" id="white">
          <h4>White Canvas</h4>-threshold". The value however must be a negative number, just to be sure that all colors will be mapped to white, in all versions of IM.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">The traditional way is again using "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -threshold -1 -alpha off   white_threshold.png
</samp></pre>
              </td>
            </tr>
          </table><img src="white_threshold.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-level" operator with same argument for both 'black' and 'white' points will have the same effect.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Providing the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -level -1,-1 -alpha off  white_level.png
</samp></pre>
              </td>
            </tr>
          </table><img src="white_level.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-fx" operator.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">You can of course set the pixel values directly using the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -fx 1.0 -alpha off  white_fx.png
</samp></pre>
              </td>
            </tr>
          </table><img src="white_fx.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-evaluate" version of this should be faster, particularly on larger images.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">However the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -evaluate set 100%  -alpha off  white_evaluate.png
</samp></pre>
              </td>
            </tr>
          </table><img src="white_evaluate.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table><img src="white_posterize.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Or negate some other black canvas generation method.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -posterize 1 -alpha off -negate  white_posterize.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td></td>
            </tr>
          </table>Alpha Operator
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">You can ensure the image is fully opaque (no transparency) then '<code>extract</code>' the images mask, using the</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha opaque -alpha extract  white_alpha.png
</samp></pre>
              </td>
            </tr>
          </table><img src="white_alpha.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table></a><a name="transparent" id="transparent">
          <h4>Transparent Canvas</h4>Probably the most important canvas you want to generate from an existing image is a transparent canvas. You can then draw and add things to this canvas, get it the way you want it, the overlay it onto the original image. -alphatransparent" operator (added IM v6.4.3-7).
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">The fastest and easiest way is to just get IM to directly clear the image to transparency, using the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha transparent trans_alpha.png
</samp></pre>
              </td>
            </tr>
          </table>However as this is a very recent addition it is probably not widely available yet. <img src="trans_alpha.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>Clear' alpha composition operator, with any overlay image (a single pixel "<code>null:</code>" in this case) as it will be ignored.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">We can make a fully-transparent 'black' canvas using the '</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  null: -alpha set -compose Clear -composite -compose Over \
          trans_compose.png
</samp></pre>
              </td>
            </tr>
          </table><img src="trans_compose.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-fill" color setting. In this case make it fully-transparent.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Here we use the "<code>-draw matte</code>" operator to replace the matte (transparency) channel value with the transparency value of the current "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha set -fill none  -draw 'matte 0,0 reset' 
color_matte.png
</samp></pre>
              </td>
            </tr>
          </table><img src="color_matte.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-fx" operator.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">We can also do this more directly with the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -alpha set -channel A -fx 0 +channel  trans_fx.png
</samp></pre>
              </td>
            </tr>
          </table><img src="trans_fx.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-evaluate" version of this should be faster, particularly on larger images.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Naturally the "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -alpha set -channel A -evaluate set 0 +channel \
          trans_evaluate.png
</samp></pre>
              </td>
            </tr>
          </table><img src="trans_evaluate.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>-threshold" but again limiting its effects to just the transparency channel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">Another way to just make the image fully transparent is to use "</td>
            </tr>
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -channel A -threshold -1 +channel trans_threshold.png
</samp></pre>
              </td>
            </tr>
          </table><img src="trans_threshold.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]">
          <table>
            <tr>
              <td></td>
            </tr>
          </table>Actually in this case we are mathematically dealing with a 'matte' channel, using threshold to set it to the maximum value, rather than zero as we did with the "</a><a href="../option_link.cgi?fx">-fx</a>" operator. This is why a '<code>-1</code>' was used in the above, rather than something like <code>101%</code>'. In many of the above image results, the original RGB colors of the original image are still present, they have just been made transparent. For example, here we read in one of the above images and ask IM to turn off the matte/alpha channel in the image so as to make the colors visible again.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick trans_fx.png -alpha off  trans_fx_alpha_off.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>Note however that not all image file formats and very few image operations will preserve the partially-transparent RGB colors that are still present in the resulting image.
              </td>
              <td>
                <a href="trans_fx_alpha_off.jpg"><img src="trans_fx_alpha_off.jpg" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As mentioned before, and worth repeating, many of the above methods rely on an image already having an alpha channel. If it doesn't, add one using the "<code><a href="../option_link.cgi?alpha">-alpha</a> <a href="../masking/#alpha_on">On</a></code>", but in that case you may as well just use the "<code><a href="../option_link.cgi?alpha">-alpha</a> Transparent</code>" operator. See the examples on <a href="../masking/#alpha">Controlling Image Transparency</a>. <a name="color_misc" id="color_misc">
          <h4>Miscellaneous Canvas Coloring</h4>Other than using a specific color, only the "</a><a href="../option_link.cgi?gamma">-gamma</a>" operator is truly flexible enough to generate a canvas of any primary/secondary color. You basically use <code>0</code> to zero out a channel, and <code>-1</code> to maximize a channel values.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                For example, here I generate a yellow canvas...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  -gamma -1,-1,0  -alpha off  yellow_gamma.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="yellow_gamma.png"><img src="yellow_gamma.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                As of IM v6.4.2 you can also use the "<code><a href="../option_link.cgi?level">+level</a></code>" operator to set a specific grey level for all the color channels.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick test.png  +level 40%,40%  -alpha off  grey_level.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="grey_level.png"><img src="grey_level.png" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="gradient" id="gradient"></a>
          <h2>Gradients of Color</h2>As you saw above you can create canvases of solid colors easy enough. But sometimes you want something more interesting.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                One very useful image creation operators is "<code>gradient:</code>". For example...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient:  gradient.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="gradient.jpg"><img src="gradient.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see by default "<code>gradient:</code>" will create an image with white at the top, and black at the bottom, and a smooth shading of grey across the height of the image. But it does not have to be only a grey-scale gradient, you can also generate a gradient of different colors by either specifying one color, or both.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100  gradient:blue              gradient_range1.jpg
  magick -size 100x100  gradient:yellow            gradient_range2.jpg
  magick -size 100x100  gradient:green-yellow      gradient_range3.jpg
  magick -size 100x100  gradient:red-blue          gradient_range4.jpg
  magick -size 100x100  gradient:tomato-steelblue  gradient_range5.jpg
</samp></pre>
                </td>
              </tr>
            </table><a href="gradient_range1.jpg"><img src="gradient_range1.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="gradient_range2.jpg"><img src="gradient_range2.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="gradient_range3.jpg"><img src="gradient_range3.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="gradient_range4.jpg"><img src="gradient_range4.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="gradient_range5.jpg"><img src="gradient_range5.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>Notice that when given a single color the second color will be either '<code>white</code>' or '<code>black</code>', which ever produces the largest color distance from the given color. As such '<code>blue</code>' produces a '<code>blue-white</code>' gradient, while '<code>yellow</code>' generated a '<code>yellow-black</code>' gradient. The '<code>red-blue</code>' gradient shows a much darker band of purple colors in the middle. This darkening is caused by the darker non-linear sRGB colorspace being used, especially with strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>"<code>gradient:</code>" currently only understands sRGB <a href="../color_basics/#colorspace">Color Space</a> color representations. As such you can not use it to generate a brighter more correct 'purple' gradient using '<code>red-blue</code>' colors in a linear LAB colorspace.<br>
              <br>
              It also means you can not generate multi-color 'rainbow' gradients using HSV colorspace.<br>
              <br>
              However you can 'fudge' such gradients relatively simply. See <a href="#gradient_colorspace">Gradients in other Colorspaces</a> below.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Gradients cannot currently be specified at other angles or involving more than two colors. However as this ability is in integral part of SVG gradients, this situation will likely change, with a major improvement in gradient options.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Some particularly nice gradients include...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 10x120  gradient:snow-navy          gradient_ice-sea.jpg
  magick -size 10x120  gradient:gold-firebrick     gradient_burnished.jpg
  magick -size 10x120  gradient:yellow-limegreen   gradient_grassland.jpg
  magick -size 10x120  gradient:khaki-tomato       gradient_sunset.jpg
  magick -size 10x120  gradient:darkcyan-snow      gradient_snow_scape.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                &nbsp; <a href="gradient_ice-sea.jpg"><img src="gradient_ice-sea.jpg" width="10" height="120" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a> <a href="gradient_burnished.jpg"><img src="gradient_burnished.jpg" width="10" height="120" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a> <a href="gradient_grassland.jpg"><img src="gradient_grassland.jpg" width="10" height="120" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a> <a href="gradient_sunset.jpg"><img src="gradient_sunset.jpg" width="10" height="120" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a> <a href="gradient_snow_scape.jpg"><img src="gradient_snow_scape.jpg" width="10" height="120" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="gradient_perfect" id="gradient_perfect"></a>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>As of IM v6.3.1 the algorithm used to generate gradients now produce a horizontally uniform colors, such that all the pixels of each row in an image being assigned the same color. That is, one color per row.<br>
              <br>
              Before this version the "<code>gradient:</code>" operator worked by ignoring the width of the image, and just assigning the next increment of color, going row-by-row from top-left corner to the bottom-right of the image.<br>
              <br>
              As a result the gradient was a predominately vertical gradient, just as it is now, but not a perfect one. Usually this fact was only important in special case such as test images, and for use in <a href="../mapping/#intro">Image Mapping</a>.<br>
              <br></i></font></td>
            </tr>
          </table>
          <p>Note, the behavior of gradients can be affected by these defines:</p>
          <div class="table-responsive" style="font-size:smaller !important;">
            <table class="table table-sm table-hover table-striped">
              <tr>
                <td>
                  <a class="anchor" id="pixel"></a>gradient:angle=<var>angle (in degrees)</var>
                </td>
                <td>For a linear gradient, this specifies the direction of the gradient going from color1 to color2 in a clockwise positive manner relative to north (up). For a radial gradient, this specifies the rotation of the gradient in a clockwise positive manner from its normal X-Y orientation. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:bounding-box=<var>WxH+X+Y</var></td>
                <td>Limit the gradient to a larger or smaller region than the image dimensions. If the region defined by the bounding box is smaller than the image, then color1 will be the color of the background. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:center=<var>x,y</var></td>
                <td>Specify the coordinates of the center point for the radial gradient. The default is the center of the image. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:direction=<var>value</var></td>
                <td>Specify the direction of the linear gradient towards the top/bottom/left/right or diagonal corners. The choices are: NorthWest, North, Northeast, West, East, SouthWest, South, SouthEast. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:extent=<var>value</var></td>
                <td>Specify the shape of an image centered radial gradient. The choices are: Circle, Diagonal, Ellipse, Maximum, Minimum. Circle and Maximum draw a circular radial gradient even for rectangular shaped images of radius equal to the larger of the half-width and half-height of the image. The Circle and Maximum options are both equivalent to the default radial gradient. The Minimum option draws a circular radial gradient even for rectangular shaped images of radius equal to the smaller of the half-width and half-height of the image. The Diagonal option draws a circular radial gradient even for rectangular shaped images of radius equal to the half-diagonal of the image. The Ellipse options draws an elliptical radial gradient for rectangular shaped images of radii equal to half the width and half the height of the image. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:radii=<var>x,y</var></td>
                <td>Specify the x and y radii of the gradient. If the x radius and the y radius are equal, the shape of the radial gradient will be a circle. If they differ, then the shape will be an ellipse. The default values are the maximum of the half width and half height of the image. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
              <tr>
                <td>gradient:vector=<var>x1,y1,x2,y2</var></td>
                <td>Specify the direction of the linear gradient going from vector1 (x1,y1) to vector2 (x2,y2). Color1 (fromColor) will be located at vector position x1,y1 and color2 (toColor) will be located at vector position x2,y2. Supported in Imagemagick 6.9.2-5.</td>
              </tr>
            </table><a name="radial-gradient" id="radial-gradient"></a>
            <h2>Radial Gradients</h2>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  As of IM v6.4.4 you can also generate radial gradient images in a similar way.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 radial-gradient:  rgradient.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="rgradient.jpg"><img src="rgradient.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the gradient is centered in the middle of the generated image, and has a diameter set to fit the larger of the X or Y size of the image. So if the size of the image isn't square you will get a 'clipped' radial gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 radial-gradient:  rgradient_clip.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="rgradient_clip.jpg"><img src="rgradient_clip.jpg" width="100" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  This lets you easily generate a square radial gradient from the center to a corner by making one edge 1.42 (square root of 2) times larger, and crop it.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x142 radial-gradient: \
          -gravity center -crop 100x100+0+0 rgradient_crop.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="rgradient_crop.jpg"><img src="rgradient_crop.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The colors of the gradient itself follow the same conventions as the much older linear "<code><a href="#gradient">gradient:</a></code>" image generator.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100  radial-gradient:blue              rgradient_range1.jpg
  magick -size 100x100  radial-gradient:yellow            rgradient_range2.jpg
  magick -size 100x100  radial-gradient:green-yellow      rgradient_range3.jpg
  magick -size 100x100  radial-gradient:red-blue          rgradient_range4.jpg
  magick -size 100x100  radial-gradient:tomato-steelblue  rgradient_range5.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="rgradient_range1.jpg"><img src="rgradient_range1.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="rgradient_range2.jpg"><img src="rgradient_range2.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="rgradient_range3.jpg"><img src="rgradient_range3.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="rgradient_range4.jpg"><img src="rgradient_range4.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="rgradient_range5.jpg"><img src="rgradient_range5.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div><a name="gradient_transparent" id="gradient_transparent"></a>
            <h3>Gradients with Transparency</h3>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  As of IM v6.2.9-8 the "<code>gradient:</code>" (and later "<code>radial-gradient:</code>") image creation operator understands the use of transparent and semi-transparent colors.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient:none-firebrick gradient_transparent.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_transparent.png"><img src="gradient_transparent.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Before ImageMagick 6.5.4-7 gradients involving a full transparency (such as the last example) would generally produce a black halo.<br>
                <br>
                What was happening is that the gradient generated was from the given color to the special color '<code>none</code>' or transparent-black. As a result colors would shade toward a semi-transparent black, before becoming fully-transparent.<br>
                <br>
                The solution to this problem was to generate a transparency gradient and then <a href="../color_mods/#colorize">Colorize</a> it with the desired color.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient:none-black \
          -fill firebrick -colorize 100% gradient_trans_colorize.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_trans_colorize.png"><img src="gradient_trans_colorize.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="gradient_histogram" id="gradient_histogram"></a>
            <h3>Gradients by Histogram Adjustment</h3>You can create a non-linear gradient by applying some form of histogram adjustment to a linear gradient. For example you can use a <a href="../color_mods/#sigmoidal">Sigmoidal Contrast</a> function to create a more natural looking gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -sigmoidal-contrast 6,50% \
            gradient_sigmoidal.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_sigmoidal.jpg"><img src="gradient_sigmoidal.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This type of gradient is especially good for generating <a href="../photos/#overlap">Overlapping Photos</a>, as it removed the sharp gradient changes at the beginning of the overlapping region. <a name="gradient_functions" id="gradient_functions"></a>
            <h3>Evaluate/Function Gradients</h3>You can also use the <a href="../transform/#evaluate">Evaluate Operator</a> and related <a href="../transform/#function">Function Operator</a> to modify a simple linear gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -evaluate cos 0.5 -negate \
            gradient_cosine.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_cosine.jpg"><img src="gradient_cosine.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or take it a step further and make a smooth parabolic peek in the center of the linear gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -function Polynomial -4,4,0 \
            gradient_peak.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_peak.jpg"><img src="gradient_peak.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or band or a rippled pattern...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -function sinusoid 4,-90  \
            gradient_bands.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_bands.jpg"><img src="gradient_bands.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Both of these closely related operators allow you to modify images and gradients based on Sine Curves, Polynomials, Logarithmic and Power-of mathematical functions. See <a href="../transform/#evaluate">Evaluate Math Functions</a> and <a href="../transform/#function">Function, Multi-Argument Evaluate</a> for more examples. <a name="gradient_distort" id="gradient_distort"></a>
            <h3>Distorted Gradients</h3><a name="gradient_rotate" id="gradient_rotate"></a>
            <h4>Rotated Gradient</h4>While the <a href="#sparse-color">Sparse Color</a> method '<code><a href="#barycentric">Barycentric</a></code>' (see below), provides a convenient way to generate gradients at any angle, if your IM is older than version 6.4.3-0 then you may need to use other methods to generate a diagonal or rotated gradient. For example, by increasing the size of the gradient image (multiply by the square root of 2 or 1.42), then rotate it 45 degrees, and crop the image to its final size, you can make a diagonal gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 142x142 gradient: -rotate -45 \
          -gravity center -crop 100x100+0+0 +repage \
          gradient_diagonal.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_diagonal.jpg"><img src="gradient_diagonal.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As of IM v6.3.5 you have a much faster and simpler way of generating a rotated gradient by using a <a href="../distorts/#srt">SRT Distortion</a>. For example, here is a 100 pixel gradient rotated 60 degrees, in a 100x100 pixel image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -distort SRT 60 gradient_srt.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_srt.jpg"><img src="gradient_srt.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This uses the default <a href="../misc/#virtual-pixel">Virtual Pixel, Edge</a> setting to ensure the whole image is covered by the requested gradient. You can also use the expert <a href="../distorts/#distort_viewport">Distort Viewport</a> setting, to map a gradient onto a larger image, such as for an use in <a href="../photos/#overlap">Overlapping Photos</a>. <a name="gradient_warping" id="gradient_warping"></a>
            <h4>Warping Gradients</h4>But you can use the same distortion methods to do a lot more than simple rotations.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  The gradient can also be twisted up...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -swirl 180 gradient_swirl.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_swirl.jpg"><img src="gradient_swirl.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You can re-map the gradient into a trapezoidal shape.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -rotate -90 \
          -distort Perspective '0,0 40,0  99,0 59,0  0,99 -10,99 99,99 109,99' \
          gradient_trapezoid.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_trapezoid.jpg"><img src="gradient_trapezoid.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or wrap the gradient into an arcs and circles using the <a href="../distorts/#distort">General Distortion Operator</a>...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -distort Arc '180 0 50 0' \
          gradient_arc.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_arc.jpg"><img src="gradient_arc.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: -distort Arc '360 0 50 0' \
          gradient_circle.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_circle.jpg"><img src="gradient_circle.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Though the new "<code><a href="#radial-gradient">radial-gradient:</a></code>" is probably the more simpler method for generating these gradients. A very useful but harder to generate gradient is a polar angle gradient. The exact form of this gradient depends on if the gradient should be centered on an even sized image, or an odd sized image. For example an <a href="../distorts/#arc">Arc Distort</a> can be used to generate images with an even number of pixel dimensions, 76 pixels in this case.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x1000 gradient: -rotate 90 \
          -distort Arc '360 -90 50 0' +repage \
          -gravity center -crop 76x76+0+0 +repage  gradient_angle_even.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_angle_even.png"><img src="gradient_angle_even.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The '<code>-90</code>' in the above sets the angle for the 'discontinuity' where 'zero' and 'maximum' wraps around to the same value. The value '<code>50</code>' should be at more than 1/2 the size of the final cropped image. Note how I used a much longer gradient to generate the smaller image. This improves the overall correctness of the result, especially as the image gets larger The closely related <a href="../distorts/#polar">Polar Distort</a> can also generate such a gradient, but as it has a control over the exact position of the 'center' of the distortion you can ensure it correctly generates an odd pixel size polar gradient image. In this case a 75 pixel image (radius = '<code>36.5</code>' )
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x1000 gradient: -rotate 90 \
          +distort Polar '36.5,0,.5,.5' +repage \
          -transverse  gradient_angle_odd.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_angle_odd.png"><img src="gradient_angle_odd.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The last two images may seem very similar, except for their size, but the handling of the center-most pixels is slightly different. If you look closely you will see that the last example has a perfect grey center pixel, where the previous example does not have a single center pixel, but four of them. The final size of the image was determined by the value '<code>36.5</code>' which is half of the '<code>75</code>' pixels wanted. The '<code>.5</code>' offsets is the important aspect for correct handling of the polar center. Note that by default the distortion places the discontinuity at the top of the image, as such the <a href="../warping/#transverse">Transverse Warp</a> corrects the angle and location of the discontinuity to match that produced by the <a href="../distorts/#arc">Arc Distort</a>. Here is a slightly different variant that generates an angular gradient but with a transparent circular mask.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 50x1000 gradient: -rotate 90 -alpha set \
          -virtual-pixel Transparent +distort Polar 49 +repage \
          -transverse  gradient_angle_masked.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_angle_masked.png"><img src="gradient_angle_masked.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The value '<code>49</code>' is the radius minus 1 as by default a distort adds a 1 pixel anti-aliasing buffer around the resulting image. As such final image is 100x100 pixels.<br>
            Circular shapes and gradients can be warped to produce some interesting non-linear gradients. For example arcing it using a <a href="../warping/#wave">Wave Distortion</a> can generate roughly triangular shaped gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 radial-gradient: \
          -background black -wave -28x200 -crop 100x100+0+0 +repage \
          gradient_triangle.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_triangle.jpg"><img src="gradient_triangle.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or a very odd looking bird like shape, generated by polar distortion along the top edge of the circular shape.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 radial-gradient: \
          +distort Polar '49' +repage \
          gradient_bird.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_bird.jpg"><img src="gradient_bird.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="gradient_compose" id="gradient_compose"></a>
            <h3>Gradients by Composition</h3>You can also modify gradients by combining them using various composition methods. For example you can use the <a href="../compose/#modulus_add">Modulus_Add</a> compose method to produce Venetian blind types of gradients.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: \( +clone +clone \) \
          -background gray50 -compose ModulusAdd -flatten \
          gradient_venetian.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="gradient_venetian.jpg"><img src="gradient_venetian.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>And even do this diagonally.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient: \( gradient: -rotate -90 \) \
          \( -clone 0--1 -clone 0--1 \) \
          -background gray50 -compose ModulusAdd -flatten \
          gradient_vent_diag.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="gradient_vent_diag.jpg"><img src="gradient_vent_diag.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or by blending two plain color gradients using either <a href="../compose/#channel">Channel Copying</a>, or <a href="../compose/#math">Mathematical Blending</a> composition methods, you can generate colorful 2 dimensional colormap gradients.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 gradient:yellow-blue \
          \( gradient:black-lime -rotate -90 \) \
          -compose CopyGreen -composite  gradient_colormap.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="gradient_colormap.jpg"><img src="gradient_colormap.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="gradient_colorspace" id="gradient_colorspace"></a>
            <h3>Gradients in other Colorspaces</h3>While "<code>gradient:</code>" generator currently cannot generate gradients directly in some another <a href="../color_basics/#colorspace">Color Spaces</a>, (only non-linear sRGB gradient images are created) you can transfer gradients into a different color space to generate interesting effects. For example...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 xc:red -colorspace HSB \
          gradient: -compose CopyRed -composite \
          -colorspace RGB -rotate 90  gradient_rainbow.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_rainbow.jpg"><img src="gradient_rainbow.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>This first converts a highly saturated color ('<code>red</code>') into HSL colorspace, any saturated color can be used. This correctly sets the images saturation and brightness channels to the appropriate values. After this a gradient is generated and copied into the 'Hue' (equivalent to the 'red') channel of this HSL colorspace image. And hey presto when we magick the HSL image back to RGB, we get a full rainbow gradient of fully-saturated colors. Another method is to generate a gradient of just the right values for one of these colorspaces, then change the images colorspace (using "<code><a href="../option_link.cgi?set">-set</a></code>"). This changes the colorspace without changing the color values that we created in the image. Now when we magick back to RGB we get the same rainbow of values.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 gradient:'#FFF-#0FF' -rotate 90 \
          -set colorspace HSB -colorspace RGB \
          gradient_rainbow_2.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_rainbow_2.jpg"><img src="gradient_rainbow_2.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>The result is actually exactly the same as the previous method, just a little more direct, in that we generate the right values for the desired colorspace, then set the colorspace those values belong to. Here we take the masked angular gradient (see above) and re-map it into the HSB color space to generate a circular hue of colors. Red (hue=0) is rotated toward to the right, where it is traditionally placed (polar coordinates angle 0).
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x300 gradient:'#FFF-#0FF' -rotate 90 \
          -alpha set -virtual-pixel Transparent +distort Polar 49 +repage \
          -rotate 90 -set colorspace HSB -colorspace RGB \
          gradient_hue_polar.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_hue_polar.png"><img src="gradient_hue_polar.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>A similar example to the above is <a href="../color_basics/#colorwheel">Color Wheel</a>, which is generated by <a href="../color_basics/#combine">Combining Channel Images</a> with both a Hue and a Lightness gradient. <a name="gradient_resize" id="gradient_resize"></a>
            <h3>Resized Gradient</h3>One trick that was brought up on the by Glenn Randers-Pehrson, was to create a very small image, two pixels across, then expand that to the image size needed using "<code><a href="../option_link.cgi?resize">-resize</a></code>". The <a href="../resize/#resize">Resize Operator</a> tries to smooth out enlarged images, to make them look better at the larger scale. It is this smoothing that we use to generate a non-linear gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  For example, here we generate the small image using a 'portable bitmap' (or PBM format) image and feed it into IM for enlargement.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  echo "P1 1 2   0  1 " | \
  magick - -resize 100x100\!   gradient_resize.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_resize.jpg"><img src="gradient_resize.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Some shells like 'csh' and variants, cannot handle the '<code>!</code>' character in the above resize geometry setting very well -- not even in quotes. Hence the backslash '<code>\</code>' character may be needed. Caution is advised.</i></font></td>
              </tr>
            </table>The gradient produced is not linear, with a smooth start and finish to the colors given, making those colors much more pronounced, than you would get using a normal gradient. The actual function the gradient follows depends on (and is close to) the exact <a href="../filter/">Resampling Filter</a> that was used by resize.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  A simple way to generate that initial two-pixel image is actually with gradient itself! This lets you specify the colors directly. Of course that will limit you to a vertical gradient, unless you rotate the result as well.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x2  gradient:khaki-tomato \
          -resize 100x100\!   gradient_resize2.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_resize2.jpg"><img src="gradient_resize2.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Of course you are not limited to just a single dimension, with this technique. Here I use a four pixel 'portable greymap' (or PGM image format) to generate a 2-dimensional gradient.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  echo "P2 2 2 2   2 1 1 0 " | \
  magick - -resize 100x100\!   gradient_resize3.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_resize3.jpg"><img src="gradient_resize3.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see this diagonal gradient is not very linear when compared to the <a href="#gradient_rotate">Rotated Gradient</a> above.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The <a href="http://netpbm.sourceforge.net/">Network Portable Bitmap</a> image formats, are very versatile for generating images from scripts. It is a format that is well worth knowing as a means of generating or manipulating image data.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  If you look carefully you will also see that the gradient also starts from the center of the enlarged pixel, and does not cover the whole image from edge to edge. This becomes more clear if we use a <a href="../filter/#triangle">Triangle Resize Filter</a>.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -filter triangle -resize 100x100\!   gradient_resize4.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_resize4.jpg"><img src="gradient_resize4.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  The <a href="../resize/#resize">Resize Operator</a> smoothes the color between these pixels according to the "<code><a href="../filter/#filter">Resampling Filter</a></code>" setings. By adjusting the filter you can have the resize gradient generate a more edge to edge effect.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x2  gradient: \
          -filter Cubic  -resize 100x100\!    gradient_resize5.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_resize5.jpg"><img src="gradient_resize5.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Here is rough "Rainbow Gradient" created using the 'resize' technique.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick xc:black xc:red xc:yellow xc:green1 xc:cyan xc:blue xc:black \
          +append -filter Cubic -resize 600x30\! gradient_rs_rainbow.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_rs_rainbow.jpg"><img src="gradient_rs_rainbow.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>With this method you can use any color combination and order for the gradients generation. This makes it very well suited to generating <a href="../color_mods/#color_lut">Color Lookup Tables</a>. <a name="gradient_interpolate" id="gradient_interpolate"></a>
            <h3>Interpolated Lookup Gradients</h3>For more information on the "<code><a href="../option_link.cgi?interpolate">-interpolate</a></code>" setting see <a href="../misc/#interpolate">Interpolation Setting</a>. Another method of generating gradients is to use the special <a href="../misc/#interpolate">Interpolation Setting</a>. This setting is used to determine the pixel color returned when the pixel lookup is not an integer, and thus does not exactly match a specific pixel. Interpolation then determines the color based on the pixels that surround the lookup point. The default setting of '<code>bilinear</code>' for example will linearly determine the color for a lookup that falls between two pixels.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 600x30 xc:   \( +size xc:gold xc:firebrick +append \)  \
          -fx 'v.p{i/(w-1),0}'    gradient_interpolated.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_interpolated.jpg"><img src="gradient_interpolated.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Here the lookup X position '<code>i/(w-1)</code>' goes from '<code>0.0</code>' to '<code>1.0</code>' over the second two-pixel image. The floating point number produces a perfect linear gradient, much like "<code><a href="#gradient">gradient:</a></code>" does. The above is actually almost equivalent (see <a href="#perfect_gradients">Perfect Gradients</a> for difference) to using a <a href="../color_mods/#clut">Clut Recolored Images</a>" to recolor a gradient image, using interpolated lookup of the two color image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 gradient: -rotate 90 \
          \( +size xc:gold xc:firebrick +append \) -clut \
          gradient_clut_recolored.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_clut_recolored.jpg"><img src="gradient_clut_recolored.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Using this method also allows you to generate multi-colored gradients.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 gradient: -rotate 90  -interpolate Bicubic \
          \( +size xc:black xc:tomato xc:wheat +append \) -clut \
          gradient_clut.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_clut.jpg"><img src="gradient_clut.jpg" width="600" height="30" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>The limitation however is that the colors can only be defined with equal spacing. You can not simply shift the position of the middle color, except by roughly modifying the input gradient to some non-linear form, so as to shift that center. For more than three color is situation becomes worse. The above is also a good technique for coloring greyscale images using <a href="../color_mods/#duotone">Duotones</a>, with a guarantee on exactly defining the mid-tone color (unlike using the <a href="../color_mods/#tint">Tint Operator</a>).<br>
            Interpolated lookup gradients can also be expanded to 2 dimensions, and generate square linear gradients (<a href="../misc/#bilinear">Bilinear Interpolation</a>), just as easily as purely one dimensions gradients.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -size 100x100 xc: +swap  -fx 'v.p{i/(w-1),j/(h-1)}' \
          gradient_bilinear.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_bilinear.jpg"><img src="gradient_bilinear.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Here is the same example but using <a href="../misc/#catrom">Catrom Interpolation</a>, and generating using the <a href="../distorts/#distort">Distort Operator</a> instead of the very slow FX operator.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -filter point -interpolate catrom \
          -define distort:viewport=100x100 \
          -distort Affine '.5,.5 .5,.5   1.5,1.5 99.5,99.5' \
          gradient_catrom.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_catrom.jpg"><img src="gradient_catrom.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The key point to understanding the above is that we are enlarging the small image based on the centers of its pixels. See <a href="../distorts/#control_coordinates">Image Coordinates vs Pixel Coordinates</a> for details. Note that most interpolation methods have equivalent <a href="../filter/#interpolate">Interpolated Resize Filters</a>. But the use of the viewport and pixel coordinates removes the edge effects that is shown in the previous <a href="#gradient_resize">Resize Gradients</a> caused by extreme upscaling of the very small image.<br>
            The <a href="../misc/#mesh">Mesh Interpolation</a> setting however is not available as a <a href="../filter/#filter">Resize Filter</a>. It is a special 2 dimensional interpolation that divides the intra-pixel area into two flat linear triangles, hinged along the diagonal connecting the corners with the minimal color difference. So by making two colors the same color, and using "<code>-interpolate mesh</code>" you can generate a very different 2D gradient.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick \( xc:red xc:gold +append \) \
          \( xc:gold xc:green +append \) -append \
          -filter point -interpolate mesh \
          -define distort:viewport=100x100 \
          -distort Affine '.5,.5 .5,.5   1.5,1.5 99.5,99.5' \
          gradient_mesh.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_mesh.jpg"><img src="gradient_mesh.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As the two diagonally opposite yellow corners are the same, a diagonal of yellow was used to join them. With the other colors linearly mapped to those triangles. If the two diagonal colors are not the same, you may get a different diagonal division. <a name="gradient_fx" id="gradient_fx"></a>
            <h3>Roll your own gradient</h3>The <a href="../transform/#fx">FX DIY Operator</a>, lets you define your own gradients or other image generation, based on the current pixel position. As this operator requires an image to work with, you can generate your gradients or other images to match that image. That is, you don't have to know the size of the image to generate a gradient for it! For example you can easily generate a linear gradient, sized correctly for the image you may be working on.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -channel G -fx 'i/w' -separate   gradient_fx_linear.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_linear.gif"><img src="gradient_fx_linear.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>When generating gray-scale gradients, you can make the -fx operator 3 times faster, simply by asking it to only generate one color channel only, such as the '<code>G</code>' or green channel in the above example. This channel can then be <a href="../color_basics/#separate">Separated</a> to form the required gray-scale image. This can represent a very large speed boost, especially when using a very complex "<code><a href="../option_link.cgi?fx">-fx</a></code>" formula.</i></font></td>
              </tr>
            </table>You can even generate some neat non-linear gradients.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -channel G -fx '(i/w)^4' -separate   gradient_fx_x4.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_x4.gif"><img src="gradient_fx_x4.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr>
                <td>
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -channel G -fx 'cos(pi*(i/w-.5))' \
           -separate   gradient_fx_cos.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_cos.gif"><img src="gradient_fx_cos.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  How about a 2-dimensional circular linear radial gradient (a cone).
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -channel G \
          -fx 'rr=hypot(i/w-.5, j/h-.5); 1-rr*1.42' \
          -separate gradient_fx_radial.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_radial.gif"><img src="gradient_fx_radial.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?fx">-fx</a></code>" function '<code>rr=hypot(xx,yy)</code>' was added to IM v6.3.6 to speed up the very commonly used expression '<code>rr=sqrt(xx*xx+yy*yy)</code>'. It also meant that we no longer need to make extra assignments such as '<code>xx=i/w-.5</code>' when creating a radial gradient.</i></font></td>
              </tr>
            </table>The value '<code>1.42</code>' (or <code>sqrt(2)</code>) in the above controls the overall size of the gradient relative to the images dimensions. In this way the radius of the gradient (how far black is from center) is diagonal distance to the corner.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You can even remove the '<code>sqrt()</code>' (built into the '<code>hypot()</code>' function) from the expression to make a more interesting spherical gradient, which can be useful for <a href="../transform/#shade">3D Shading Effects</a>.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -channel G \
          -fx 'xx=i/w-.5; yy=j/h-.5; rr=xx*xx+yy*yy; 1-rr*4' \
          -separate gradient_fx_spherical.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_spherical.gif"><img src="gradient_fx_spherical.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note how I use some assignment expressions to simplify the calculation of the distance from center of the image, then magick it to a gradient. This feature was added in IM v6.3.0.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Using a high power function, you can give photos a fade off effect around the rectangular edges of the image. Adjust the power value '<code>4</code>' to control the amount of fading.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -channel G \
          -fx '(1-(2*i/w-1)^4)*(1-(2*j/h-1)^4)' \
          -separate  gradient_fx_quad2.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_quad2.gif"><img src="gradient_fx_quad2.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Here is an angular gradient, generated using direct mathematics.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -channel G \
          -fx '.5 - atan2(j-h/2,w/2-i)/pi/2' \
          -separate  gradient_fx_angular.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_fx_angular.gif"><img src="gradient_fx_angular.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the '<code>atan2(y,x)</code>' function returns an angle in radians from -PI to +PI (see its manpage), so its output needs to be be scaled and translated to correctly fit a 0.0 to 1.0 color range. This is why the above looks so much more complex than it really is.This last example can be generated faster by <a href="#gradient_distort">Distorting a Gradient</a>. <a name="gradient_complex" id="gradient_complex"></a>
            <h3>More Complex DIY Gradients</h3><i>ASIDE: This section was created before the addition of <a href="#sparse-color">Sparse Points of Color</a>, and the had a direct influence on its creation.</i> Of course an FX function can generate color gradients. For example, here is a gradient based on distance ratios, using an extremely complex FX expression.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="">
  magick -size 100x100 xc: +size xc:red xc:yellow -colorspace RGB \
          -fx 'ar=hypot( i/w-.8, j/h-.3 )*4;
               br=hypot( i/w-.3, j/h-.7 )*4;
               u[1]*br/(ar+br) + u[2]*ar/(ar+br)' \
          -colorspace RGB gradient_dist_ratio.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_dist_ratio.gif"><img src="gradient_dist_ratio.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The image processing was performed in a linear color space (RGB) to avoid 'sRGB darken' during the blending of such strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.</i></font></td>
              </tr>
            </table>When going from two points to three points the ratio of how much color each 'control point' provides, is a bit more complex, and uses a technique called Inverse Distance Weighted (IDW) Interpolation. You can see more details math for this in <a href="http://en.wikipedia.org/wiki/Inverse_distance_weighting">Wikipedia, IDW</a> Here is an inverse distance example for three points.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="">
  magick -size 100x100 xc: +size xc:red xc:yellow xc:lime -colorspace RGB \
          -fx 'ar=1/max(1, hypot(i-50,j-10)  );
               br=1/max(1, hypot(i-10,j-70)  );
               cr=1/max(1, hypot(i-90,j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB gradient_inverse.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_inverse.gif"><img src="gradient_inverse.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>And here I use an inverse distance squared which is the more normal method used for an IDW interpolation. This is also known as Shepard's Interpolation method.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="">
  magick -size 100x100 xc: +size xc:red xc:yellow xc:lime -colorspace RGB \
          -fx 'ar=1/max(1,  (i-50)*(i-50)+(j-10)*(j-10)  );
               br=1/max(1,  (i-10)*(i-10)+(j-70)*(j-70)  );
               cr=1/max(1,  (i-90)*(i-90)+(j-90)*(j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB gradient_shepards.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_shepards.gif"><img src="gradient_shepards.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the '<code>hypot()</code>' function was not used in the above as there is no need to generate a square root of the distance. The above has now been implemented using the <a href="#sparse-color">Sparse Color</a> methods '<code><a href="#inverse">Inverse</a></code>' and '<code><a href="#shepards">Shepard's</a></code>'. As such the above can now be done far more simply using...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '50,10 red  10,70 yellow  90,90 lime' \
          -colorspace sRGB  gradient_inverse_alt.gif
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Shepards '50,10 red  10,70 yellow  90,90 lime' \
          -colorspace sRGB  gradient_shepards_alt.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_inverse_alt.gif"><img src="gradient_inverse_alt.gif" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <a href="gradient_shepards_alt.gif"><img src="gradient_shepards_alt.gif" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
            </div>The problem with using either 'Inverse Distance' or 'Shepard's Method' (inverse squared distance) is that all the 'control points' has a global effect over the whole image. As a result you get a sort of underlying 'average color' in between the points, and especially at a large distance from all control points. This, in turn, produces 'spots' of color rather than a smooth gradient of color. <a name="gradient_complex_hues" id="gradient_complex_hues"></a>
            <h3>DIY Gradients and Hues<br>
            <font size="-1">-- (Hues are hard to deal with)</font></h3><i>ASIDE: This was a sort of failed attempt to generate an interesting rainbow effect. It was a failure, but I learned a lot from that failure, which I present to you here.</i> The above works well but I wanted to try and to do better. I thought perhaps I could generate a bright rainbow gradient of colors between the points, rather than generating spots that merges into an average color. So to generate a hue gradient, I tried to do the <a href="http://en.wikipedia.org/wiki/Inverse_distance_weighting">Inverse Distance Weighted Interpolation</a> in HSB colorspace, though I switched the yellow to blue, to make the colors more equally spaced around the hue, and hopefully provide another way of generating a color wheel (see <a href="#gradient_colorspace">Gradients in Other Colorspaces</a> above).
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="">
  magick -size 100x100 xc: +size xc:red xc:blue xc:lime -colorspace HSB \
          -fx 'ar=1/max(1,  (i-50)*(i-50)+(j-10)*(j-10)  );
               br=1/max(1,  (i-10)*(i-10)+(j-70)*(j-70)  );
               cr=1/max(1,  (i-90)*(i-90)+(j-90)*(j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB   gradient_shepards_HSB.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_shepards_HSB.gif"><img src="gradient_shepards_HSB.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see all the colors were nice an bright as we are only generating a hue gradient. However it also appears very strange, which is caused by the 'cyclic' nature of the 'Hue' color channel. As a consequence the area between the blue and the red goes the long way round though a green hue, rather than that the shorter 'modulus' path via a purple hue. After much research I finally discovered how to do the modulus mathematics needed to do the above correctly by using a <a href="http://en.wikipedia.org/wiki/Circular_mean">Circular Mean</a> for the weighted average of distances. This involves converting the Hue as a polar angle, into X and Y rectangular coordinates. That allows you to perform linear mathematics, letting us perform a linear weighting of the values, appropriately. The result is then then converting back into an angular Hue.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="">
  magick -size 100x100 xc: +size xc:red xc:blue xc:lime \
          -colorspace HSB -channel R \
          -fx 'aa=u[1]*2*pi; ba=u[2]*2*pi; ca=u[3]*2*pi;
               ar=1/max(1, hypot(i-50,j-10) );
               br=1/max(1, hypot(i-10,j-70) );
               cr=1/max(1, hypot(i-90,j-90) );
               nr=ar+br+cr;
               mod(atan2( ( sin(aa)*ar + sin(ba)*br + sin(ca)*cr )/nr,
                         ( cos(aa)*ar + cos(ba)*br + cos(ca)*cr )/nr
                       )/(2*pi)+1, 1)' \
          -separate -background white -combine +channel \
          -set colorspace HSB -colorspace sRGB  gradient_circular_mean_hue.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_circular_mean_hue.gif"><img src="gradient_circular_mean_hue.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>NOTE: The above only performed its operations on the hue channel only. For real image, we would still need to operate (as normal) on saturation and brilliance channels. As you can see we now get a correct gradient between the red and blue, though the method when applied to just primary colors that have a high angular separation, tends to generate very sudden gradient changes in the middle. That is, while the result is correct the angular hue variation is not linear for very large changes in hue effects. It would work well for averaging lots of near hues, but not for these widely spaced primaries. I even switched to using a stronger 'Inverse Weighting' rather than the more usual 'Inverse Squared' or 'Shepard's' method (see above) and while it improved things, the hue changes were still compressing in the center due to the non-linear effects. As the input colors are constant, pre-converting them into hue-x, and hue-y coordinates, doing the shepard's weighting on those channels, then converting back again would actually make the process even faster. That is, convert colors from a HSB colorspace to a Hx,Hy,S,B colorspace, to apply the technique. If this is done, then central point and even gradient between the points, would shade to white (the center point of a HSB colorspace). If this was performed in HSL colorspace that area would shade toward a mid-tone gray.<br>
            This conversion from a polar Hue to X-Y coordinates would in some ways be similar to just doing the calculations in a non-polar RGB space, which shows that same shade toward gray effects (see previous examples). So if by using a <a href="http://en.wikipedia.org/wiki/Circular_mean">Circular Mean</a> we are in fact simply converting a HSB colorspace into a highly distorted variant RGB, why not just do the task in a linear RGB colorspace, and saturate the colors, to generate the hue!
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '50,10 red  10,70 blue  90,90 lime' \
           -colorspace sRGB gradient_inverse_RGB.png
  magick gradient_inverse_RGB.png -colorspace HSB \
          -channel GB -evaluate set 100% +channel \
          -colorspace sRGB gradient_inverse_RGB_Hue.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="gradient_inverse_RGB.png"><img src="gradient_inverse_RGB.png" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="gradient_inverse_RGB_Hue.gif"><img src="gradient_inverse_RGB_Hue.gif" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
            </div>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The image processing was performed in a linear color space (RGB) to avoid 'sRGB darken' during the blending of such strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.</i></font></td>
              </tr>
            </table>As you can see we get practically exactly the same result as before, but with all the complex 'modulus mathematics' removed. However I am still no closer to getting a more linear spread of hues between the starting points of color. The moral of all this is that working with Hues is hard, not only due to the 'red discontinuity', but also because of non-linear effects that happen when colors are very widely spaced. And in the end the result was the same as if I have done the task directly linear RGB space and saturating the colors. Essentially while HSB and HSL colorspaces are fun, they are not linear, realistic, or practical colorspaces to work with. This is also probably why very few operations actually work with hue directly. <a name="perfect_gradients" id="perfect_gradients"></a>
            <h3>Generating the Perfect Gradient (mathematically)</h3>Generating perfect mathematical gradient, such as for <a href="../fourier/">Fourier Transforms</a> (which is cyclic), <a href="../mapping/#distort">Image Mapping</a>, or even <a href="../transform/#gradient_math">Gradient Mathematics</a>; requires special gradients that is different to the gradients we have so far looked at.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  What do I mean by this? Well here is a small 1x5 pixel "<code>gradient:</code>" image, that I have <a href="../resize/#scale">Scaled</a> so you can see the individual pixel colors.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x5 gradient:  -scale 2000% gradient.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient.png"><img src="gradient.png" width="20" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This image creates a gradient that goes from an exact 'white' color along the very top row, to an exact 'black' color along the bottom most row. It is an 'idealized' gradient, and typically exactly what an user wants, as it actually contains the actual colors the user specified. However while this is what an user expects, it is not a mathematically correct gradient. As discussed in <a href="../distorts/#control_coordinates">Image Coordinates vs Pixel Coordinates</a> pixels actually have an area, and as such the white pixel at the top of the image represents the center of that pixel, while the black represents the center of he bottom most pixel. That is, not the edge of the image but 1/2 pixel away from the edge. Mathematically images start at the edge. As such to generate a perfect mathematical gradient, you need to specify the color locations at the edge of the image, in pixel coordinates. As such in image coordinates, the positions are displaced by 1/2 a pixel, and the image size is exactly the number of pixels in the image (a distance), rather than a location that is 1 pixel smaller that the images size. One way to generate a mathematically perfect gradient is to use <a href="#barycentric">Barycentric Sparse Color</a> (looked at in detail in the next section) to generate a perfect edge-to-edge gradient...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x5 xc: \
          -sparse-color Barycentric '0,-0.5 white  0,%[fx:h-.5] black' \
          -scale 2000%  gradient_math.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_math.png"><img src="gradient_math.png" width="20" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that the coordinates used go from <code>-0.5</code> to the images height minus <code>0.5</code>, That the pixel coordinates of the actual edges of the image. And if you were to look closely at the results you will find that the top and bottom most pixels are <i>not white or black in color</i>. The pixel is the color of the gradient at the pixels center. Because this gradient is mathematically correct, this gradient will 'tile' correctly when used in special 'tiling' or 'cyclic' situations. The previous gradient image will not 'tile' correctly. You get a pure-white pixel, next to, the pure-black pixel, so as to generate an one pixel gap or 'disjunction' in the mathematical cycle, in situations where pure white and pure black are typically regarded as equivalent values. A simpler way is to generate a "<code><a href="#gradient">gradient:</a></code>" image that is one pixel longer, and chop one pixel, from either end (according to the current "<code><a href="../option_link.cgi?gravity">-gravity</a></code>" setting).
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  For example, here chopped the top-most white pixel, as having a black pixel (or zero value) is often more desirable in the final result.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 1x6 gradient: -chop 0x1 -scale 2000%  gradient_chopped.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="gradient_chopped.png"><img src="gradient_chopped.png" width="20" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The resulting gradient image can then be <a href="../warping/#rect_rotates">Rotated</a> as needed, to then generate the required image for later image processing. However while this gradient will 'cycle' correctly, the actual position of the color is not exactly correct. But in many cases this is good enough. If you need a 'perfect gradient' I recommend you use a sparse color gradient. <b>In Summery...</b> A little thought about exactly what you want from your gradient can make a big difference in the accuracy of your final results. But if it does not matter, than don't worry about it, use whatever is simplest for the task at hand.<br>
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="sparse-color" id="sparse-color"></a>
            <h2>Sparse Points of Color</h2>The "<b><code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code></b>" operator was added to IM v6.4.3-0 will take an image and set the color given at each of the given floating point '<code>x,y</code>' coordinates. That is, of the form...
            <div align="center">
              <pre>-sparse-color {method}  'x,y color   x,y color   x,y color ...' </pre>
            </div>The rest of the pixels (limited according to the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting) will then be mapped according to there relation to these isolated points of color, so as to smooth out the colors between those points. The <i>method</i> defines what that relationship will be. Naturally there are lots of ways to define what the intervening color should be, and which method you choose really depends on what you are attempting to achieve. It can also actually be classed as a completely free-form version of 2-dimensional interpolation (See <a href="http://en.wikipedia.org/wiki/Interpolation">Interpolation, Wikipedia</a>). Image enlargement, or <a href="../resize/#resize">Resize</a> is actually a specialized sub-set of this, but one where you start with a complete fixed grid of pixels to be enlarged. Unfortunately few of the <a href="../filter/#filter">Resize Filters</a> or <a href="../misc/#interpolate">Interpolate Methods</a> that are specifically designed to dealing with a grid of points, will translate directly into a free form set of sparsely separated points of color. That is, to say resize involving incomplete grid just does not work. This is also related to "Geographical Information System (GIS)" methods where landscapes are measured using sparsely separated points of height (which are rarely in a strict grid), with the rest of the landscape being determined from those isolated points. In a similar situation meteorology often has isolated points of air pressure and temperature, which then needs to be interpolated. Typically after interpolation the maps are further processed to generate 'iso-lines' showing points of equal value (height, pressure, temperature), producing the various weather maps almost everyone are familiar with. In this case you would think of the generated image as being a simple gray-scale 'height map' of the input data, or perhaps even of all three variables simultaneously, each to a separate image 'channel'. <a name="barycentric" id="barycentric"></a>
            <h3>Barycentric <font size="-1">(triangle gradient)</font></h3>The "<code>Barycentric</code>" method, will map three and only three points into a linear triangle of color. The colors outside this triangle continue as before. I have marked the input points with a small circle, so that the colors you see are all the interpolated values that were generated by the <a href="#sparse-color">Sparse Color Operator</a>.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_barycentric.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_barycentric.png"><img src="sparse_barycentric.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The image processing was performed in a linear color space (RGB) to avoid 'sRGB darken' during the blending of such strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.</i></font></td>
              </tr>
            </table>If four or more points are given a 'best fit' will be performed, over all the points given, and as a result the actual points may not get the exact color specified for those points. However be warned that the gradient does not just 'stop' but continues to change beyond those points. Traditionally a barycentric gradient will be limited to within the enveloping triangle of the points used to generate it. For example..
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          \( -size 100x100 xc:black -draw 'polygon 30,10  10,80  90,90' \) \
          -alpha off -compose CopyOpacity -composite \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_triangle.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bary_triangle.png"><img src="sparse_bary_triangle.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This is a faster version from Fred Weinhaus, that creates a triangle mask in the alpha channel, which by default, the <a href="#sparse-color">Sparse Color Operator</a> will not update (due to the default channel settings). All the colors including fully transparent pixels are however still filled with color, just alpha masked.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:none -draw "polygon 30,10  10,80  90,90" \
          -colorspace RGB \
          -sparse-color Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB   sparse_bary_triangle_2.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bary_triangle_2.png"><img src="sparse_bary_triangle_2.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The triangular masks used above are 1/2 pixel too big due to the way draw draws an extra line around its shapes. See <a href="../draw/#bounds&quot;">Draw Fill Bounds</a> for details. This could be a problem when generating a generating a triangular mesh of gradients.</i></font></td>
              </tr>
            </table>The '<code>barycentric</code>' method is in reality a mapping of a linear affine equation to each of the three color channels separately. As such if I separate each of the color channels of the above three point example, you get three simple linear gradients in each color channel.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_barycentric.png -separate sparse_bary_%d.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="sparse_barycentric.png"><img src="sparse_barycentric.png" align="middle" vspace="1" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="sparse_bary_0.gif"><img src="sparse_bary_0.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="sparse_bary_1.gif"><img src="sparse_bary_1.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="sparse_bary_2.gif"><img src="sparse_bary_2.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>It is only because of the use of primary colors that the above gradients all were mapped parallel to one of the edges of the triangle. That is, not typically the case. But you will always get a simple linear gradient in each separate channel of the image, and a flat plane of values in 3D color space. <a name="two_color_gradients" id="two_color_gradients"></a>
            <h4>Barycentric and Two Color Gradients</h4>This parallel effect of the triangular barycentric gradient is actually very useful. If two of the points were set to the same color, then those to points will define the 'angle' of the gradient between them and the other colored point. For example by making two of the points '<code>red</code>' the gradient will be made parallel to the two '<code>red</code>' points...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '30,10 red   10,80 red   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_gradient.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bary_gradient.png"><img src="sparse_bary_gradient.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Here is the same example but with one of the angle control points moved to show how it sets the gradient angle.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '50,70 red   10,80 red   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 50,70 50,72  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_gradient_2.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bary_gradient_2.png"><img src="sparse_bary_gradient_2.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="diagonal_gradients" id="diagonal_gradients"></a>
            <h4>Diagonal Gradients</h4>This provides a simple way of generating any linear diagonal gradient using just two colors. For example, here is a particularly nice way of creating a diagonal gradient, going from one corner to another corner, for ANY sized input image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,0 skyblue  -%w,%h skyblue  %w,%h black' \
          -colorspace sRGB diagonal_gradient.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="diagonal_gradient.jpg"><img src="diagonal_gradient.jpg" width="600" height="60" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>And to align with the other two corners...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,%h black  -%w,0 black  %w,0 skyblue' \
          -colorspace sRGB diagonal_gradient_2.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="diagonal_gradient_2.jpg"><img src="diagonal_gradient_2.jpg" width="600" height="60" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div>These 'diagonal gradients' produce a natural looking gradient even with long images such as the above. Study the locations of the three color points, especially the two points of equal color that define the angle of the gradient between the two corners. Notice that in both cases one of the those points is not even located within the image itself! Also note the use of <a href="../basics/#arg_percent">Percent Escapes</a> to make the positions automatically adjust to the size of the images on which the gradient is being drawn. <a name="two_point_gradients" id="two_point_gradients"></a>
            <h4>Two Point Gradients</h4>If only two color points are given, IM will generate the third point for you, so that the angle is perpendicular between the two original points. The result is a simple linear gradient over which you have a lot of control.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -colorspace RGB \
          -sparse-color  Barycentric '30,10 red  90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 90,90 90,92' \
          sparse_bary_two_point.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bary_two_point.png"><img src="sparse_bary_two_point.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Two point gradients however do not work very well when applied to the corners of very 'wide' or 'tall' images (high-aspect ratio). Basically the gradient is not diagonally aligned, unlike the three point gradients above. It is angled, just not angled enough to make it 'interesting'.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,0 skyblue  %w,%h black' \
          -colorspace sRGB  sparse_bary_two_point_wide.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="sparse_bary_two_point_wide.jpg"><img src="sparse_bary_two_point_wide.jpg" width="600" height="60" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
            </div><a name="bilinear" id="bilinear"></a>
            <h3>Bilinear <font size="-1">(4 point gradient)</font></h3>This method fits an equation to 4 points, over all three color channels to produce an uniform color gradient between the points, and beyond.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -colorspace RGB \
    -sparse-color Bilinear '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_bilinear.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_bilinear.png"><img src="sparse_bilinear.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>You can see this '4 point fit' by taking the above image and separating out the individual color channel gradients.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_bilinear.png -separate sparse_bilin_%d.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="sparse_bilinear.png"><img src="sparse_bilinear.png" align="middle" vspace="1" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="sparse_bilin_0.gif"><img src="sparse_bilin_0.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="sparse_bilin_1.gif"><img src="sparse_bilin_1.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="sparse_bilin_2.gif"><img src="sparse_bilin_2.gif" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>Note how the equation produces curves (quadratic curves actually). However if the 4 points form parallel lines, the gradient generated will become linear. This method is actually equivalent to the <a href="../misc/#bilinear">Bilinear Interpolation</a> method (see <a href="#gradient_interpolate">Interpolated Lookup Gradients</a> below), when the 4 points are aligned to a orthogonal (rectangular) grid. If less than 4 points are given the above function will be replaced by a 3 point '<code><a href="#barycentric">Barycentric</a></code>' method (see above). If more than four points are given it will do a best fit of all the points, and thus may not actually match the given color at the point specified. This is not recommended. <a name="voronoi" id="voronoi"></a>
            <h3>Voronoi <font size="-1">(nearest color)</font></h3>The "<code>Voronoi</code>" method, just maps each pixel to the closest color point you have provided. This basically divides the image into a set of polygonal 'cells' around each point. For example..
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_voronoi.gif"><img src="sparse_voronoi.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see no attempt is made to provide anti-aliasing of the colored 'cells' around each point. The edge of each cell actually falls exactly midway between each point's nearest neighbours. This can be used for example to generate masks to cut up the image in various ways. Just assign one point as white and all the rest as black to extract one single 'cell' from the image. If you want to smooth (anti-alias) the result you can either use some form of <a href="../distorts/#super_sampling">Super Sampling</a> to smooth the image. For example generate one 4 times as big, and "<code><a href="../option_link.cgi?scale">-scale</a></code>" it back to the desired size.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 400x400 xc: -colorspace RGB \
    -sparse-color Voronoi '120,40 red 40,320 blue 270,240 lime 320,80 yellow' 
\
    -scale 25%  -colorspace sRGB -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_ssampled.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_voronoi_ssampled.png"><img src="sparse_voronoi_ssampled.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>All the image processing was performed in a linear color space (RGB) to avoid 'sRGB darken' during the blending of such strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.</i></font></td>
              </tr>
            </table>The simpler way (though not very nice) is to just simply blur the image very slightly...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
    -sparse-color Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 1x0.7  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_smoothed.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_voronoi_smoothed.png"><img src="sparse_voronoi_smoothed.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>By blurring generated image by a large amount you can set up some non-linear gradients between the 'cells' that was generated.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 0x15  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_blur.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_voronoi_blur.png"><img src="sparse_voronoi_blur.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The larger the "<code><a href="../option_link.cgi?blur">-blur</a></code>", the larger the gradient between the various 'cells'. However be warned that this may not preserve small colored cells, or ensure the original point remains the color that was given, if it is close to the edge (and another point) of a different color. By using a special 'linear blur' technique, developed by Fred Weinhaus, you can produce a fixed width linear gradient between the cells.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 10x65535  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_gradient.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_voronoi_gradient.png"><img src="sparse_voronoi_gradient.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The unblurred output could also passed to various <a href="../transform/#edge">Edge Detection</a> techniques to generate various bounded edges. You can remap the image via a <a href="../transform/#edge_vector">Raster to Vector Convertor</a> to generate vector lines. However I found the default '<code>autotrace</code>' settings may need to be adjusted with "<code>-corner-threshold 120</code>" so it will detect the corners better. <a name="shepards" id="shepards"></a>
            <h3>Shepards <font size="-1">(spots of color)</font></h3>The "<code>Shepards</code>" method uses a ratio of the inverse squares of the distances to each of the given points to determine the color of the canvas at each point. See <a href="#gradient_complex">More Complex DIY Gradients</a> above for examples of how the mathematics is performed. It is a bit like having spotlights of color at each point which interacts with each other, as the light spreads out to an uniform average of all the given colors at infinity.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
    -sparse-color  Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_shepards.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_shepards.png"><img src="sparse_shepards.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The image processing was performed in a linear color space (RGB) to avoid 'sRGB darken' during the blending of such strong primary colors. See <a href="../color_basics/#processing">Processing Real Images</a> for more details.</i></font></td>
              </tr>
            </table>By surrounding a specific area with a similar color you can generate a plateau of that specific color, though the boundaries between the edging points may 'leak', and the center of the 'plateau' may sag to form shallow bowl (depending on distance to other color points). This method is also what is used to generate a displacement field, such as what is used in <a href="../distorts/#shepards">Shepards Image Distortions</a>. In that case X and Y displacement vectors is what is being mapped rather than color R,G,B values. <a name="inverse" id="inverse"></a>
            <h3>Inverse <font size="-1">(sharp points of color)</font></h3>The "<code>Inverse</code>" method is practically identical to "<code>Shepards</code>", except that it uses a more direct inverse distance weighting of the points given. See <a href="#gradient_complex">More Complex DIY Gradients</a> above for examples of how the mathematics is performed. This was a much later addition to ImageMagick version 6.6.9-7. For example...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
    -sparse-color  Inverse '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_inverse.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_inverse.png"><img src="sparse_inverse.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see it generates sharp points of color, that quickly merges into the background 'average color'. In comparison to <a href="#shepards">Shepards Method</a> which generates rounded spots, with a 'flat' color around the color points. It does however work better when generating linear gradients where all the control points form a line. That is, for generating 1 dimensional gradients along a specific line in the image. However there is one more point to be made. The speed of how fast these points of color drops to a near 'average' level is controlled my how close they are. Placing two point sources close together, and they drop quickly, the further apart they are and the larger individual colors influence results.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '45,45 red  55,55 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 45,45 45,47  circle 55,55 55,57' \
          sparse_inverse_near.png
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '30,30 red  70,70 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,30 30,32  circle 70,70 70,72' \
          sparse_inverse_far.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="sparse_inverse_near.png"><img src="sparse_inverse_near.png" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <a href="sparse_inverse_far.png"><img src="sparse_inverse_far.png" width="100" height="100" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a>
            </div>Also if you 'double up' a specific point (exactly on, or just near each other) with the same or similar color, you will make that color point, twice as strong.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '30,30 red  75,65 lime  65,75 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,30 30,32  circle 75,65 75,67  circle 65,75 65,77 ' 
\
          sparse_inverse_stronger.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_inverse_stronger.png"><img src="sparse_inverse_stronger.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>These effects also applies to '<code><a href="#shepards">Shepards</a></code>' method too! <a name="shepards_power" id="shepards_power"></a>
            <h3>Shepards Power Factor</h3>Both the <a href="#shepards">Shepards</a> and <a href="#inverse">Inverse</a> sparse color methods are actually the same but with different 'power levels' applied to the inverse distance weights. (2.0 and 1.0 respectiavally). As of IM v6.8.0-10, you can set this power level using an operational <a href="../basics/#define">define</a>, '<code>shepards:power</code>', which will be used by the '<code><a href="#shepards">Shepards</a></code>' method. For example
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -colorspace RGB -define shepards:power=0.5 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow0.5.png
  magick -size 100x100 xc: -colorspace RGB -define shepards:power=1 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow1.png
  magick -size 100x100 xc: -colorspace RGB -define shepards:power=2 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow2.png
  magick -size 100x100 xc: -colorspace RGB -define shepards:power=3 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow3.png
magick -size 100x100 xc: -colorspace RGB -define shepards:power=8 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow8.png
</samp></pre>
                  </td>
                </tr>
              </table>
              <table>
                <tr valign="top">
                  <td align="center">
                    <a href="sparse_shepards_pow0.5.png"><img src="sparse_shepards_pow0.5.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 0.5</font>
                  </td>
                  <td align="center">
                    <a href="sparse_shepards_pow1.png"><img src="sparse_shepards_pow1.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 1.0<br>
                    (inverse)</font>
                  </td>
                  <td align="center">
                    <a href="sparse_shepards_pow2.png"><img src="sparse_shepards_pow2.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 2.0<br>
                    (shepards)</font>
                  </td>
                  <td align="center">
                    <a href="sparse_shepards_pow3.png"><img src="sparse_shepards_pow3.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 3.0</font>
                  </td>
                  <td align="center">
                    <a href="sparse_shepards_pow8.png"><img src="sparse_shepards_pow8.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                    <font size="-1">power 8.0</font>
                  </td>
                </tr>
              </table>
            </div>As you can see the 'spots of color' expand from very sharp points, to rounded spots, and on to large areas of color. At very high power levels it will eventually reproduce the same pattern as a <a href="#voronoi">Voronoi Sparse Color Method</a>. This <a href="../basics/#define">-define</a> not only effects <a href="#shepards">Shepards Sparse Color</a>, but also will have similar effects on <a href="../distorts/#shepards">Shepards Distortion Method</a> which is based on calculated displacement maps generated by the sparse color method. However it does not effect the <a href="#inverse">Inverse</a> sparse color method, which always uses a power-level of 1.0. <a name="sparse_summery" id="sparse_summery"></a>
            <h3>Summery of Sparse Color Methods</h3>Here is a repeat of the various, 4 point "<code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code>" images, for comparison.
            <table align="center" width="90%">
              <tr>
                <td align="center">
                  <a href="sparse_voronoi.gif"><img src="sparse_voronoi.gif" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Voronoi</font>
                </td>
                <td align="center">
                  <a href="sparse_voronoi_blur.png"><img src="sparse_voronoi_blur.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Voronoi (blurred)</font>
                </td>
                <td align="center">
                  <a href="sparse_shepards.png"><img src="sparse_shepards.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Shepards</font>
                </td>
                <td align="center">
                  <a href="sparse_inverse.png"><img src="sparse_inverse.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Inverse</font>
                </td>
                <td align="center">
                  <a href="sparse_bilinear.png"><img src="sparse_bilinear.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Bilinear</font>
                </td>
              </tr>
            </table>And here is a summery of the various, 3 point methods. <!--<CODE EXECUTE>
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Voronoi '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_voronoi_3pt.gif
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Voronoi '30,10 red   10,80 blue   90,90 lime' \
          -blur 0x15  -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_voronoi_blur_3pt.png
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Shepards '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_shepards_3pt.png
  magick -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_inverse_3pt.png
</CODE>-->
            <table align="center" width="90%">
              <tr>
                <td align="center">
                  <a href="sparse_voronoi_3pt.gif"><img src="sparse_voronoi_3pt.gif" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Voronoi</font>
                </td>
                <td align="center">
                  <a href="sparse_voronoi_blur_3pt.png"><img src="sparse_voronoi_blur_3pt.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Voronoi (blurred)</font>
                </td>
                <td align="center">
                  <a href="sparse_shepards_3pt.png"><img src="sparse_shepards_3pt.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Shepards</font>
                </td>
                <td align="center">
                  <a href="sparse_inverse_3pt.png"><img src="sparse_inverse_3pt.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Inverse</font>
                </td>
                <td align="center">
                  <a href="sparse_barycentric.png"><img src="sparse_barycentric.png" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <font size="-1">Barycentric</font>
                </td>
              </tr>
            </table>At this time only '<code><a href="#voronoi">Voronoi</a></code>', '<code><a href="#shepards">Shepards</a></code>' and '<code><a href="#inverse">Inverse</a></code>' methods are suitable for more than four points. <i>More "<code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code>" methods are planned. If you have any ideas mail them to me.</i> <a name="sparse_channel" id="sparse_channel"></a>
            <h3>Channel and Sparse Color</h3>The "<code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code>" operator is effected by the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting which means you can use that setting to limit its effects to just a single channel, or expand it to the transparency channel. You can also use the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting to speed up processing of gray-scale images by only operating on one channel, then "<code><a href="../option_link.cgi?separate">-separate</a></code>" that channel (see <a href="../color_basics/#channel">Channel Handling</a> for more detail). For example..
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -channel G -sparse-color Shepards \
              '30,10 gray70  10,80 black  70,60 white  80,20 gray(33.3333%)' \
          -separate +channel    -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82' \
          -draw 'circle 70,60 70,62  circle 80,20 80,22' \
          sparse_shepards_gray.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_shepards_gray.gif"><img src="sparse_shepards_gray.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As of IM v6.6.8-5 unmodified channels is preserved, as such you can now use <a href="#sparse-color">Sparse Color</a> with the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting to add a transparent gradient to any image, quickly and easily. For example, here I add a transparent <a href="#diagonal_gradient">Diagonal Gradient</a>, that is aligned so that 50% transparency is along the diagonal of the built-in "<code>rose:</code> image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set -channel A \
          -sparse-color Barycentric \
                 '0,0 opaque   %w,-%h opaque    %w,%h transparent' \
          rose_alpha_gradient.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="rose_alpha_gradient.png"><img src="rose_alpha_gradient.png" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>The color '<code>Opaque</code>' is just another name for '<code>Black</code>'. Basically it is used when you are really only interested in specifying a fully-opaque color, but the actual color itself unimportant. Similarly with the color '<code>Transparent</code>'. I could have just as easily used '<code>White</code>' and '<code>None</code>' respectively.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Before IM v6.6.8-5 any channels not selected by the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting was reset to zero (black) values. This severely limited its effective usefulness</i></font></td>
              </tr>
            </table><a href="#sparse-color">Sparse Color</a> also accepts normalized floating point values instead of a color name. Exactly how many values need to be provided to replace the color name depends on the current "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting, and whether that channel is 'active' in the image being processed. The easiest way is to limited the processing to a single channel. Also note that when using raw numbers, rather than color names, transparency values are 'matte' values (0=opaque) and not 'alpha' values (1=opaque) (for IMv7). As such in the above I could have used numbers instead of color names...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  -channel A  -sparse-color Bilinear '0,0 1.0   -%w,%h 1.0    %w,%h 0.0'
</samp></pre>
                  </td>
                </tr>
              </table>
            </div>This may be easier to handle in programmed scripts, and in API's, which may not have access to the 'colorname' translator. <a name="sparse_fill" id="sparse_fill"></a>
            <h3>Sparse Color as a Fill Operator</h3>One of the original reasons for creating the <a href="#sparse-color">Sparse Color Operator</a>, was so that you could give an image containing just a small number of fixed points of color, and from this 'fill-in' the rest of the undefined colors. For example, here I have drawn a small number of pixels. The "<code><a href="../option_link.cgi?antialias">+antialias</a></code>" setting was specifically turned off so no semi-transparent, or mixed colors have been drawn, as such the image only contains the four exact colors specified an no others.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:none +antialias -fill none -strokewidth 0.5 \
          -stroke Gold        -draw "path 'M 20,70  A 1,1 0 0,1 80,50'" \
          -stroke DodgerBlue  -draw "line 30,10  50,80" \
          -stroke Red         -draw "circle 80,60  82,60" \
          sparse_source.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_source.gif"><img src="sparse_source.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Now we can extract the few non-transparent pixels that are present in this image, then fill in all the other colors using the multi-point sparse color method, '<code><a href="#shepards">Shepards</a></code>'.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_source.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' |\
      magick sparse_source.gif -alpha off \
              -sparse-color shepards '@-' sparse_fill.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_fill.png"><img src="sparse_fill.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The "<code>sed</code>" command in the above takes the <a href="../files/#txt">Enumerated Text File Format</a>, deletes the first header line and any line containing transparency, before re-formatting it into a list of pixel coordinates and colors. That list is then 'pipelined' into the <a href="#sparse-color">Sparse Color Operator</a> using the special "<code>@-</code>" argument. Yes the above is very tricky, but works. At least for a very small number of points. However the more points that are provided, the slower the operation becomes. This is because <a href="#sparse-color">Sparse Color</a> is 'point' orientated in its processing, rather than image or <a href="../morphology">Morphology</a> orientated. Eventually I hope to be able to provide a set of morphology orientated, 'hole-filling' methods, where you can just give the above image as-is and have it fill in the transparent areas automatically. This point-extraction technique can be combined with the <a href="../morphology/#edge-in">EdgeIn Morphology Method</a> to extract the pixels around the edges of objects or holes, so that you can then 'fill-in' the missing background or holes (as shown in <a href="../morphology/#channels">Morphology and Channels</a>). For example...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick figure.gif -channel A -morphology EdgeIn Diamond 
shape_edge_pixels.gif
  magick shape_edge_pixels.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' | \
     magick shape_edge_pixels.gif -alpha off \
             -sparse-color shepards '@-' shape_edge_in_lights.png
  magick shape_edge_in_lights.png figure.gif -composite shape_in_lights.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="figure.gif"><img src="figure.gif" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="shape_edge_pixels.gif"><img src="shape_edge_pixels.gif" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="shape_edge_in_lights.png"><img src="shape_edge_in_lights.png" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="shape_in_lights.png"><img src="shape_in_lights.png" width="100" height="125" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Note that the resulting image is exactly the same as the input, but with the transparent background replaced with a distance blurred 'edge colors'. This is why the edges of the image have become in-distinct. This image was specifically developed to try and generate better 'edge feathering' techniques. See <a href="../blur/#feathering">Blur Feathering</a> and <a href="../morphology/#distance_feather">Distance Feathering</a> for other feathering techniques. <a name="sparse_blur" id="sparse_blur"></a>
            <h3>Sparse Color Shepards, a Blur Alternative</h3>One alternative to using "<code><a href="../option_link.cgi?sparse-color">-sparse-color</a></code>" is to take the image of pixels on a transparent background, and <a href="../blur/#blur">Blur</a> it. Afterward the transparency is junked.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_source.gif   -channel RGBA -blur 0x15 \
          -alpha off  sparse_blur_simple.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="sparse_source.gif"><img src="sparse_source.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="sparse_blur_simple.png"><img src="sparse_blur_simple.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>The problem with this is that the original colors not preserved, and you also have the problem of exact what '<i>sigma</i>' value should be used. Also it does not take into account just now 'near' each color is, as such two colored pixels close together (less than the '<i>sigma</i>' value) will swamp each other, and become blurred together.<br>
            A better method is to generate multiple layers of blurred images with progressively smaller '<i>sigma</i>' values, and the original unblurred image on top.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" script="" sparse_blur_layered.png="">
  for sigma in  64 32 16 8 4 2 1 0;  do
    magick sparse_source.gif -depth 16 \
            -channel RGBA -blur 0x$sigma miff:-
  done |
    magick - -background none -flatten -alpha off sparse_blur_layered.png
</code></pre>
                  </td>
                </tr>
              </table><a href="sparse_source.gif"><img src="sparse_source.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="sparse_blur_layered.png"><img src="sparse_blur_layered.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>This layered blurring technique is equivalent to the result of a '<code><a href="#shepards">Shepards</a></code>' method on the same image, though not as exact, it is very close. However it is likely to be much faster when a lot of input pixels are involved, as it is image (morphology) oriented, rather than calculating using individual points. An other layered blur method is to use <a href="../resize/#resize">Resize</a> to generate a 'pyramid' of blurred images. This technique is detailed in <a href="../blur/#blur_resize">Large Blurs using Resize</a>.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_source.gif \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          -layers RemoveDups -filter Gaussian -resize 100x100\! -reverse \
          -background None -flatten -alpha off    sparse_blur_pyramid.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_blur_pyramid.png"><img src="sparse_blur_pyramid.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This will work very fast with very large images without needing large '<i>sigma</i>' values (and thus very slow) for each of the blurring steps. Essentially it is using a faster image resizing technique to generate the blurred layers of the previous example. It is not as exact, but will generate a good approximation of the correct result. However it works best for images which are a square, and a power of two in size, or it will be less accurate. The special operator "<code><a href="../option_link.cgi?layers">-layers</a> RemoveDups</code>" in the above will remove any extra 'single average pixel' images that was generated, by the multiple 'clone-resize' operations. The images are then resize back to the original size using a <a href="../filter/#gaussian">Gaussian Resize Filter</a> (the equivalent to a blur). The image order is then reversed so as to place the original on top, and the more blurry layers underneath, before flattening together as before. It has the advantage of only needing to read the image once, doing all the work in a single command. It also works very quickly even for large images, especially as the resize only halves the image at each step, and thus avoids the slow blurring with a very large sigma. The only disadvantage with this method is that you will need to have a rough idea of the original size of the image to restore the 'blurred' images, and to get at least a rough idea of how many resized clones to generate (Log<sub><sub>2</sub></sub> of the largest dimension, plus 1). However overdoing the resize clones is not a major performance hit as the resize simply becomes a 'no-op' when the input image has already been resized down to the minimal 1 pixel image. The extra and useless 'resized image layers' are then dealt with automatically using "<code><a href="../option_link.cgi?layers">-layers</a> RemoveDups</code>".The only real problem is the possibility of the resized images becoming 'out of sync' when handling an image that is not a power-of-two in size. How severe this problem is is not known, but shouldn't be too great, as those images are also the most blurred. Of course it still has the 'leakage' problem of the '<code><a href="#shepards">Shepards</a></code>' method, so lets look at this problem in more detail. <a name="shepards_leakage" id="shepards_leakage"></a>
            <h3>Shepards Method 'Leaks'</h3>The '<code><a href="#shepards">Shepards</a></code>' method does not have any understanding of 'boundaries', and as such colors on the far side of some 'line of color' will leak, or 'bleed thru' past that line. Eventually at a large distance you will get a pure average color of all the pixels. This is not always a desirable outcome (though is desirable in some cases). In this example, the closer the '<code>Red</code>' curve approaches the '<code>White</code>' line, the more the color will 'leak' though the two lines to the far side producing a pink color.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:none +antialias -fill none -strokewidth 0.5 \
          -stroke Red    -draw "path 'M 26,0  A 55,61 0 0,1 26,100'" \
          -stroke White  -draw "line 50,0  50,100" \
          sparse_lines_near_source.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_lines_near_source.gif"><img src="sparse_lines_near_source.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick sparse_lines_near_source.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' |\
      magick -size 100x100 xc: -sparse-color shepards '@-' \
              sparse_lines_near.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="sparse_lines_near.png"><img src="sparse_lines_near.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This leakage of colors is the main problem with using <a href="#shepards">Shepards Method</a> for 'hole filling' especially when multiple holes are involved, as the colors involved with one hole, can and will leak into and effect the colors in a completely different hole. And visa-versa. It is an understanding of boundaries that forms the difference between <a href="#shepards">Shepards Method</a>, and another form of color 'hole-filling' known as '<i>Color Diffusion</i>'. Basically with '<i>Color Diffusion</i>', colors can not pass though a line of some other defined color. It is achieved by limiting the effect to only colors in 'line of sight', or to those that leak, around the outside of an edge. This requires using distance to the nearest colors to limit what colors influence a pixel. One major use of '<i>Color Diffusion</i>' is presented on the <a href="http://artis.imag.fr/Publications/2008/OBWBTS08/">Diffusion Curves</a> web site. This not only makes heavy use of color diffusion, but also includes information on techniques for generating diffusions very quickly. I hope to implement this into ImageMagick at some point in the future.
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="plasma" id="plasma"></a>
            <h2>Plasma Images</h2><a name="plasma_gradients" id="plasma_gradients"></a>
            <h3>Plasma Gradients</h3>While gradients provide a smooth range of colors, another image creation operator "<code>plasma:</code>" provides a different sort of gradient. One that is ideally suited to generating a random backdrop of color for your images. First of all I should point out that "<code>plasma:</code>" is a randomized image. As such it can and will produce a different image every time it is run. For example, here we generate three separate 'standard' plasma images, and each image is different from each other, even though the same command was used to generate them.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100  plasma:  plasma1.jpg
  magick -size 100x100  plasma:  plasma2.jpg
  magick -size 100x100  plasma:  plasma3.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma1.jpg"><img src="plasma1.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma2.jpg"><img src="plasma2.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma3.jpg"><img src="plasma3.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>You can also see that plasma images are also a type of randomized gradient of colors, and like "<code>gradient:</code>" started with white at the top and black at the bottom. What isn't well document is that you can specify color for the plasma gradient in the exact same way as you can for linear gradients above.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100  plasma:blue              plasma_range1.jpg
  magick -size 100x100  plasma:yellow            plasma_range2.jpg
  magick -size 100x100  plasma:green-yellow      plasma_range3.jpg
  magick -size 100x100  plasma:red-blue          plasma_range4.jpg
  magick -size 100x100  plasma:tomato-steelblue  plasma_range5.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_range1.jpg"><img src="plasma_range1.jpg" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="plasma_range2.jpg"><img src="plasma_range2.jpg" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="plasma_range3.jpg"><img src="plasma_range3.jpg" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="plasma_range4.jpg"><img src="plasma_range4.jpg" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="plasma_range5.jpg"><img src="plasma_range5.jpg" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>You can also see that mid-tone colors like '<code>tomato</code>' and '<code>steelblue</code>' tend to work better than pure colors like '<code>red</code>' and '<code>blue</code>'. By using the same color twice with plasma you can produce a background that is predominantly that color, but with random splotches of colors close to those of the original colors.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100  plasma:black-black          plasma_black.jpg
  magick -size 100x100  plasma:grey-grey            plasma_grey.jpg
  magick -size 100x100  plasma:white-white          plasma_white.jpg
  magick -size 100x100  plasma:yellow-yellow        plasma_yellow.jpg
  magick -size 100x100  plasma:tomato-tomato        plasma_tomato.jpg
  magick -size 100x100  plasma:steelblue-steelblue  plasma_steelblue.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_black.jpg"><img src="plasma_black.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_grey.jpg"><img src="plasma_grey.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_white.jpg"><img src="plasma_white.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_yellow.jpg"><img src="plasma_yellow.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_tomato.jpg"><img src="plasma_tomato.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_steelblue.jpg"><img src="plasma_steelblue.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>Again as you can see, mid-tone colors will generate more varieties of color in the resulting image, than an extreme color, like black, white, or yellow. The '<code>grey</code>' plasma in the above is particularly nice giving a iridescent 'mother-of-pearl' like effect, basically as grey has total freedom in the colors that the "<code>plasma:</code>" will generate.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Normalizing a prefect 50% grey plasma will produce a particularly uniform multi-color plasma image, over the full range of colors, including white and black.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100  plasma:grey50-grey50 -auto-level plasma_grey_norm.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_grey_norm.jpg"><img src="plasma_grey_norm.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Alternatively you can just spread the contrast of the colors to just make them bolder, but without going to extremes.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100  plasma:grey50-grey50 \
                       -sigmoidal-contrast 8x50%   plasma_grey_contrast.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_grey_contrast.jpg"><img src="plasma_grey_contrast.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Compare this image with the 'fractal plasma' images below. <a name="plasma_fractal" id="plasma_fractal"></a>
            <h3>Fractal Plasma</h3>The plasma generator also has a special fractal mode, which produces highly colorful effects. The colors generated are enhanced to produce more exaggerated color changes.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100  plasma:fractal  plasma_fractal1.jpg
  magick -size 100x100  plasma:fractal  plasma_fractal2.jpg
  magick -size 100x100  plasma:fractal  plasma_fractal3.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_fractal1.jpg"><img src="plasma_fractal1.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_fractal2.jpg"><img src="plasma_fractal2.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_fractal3.jpg"><img src="plasma_fractal3.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>In fact this is very similar to the constant color plasma images we have already seen, and in fact these are generated in the same way but with more pronounced color changes.<br>
            I often find that plasma images are a little 'noisy'. As such they usually will benefit from a little smoothing using "<code><a href="../option_link.cgi?blur">-blur</a></code>".
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  Here I have have smoothed out the noise from the middle plasma image above.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick plasma_fractal2.jpg  -blur 0x2  plasma_smooth.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_smooth.jpg"><img src="plasma_smooth.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  You can use "<code><a href="../option_link.cgi?paint">-paint</a></code>" to create random blotches of color.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick plasma_fractal2.jpg  -blur 0x1 -paint 8  plasma_paint.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_paint.jpg"><img src="plasma_paint.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  Or make the colors more pronounced and circular using the "<code><a href="../option_link.cgi?emboss">-emboss</a></code>" image operator, after using "<code><a href="../option_link.cgi?blur">-blur</a></code>" to remove the low level noise.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick plasma_fractal2.jpg  -blur 0x5 -emboss 2 plasma_emboss.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_emboss.jpg"><img src="plasma_emboss.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  By using a "<code><a href="../option_link.cgi?blur">-blur</a></code>" followed by a "<code><a href="../option_link.cgi?sharpen">-sharpen</a></code>" you can produce a more pastel color pattern than we produced with "<code><a href="../option_link.cgi?emboss">-emboss</a></code>".
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick plasma_fractal2.jpg  -blur 0x5 -sharpen 0x15 plasma_sharp.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_sharp.jpg"><img src="plasma_sharp.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  I actually find generating a swirled plasma gradient to be particularly nice, as a background pattern.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 160x140  plasma:fractal \
          -blur 0x2  -swirl 180  -shave 20x20  plasma_swirl.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_swirl.jpg"><img src="plasma_swirl.jpg" width="120" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="plasma_greyscale" id="plasma_greyscale"></a>
            <h3>Greyscale Plasma</h3>Now the plasma generator will always generate color, even on a pure black solid color. However it is often useful to generate a pure grey-scale plasma. Well there are two simple ways of doing this.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  The simplest way is to take the plasma image and converted it to grey scale.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 plasma:fractal -blur 0x2 \
          -colorspace Gray   plasma_greyscale.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_greyscale.jpg"><img src="plasma_greyscale.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr valign="top">
                <td width="100%" align="justify">
                  Another way is to copy one of the color channel over the other two, for a stronger, single layer, effect.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 plasma:fractal -blur 0x2 \
          -channel G -separate   plasma_grey_copy.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_grey_copy.jpg"><img src="plasma_grey_copy.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
              <tr valign="top">
                <td width="100%" align="justify">
                  A final technique is to use "<code><a href="../option_link.cgi?shade">-shade</a></code>" on the plasma.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 plasma:fractal -blur 0x5 \
          -shade 120x45  -auto-level  plasma_grey_shade.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_grey_shade.jpg"><img src="plasma_grey_shade.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>You'd probably think you would get a lot of light and shadow effects, but the raw plasma is so random, that "<code><a href="../option_link.cgi?shade">-shade</a></code>" only seems to produce a more 'mottled plasma' effect. Instead of using a fractal plasma, with its highly exaggerated color changes, you can create a grey-scale plasma using the constant color plasma method. As a side effect, this method also allows you to control the overall brightness of the grey-scale plasma image generated.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100 plasma:black-black \
           -blur 0x2 -colorspace Gray plasma_grey0.jpg
  magick -size 100x100 plasma:grey25-grey25 \
           -blur 0x2 -colorspace Gray plasma_grey1.jpg
  magick -size 100x100 plasma:grey50-grey50 \
           -blur 0x2 -colorspace Gray plasma_grey2.jpg
  magick -size 100x100 plasma:grey75-grey75 \
           -blur 0x2 -colorspace Gray plasma_grey3.jpg
  magick -size 100x100 plasma:white-white   \
           -blur 0x2 -colorspace Gray plasma_grey4.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_grey0.jpg"><img src="plasma_grey0.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey1.jpg"><img src="plasma_grey1.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey2.jpg"><img src="plasma_grey2.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey3.jpg"><img src="plasma_grey3.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey4.jpg"><img src="plasma_grey4.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>If this is not quite bold enough, use the channel copy method of grey-scaling the plasma image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 100x100 plasma:black-black   \
          -blur 0x2  -channel G  -separate   plasma_grey5.jpg
  magick -size 100x100 plasma:grey25-grey25 \
          -blur 0x2  -channel G  -separate   plasma_grey6.jpg
  magick -size 100x100 plasma:grey50-grey50 \
          -blur 0x2  -channel G  -separate   plasma_grey7.jpg
  magick -size 100x100 plasma:grey75-grey75 \
          -blur 0x2  -channel G  -separate   plasma_grey8.jpg
  magick -size 100x100 plasma:white-white   \
          -blur 0x2  -channel G  -separate   plasma_grey9.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_grey5.jpg"><img src="plasma_grey5.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey6.jpg"><img src="plasma_grey6.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey7.jpg"><img src="plasma_grey7.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey8.jpg"><img src="plasma_grey8.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="plasma_grey9.jpg"><img src="plasma_grey9.jpg" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>These grey-scale plasma images are very useful for further processing, allowing you to generate other image effects. For example, look at the page on <a href="../backgrounds/">Background Images</a> for a huge number of examples where the plasma fractal was used to produce lots of interesting effects. <a name="plasma_seeded" id="plasma_seeded"></a>
            <h3>Seeding or Repeating a Plasma Image</h3>Remember "<code>plasma:</code>" can produce areas of near pure black or pure white, or any other color (though it isn't likely to be pure). And while it is unlikely you will get an image that is all in one color, it is also a possible outcome. So when you get a good result you may like to save it, for later re-use. Because of this, scripts using plasma images, may like to include options to generate and re-use such randomized images. That is, you may like to separate the plasma image generation from other parts that use that image, to allow re-use.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  A simpler technique however is to 'seed' or initialize the IM random number generator so that '<code>plasma:</code>' will generate the same 'randomized' image. That way you can tune a script or program to produce a good or interesting coloration or effect, over and over.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 -seed 4321  plasma:    plasma_seeded.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="plasma_seeded.jpg"><img src="plasma_seeded.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE plasma_seeded.jpg \
                ../images/plasma_seeded.jpg null: 2>&1 |\
         sed 's/ .*//'`" != '0' ] &&  echo >&2 \
    "ASSERTION FAILURE: Seeded Plasma Image Changed\!"
  [ "`magick -size 100x100 -seed 1 plasma: -seed 1 plasma: miff:- | \
      magick compare -metric PAE - null: 2>&1 | sed 's/ .*//'`" != '0' ] && echo >&2 
\
    "ASSERTION FAILURE: Repeated Seeded Plasmas do not match\!"
</CODE> -->
            The above image will never change, so unless I change the "<code><a href="../option_link.cgi?seed">-seed</a></code>" number I will always have a 'red' area in the bottom-right corner. Interestingly using the same seed with different initializing color gradients can produce a set of images, which while random, are similar in their internal pattern.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 -seed 4321 plasma:grey-grey         plasma_rnd1.jpg
  magick -size 100x100 -seed 4321 plasma:white-blue        plasma_rnd2.jpg
  magick -size 100x100 -seed 4321 plasma:green-yellow      plasma_rnd3.jpg
  magick -size 100x100 -seed 4321 plasma:red-blue          plasma_rnd4.jpg
  magick -size 100x100 -seed 4321 plasma:tomato-steelblue  plasma_rnd5.jpg
</samp></pre>
                  </td>
                </tr>
              </table><a href="plasma_rnd1.jpg"><img src="plasma_rnd1.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_rnd2.jpg"><img src="plasma_rnd2.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_rnd3.jpg"><img src="plasma_rnd3.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_rnd4.jpg"><img src="plasma_rnd4.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="plasma_rnd5.jpg"><img src="plasma_rnd5.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>As you can see the same pattern of colors is present in all the above images, though the underlying color base can highlight or obscure parts of the shared pattern. Just one final word of warning. Other IM operators can also use the random number generator, such as the "<code><a href="../option_link.cgi?fx">-fx</a></code>" '<code>rand()</code>' function, the "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" '<code>random</code>' setting the "<code><a href="../option_link.cgi?random-threshold">-random-threshold</a></code>" dither operator, and the "<code><a href="../option_link.cgi?noise">-noise</a></code>" operator. As such is a good idea to seed the generator immediately before your specific use of the random number generator. As of IM v6.3.4-3, you can also re-randomize the generator using "<code><a href="../option_link.cgi?seed">+seed</a></code>". So placing this setting after your 'seeded plasma' will ensure that any later operators correctly generate a randomized result if desired. By default the seed is randomized when IM starts, so you normally do not need to randomize it yourself using "<code><a href="../option_link.cgi?seed">+seed</a></code>" to get a random result. <a name="plasma_problems" id="plasma_problems"></a>
            <h3>Problems using Plasma</h3>One problem that you should avoid with "<code>plasma:</code>" images is generating them with a high aspect ratio. It tends to distort the normal plasma color effects, pulling the colors out into needle-like streaks.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 200x50 plasma:  plasma_high_aspect.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_high_aspect.jpg"><img src="plasma_high_aspect.jpg" width="200" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>There is no simple solution to this, so unless this is what you are wanting, caution is advised. There is also a definite top-left to bottom-right diagonal warp in the plasma image that should not exist. That is, there is some sort of 'spatial bias' flaw in the algorithm. For example as Thomas Maus &lt;thomas.maus_AT_alumni.uni-karlsruhe.de&gt; pointed out if you mirror and append the same plasma image, you will always see a distinct 'V' in the resulting image...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" random="">
  magick -size 60x60 plasma: \( +clone -flop \) +append plasma_flaw.jpg
</code></pre>
                  </td>
                </tr>
              </table><a href="plasma_flaw.jpg"><img src="plasma_flaw.jpg" width="120" height="60" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
            </div>This should not happen. But the problem seems to be too deep to be able to fix without basically completely re-writing the whole plasma generator function.
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="random" id="random"></a>
            <h2>Random Images</h2><a name="random_noise" id="random_noise"></a>
            <h3>Raw Random Noise</h3>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  As of IM v6.3.5 you can generate a purely random image from an existing image using Noise Generator, "<code><a href="../option_link.cgi?noise">+noise</a></code>" method '<code>Random</code>'.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 xc:   +noise Random   random.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random.png"><img src="random.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  If your IM is older than this you can still generate a pure random noise image using the slower <a href="../transform/#fx">DIY FX Operator</a>, "<code><a href="../option_link.cgi?fx">-fx</a></code>".
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 xc: -fx 'rand()'   random_fx.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_fx.png"><img src="random_fx.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Or for speed you can use the "<code><a href="../option_link.cgi?spread">-spread</a></code>" operator to randomize a gradient (separatally for the three color channels) or by using some other image.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 gradient: -separate \
          -virtual-pixel tile   -spread 200   -combine  random_spread.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_spread.png"><img src="random_spread.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The result may seem very random, but it will produce a more controlled range of colors, (or just color values). <a name="random_specks" id="random_specks"></a>
            <h3>Random Specks (pixel dust)</h3>Generating images of scattered random pixels can also be very useful. . just remember that each of the three <a href="../color_basics/#channels">Color Channels</a> of a random image can be thought of as separate random gray-scale image and these channels can be merged together in various ways.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  For example you generate a mask of random dots by first <a href="../quantize/#threshold">Thresholding</a> a color channel ('<code>G</code>' or the green channel), and separating it out as a gray-scale image.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick random.png  -channel G -threshold 5% -separate \
          +channel -negate    random_mask.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_mask.png"><img src="random_mask.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As each color is a linearly random value, the threshold percentage used in the above directly defines the density of pixels selected. You can go further and use one color color channel ('<code>G</code>' or green channel) to select random values from another color channel channel ('<code>R</code>' or red channel), by using various <a href="../compose/#compose">Image Composition</a> methods.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random.png   -channel G -threshold 5% -negate \
          -channel RG -separate +channel \
          -compose Multiply    -composite   random_black.png
  magick random.png   -channel G -threshold 5% \
          -channel RG -separate +channel \
          -compose Screen      -composite   random_white.png
  magick random.png   -channel G -threshold 5% -negate \
          -channel RG -separate +channel \
          -compose CopyOpacity -composite   random_trans.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random.png"><img src="random.png" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="random_black.png"><img src="random_black.png" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="random_white.png"><img src="random_white.png" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <a href="random_trans.png"><img src="random_trans.png" width="100" height="100" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            </div>These types of images are directly usable to generate <a href="../anim_mods/#glitter">Glitter Animations</a>. But further processing, particularly on the black background version, will let you enlarge the dots based on their gray-scale intensity or generate streaks and or star flares from those dots. For examples see <a href="../advanced/#stars">Star Generators</a>. <!-- <CODE EXECUTE ASSERT>
  [ "`magick -size 100x100 xc: -seed 11 +noise Random \
                      \( +clone -seed 11 +noise Random \) miff:- | \
      magick compare -metric PAE - null: 2>&1 | sed 's/ .*//'`" != '0' ] && echo >&2 
\
    "ASSERTION FAILURE: Seeded Random Images do not match"
</CODE> -->
            Like <a href="#plasma_seeded">Seeded Plasma Images</a> you can also use the "<code><a href="../option_link.cgi?seed">-seed</a></code>" setting to pre-initialise the random number generator. This allows you to generate the same random image(s) repeatably for a particular machine, just as you can for plasma images. <a name="random_blur" id="random_blur"></a>
            <h3>Blurred Random Images (random blobs)</h3>Now while you can make direct use of random images to create speckled effects, purely random images are generally not very useful. But by <a href="../blur/#blur">Blurring</a> a purely random image you will introduce some 'neighbourhood' order, such that nearby pixels become related. For example, here I blur just one random image, causing the random values to produce larger 'blobs' or mottled colors.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random.png -virtual-pixel tile  -blur 0x1  -auto-level  random_1.png
  magick random.png -virtual-pixel tile  -blur 0x3  -auto-level  random_3.png
  magick random.png -virtual-pixel tile  -blur 0x5  -auto-level  random_5.png
  magick random.png -virtual-pixel tile  -blur 0x10 -auto-level  
random_10.png
  magick random.png -virtual-pixel tile  -blur 0x20 -auto-level  
random_20.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random.png"><img src="random.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="random_1.png"><img src="random_1.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_3.png"><img src="random_3.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_5.png"><img src="random_5.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_10.png"><img src="random_10.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_20.png"><img src="random_20.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>Note however without the <a href="../misc/#virtual-pixel">Virtual Pixel Setting</a> the "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator will have strong edge effects, which are best avoided. As a bonus by changing the "<code><a href="../option_link.cgi?virtual-pixel">-virtual-pixel</a></code>" setting to '<code>tile</code>', the randomised image remains tilable, with the colors wrapping across the image boundaries. This tiling ability is something that currently not possible with a random <a href="#plasma">Plasma Images</a> and is an inherent result of pure random images being so random to start with. <a name="random_hue" id="random_hue"></a> <b>Blurred Random Hues</b>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  One particular conversion of a blurred random noise image that I found particularly pleasing is to map the values into HSB color hues.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick random_10.png -set colorspace HSB \
          -channel GB -evaluate set 100% +channel \
          -colorspace RGB random_hues_cyan.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_hues_cyan.png"><img src="random_hues_cyan.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The problem with the above is that the blur will tend to create spots of red-yellow (low values) and red-magenta (high values), with bands of green, cyan and blues, in between them. This is simply a consequence of the way the hue values were blurred and leveled. The ideal solution to this would be a type of modulus-blur, that would take into account the cyclic nature of the Hue values. However such an operator is not currently available, and perhaps never will.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  The best solution I know of is to simply add all three random channels in the image (using <a href="../compose/#modulusadd">Modulus-Add Composition</a>) so as to extend the range of values. This also have a side effect of making the blurred spots smaller, but at least you now get a more dynamic range rainbow colors. <i>Anyone got a better idea?</i>
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick random_10.png -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB random_hues.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_hues.png"><img src="random_hues.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>For more methods of processing a random images, see <a href="#plasma">Plasma Images</a> above, as well as <a href="../backgrounds/">Generating Backgrounds</a>. <a name="random_grayscale" id="random_grayscale"></a> <b>Blurred Random Grays</b>As you can see from the above you get an image with various blobs of primary colors. That is, because each channel is being processed completely separately to each other as gray-scale images. Lets extract one of the channels of each of the above image so you can see the structure of the blurred image...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random.png     -channel G  -separate   random_0_gray.png
  magick random_1.png   -channel G  -separate   random_1_gray.png
  magick random_3.png   -channel G  -separate   random_3_gray.png
  magick random_5.png   -channel G  -separate   random_5_gray.png
  magick random_10.png  -channel G  -separate   random_10_gray.png
  magick random_20.png  -channel G  -separate   random_20_gray.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random_0_gray.png"><img src="random_0_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_1_gray.png"><img src="random_1_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_3_gray.png"><img src="random_3_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_5_gray.png"><img src="random_5_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_10_gray.png"><img src="random_10_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_20_gray.png"><img src="random_20_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>The first thing that you should notice is that the image will generally (but not always) contain roughly equal amounts of both black and white areas. You can see this if we <a href="../quantize/#threshold">Threshold</a> the random images at 50%
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random_0_gray.png   -threshold 50%   random_0_thres.png
  magick random_1_gray.png   -threshold 50%   random_1_thres.png
  magick random_3_gray.png   -threshold 50%   random_3_thres.png
  magick random_5_gray.png   -threshold 50%   random_5_thres.png
  magick random_10_gray.png  -threshold 50%   random_10_thres.png
  magick random_20_gray.png  -threshold 50%   random_20_thres.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random_0_thres.png"><img src="random_0_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_1_thres.png"><img src="random_1_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_3_thres.png"><img src="random_3_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_5_thres.png"><img src="random_5_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_10_thres.png"><img src="random_10_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="random_20_thres.png"><img src="random_20_thres.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>As you can see you get approximately 50% white and 50% black areas, separated by a curvy line. Also the curve of this line varies according to the '<i>sigma</i>' value used for the blurring of the purely random image. From individual pixels generating a black and white 'snow' until you get a very uniform (though still random) separation of the image into two black and white areas. For more examples of using random images, see <a href="../backgrounds/">Background Images</a> or to have a look at generating randomised canvases, see <a href="../misc/#spots">Random Spots of Solid Color</a>. <a name="granularity" id="granularity"></a>
            <h3>Random Granularity (order in the chaos)</h3>Now remember all the blurred random images were generated from the same initial random image, thus they are all related. But every new random image generated will have a completely different pattern, though the patterns will more or less look similar in structure.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  But first lets give a full example of generating a 'blured random image' from scratch...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code already_executed="">
  magick -size 100x100 xc:  -channel G +noise Random \
         -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate +channel   random_5_gray.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_5_gray.png"><img src="random_5_gray.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The heavy use of the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting to limit operations to the 'Green' channel of the image is important as it speeds up the overall generation of the image by a factor of 3. The <a href="../channel/#separate">Channel separate</a> will then ensure we get a pure grayscale result. If you want you could leave out both "<code><a href="../option_link.cgi?channel">-channel</a></code>" settings, which will result in the generation of 3 completely separate and different 'Blurred Random Images'. The image has some important characteristics, which we can see more clearly if we divide the image up into three equal sets of colors (using a technique called <a href="../quantize/#posterize">Posterization</a>), you can see that inside each of the black and white zones you get more circle blobs or 'granules'.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  For example...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick random_5_gray.png  -ordered-dither threshold,3  random_5_blobs.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_5_blobs.png"><img src="random_5_blobs.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>First I would like to point out how we get roughly equal amounts of light and dark areas within the image, but that those areas are interconnected by the grey 'middle' colors of the gradient that forms between the light and dark areas. Now the individual blobs or 'granules' varies from area to area across the image, but they all roughy average at about a diameter of about <i>three to four times</i> the value used to blur the initial random image. This blur value is known as the '<i>granularity</i>' of the image is a very important value, as it basically represents the average size of the circular structures the random image produces. Some times it is called the 'curviness' of the image. The larger the value the larger and slower these curves are within the image. This is the most important factor describing a Blurred Random image, so lets make it very clear...
            <div align="center">
              <b>The '<i>Granularity</i>' of a random image (or blur factor)<br>
              determines the size of the circular structures within</b>
            </div>Of course the smaller the 'blur factor' or '<i>Granularity</i>', the smaller or tighter the curves become, until you reach a value of '<code>0</code>', at which point, all the clumping or 'blobs' within the image vanishes, and you are least with a purely random 'noise', 'snow', or 'pixel dust' type of effect.<br>
            ASIDE: Actually the size of the actual 'granules' themselves can vary depending on the threshold factor used to generate them. What the factor really describes is the average distance between centers of the white and black areas. The larger the value the larger the distance, and the larger and more spread out the spots have to be to accomidate that increased distance. This becomes more obvious when we start looking at <a href="#random_ripples">Random Ripples</a> below.<br>
            You may also like to try using a 50% <a href="../color_mods/#solarize">Solarize</a> operation with some extra <a href="../color_mods/#levels">Level Adjustments</a> to extract both the well separated black and white granules from the image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  For example, here is a full example with a granularity of '<code>8</code>' and a blob threshold of '<code>25%</code>' generating white spots from both black and white parts of the image.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 100x100 xc: -channel G +noise random \
          -virtual-pixel tile -blur 0x8 -auto-level  \
          -solarize 50% -separate +channel \
          -threshold 25% -negate   random_granules.png
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="random_granules.png"><img src="random_granules.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Be warned that as the value gets larger, the time to generate the blurred random image also gets much much longer. Also when the value reaches about half that of the size of the smallest image dimension, the effect stops growing as the random image settles into a single white and black spot. Large values are not recommended. <a href="animated_granularity.gif"><img src="animated_granularity.gif" width="150" height="150" align="left" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> To finish with, to the left is shown a <a href="../anim_mods/#patrol">Patrol Cycle Animation</a> resulting from varying the 'granularity' (random blurring) of a single random image. The animation was generated using the shell script "<code><a href="animate_granularity">animate_granularity</a></code>", which you can download, study and play with. Note that as the same random image is used as a source the 'granules' or spots do not really move, but just sort of grow together, or fade away, so as to produce larger 'granules' with increasing granularity. Also remember that while I have reduced the number of colors in the animation, the structure of the full random image is actually smooth gradient between two sets of white and black granules. This gradient is what makes the image useful in other techniques. <a name="random_flux" id="random_flux"></a>
            <h3>Random Flux (animation cycles)</h3>Now as you saw above the granules or spots do not actually move all that much. But for animation effects you want a pattern that moves smoothly in time. Also you don't want that pattern to just simply move back and forth. And finally, you do not want that pattern of movements to suddenly jump or jerk as the animation loops. So what we need is some way to generate a smoothly repeating random pattern. A tall order. Also as you need it to be smooth, you will need to generate all the patterns from the same single random image. Here is an idea that allows you to generate such a random pattern. Rather than think of each random pixel value as being a random intensity, we instead think of that value being a 'time' value defining when that pixel is at its maximum or minimum intensity. That is, we magick that value into a position on a 'wave'. Thus each pixel represents some 'phase' of a sine curve. This sounds complicated, but in reality it isn't. We just use the <a href="#random">Random Image</a> as a source image for a <a href="../transform/#function_sinusoid">Sinusoid Function</a>. Now for each image in the time sequence we set the time '<i>phase</i>' for that particular point in the time cycle.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random.png   -function Sinusoid 1,<i>{time}</i> \
          ... do granular blurring,  and other processing ...
</samp></pre>
                  </td>
                </tr>
              </table>
            </div>Where '<code><i>{time}</i></code>' goes from '<code>0</code>' to '<code>360</code>' over the complete animation cycle. The result is that instead of each pixel having a 'static' random value, we now have one that cycles in a loop between black and white over a period of time. Each pixel will follow this same cycle, but as each pixel has a completely different 'phase', and will cycle independently of all the other pixels. That is, the image is still random, but smoothly changing with the provided 'time' value. For the scientifically minded this is a bit like looking at the 'quantum flux' that exists at sub-atomic level, where space is far from the 'static' state we see at normal scales. Hence the name '<b>Random Flux</b>'. For example lets generate a time sequence of 12 images...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre><code execute="" script="">
  for i in `seq 0 30 359`; do
    magick random.png  -channel G  -function Sinusoid 1,${i} \
            -virtual-pixel tile -blur 0x8 -auto-level \
            -separate flux_${i}.png
  done
</code></pre>
                  </td>
                </tr>
              </table>
              <table cellspacing="0" cellpadding="0">
                <tr valign="middle">
                  <td>
                    <a href="flux_0.png"><img src="flux_0.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                  <td>
                    <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="flux_30.png"><img src="flux_30.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_60.png"><img src="flux_60.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_90.png"><img src="flux_90.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_120.png"><img src="flux_120.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                  <td>
                    <a href="flux_150.png"><img src="flux_150.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                </tr>
                <tr>
                  <td align="center"><img src="../img_www/up.gif" align="middle" width="20" height="20" alt="=&gt;"></td>
                  <td></td>
                  <td align="center"><img src="../img_www/down.gif" align="middle" width="20" height="20" alt="=&gt;"></td>
                </tr>
                <tr valign="middle">
                  <td>
                    <a href="flux_330.png"><img src="flux_330.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                  <td>
                    <a href="flux_300.png"><img src="flux_300.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_270.png"><img src="flux_270.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_240.png"><img src="flux_240.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="flux_210.png"><img src="flux_210.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/left.gif" align="middle" width="20" height="20" alt="=&gt;">
                  </td>
                  <td>
                    <a href="flux_180.png"><img src="flux_180.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                </tr>
              </table>
            </div>And your one random image can now generates a whole sequence images forming a cycle. Note that the 'time' extraction has to happen before any other processing such as blurring, which is probably the slowest part of the whole generation process. The other thing to notice is that at phase '<code>180</code>' (bottom right), you actually get the exact negative of the first image (top-left). That is 'white' granules has become 'black' granules, and visa-versa. In fact the whole second half of the animation is actually the negative of the first half. This can be used to cut down the generation time of a simple 'Random Flux' animation. Because the image is a negative at a 180 degree phase, you will find that each 'white' granule slowly moves so as to swap places with a neighbouring 'black' granule. But as the whole second half is a negative of the first the it can't just simply shuffle back-and-forth, but must continue move forward to return to the original image, or circle around in a loop, or simply fade and appear appropriatally. In other words the white and black granules move in far more complex cycle. <!-- <CODE EXECUTE>
  magick flux_{?,??,???}.png -set delay 20 -loop 0 flux_anim.gif
</CODE> -->
            <a href="flux_anim.gif"><img src="flux_anim.gif" width="100" height="100" align="right" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> To the right is an animation of the above frames... The fluctuating pattern is completely random, but smoothly changing from frame to frame, and when the animation loops. You can see no beginning or end to the result. Sometimes you will get a swirling of movement, other times it looks like all the 'gas' like blobs are being sucked into a dark zone, or just appearing and fading away again. You also get periods of very fast movements, as well as very slow movements. It is totally random. <b>In summary</b>: The same properties present in <a href="#random">Blurred Random Images</a> are also present in this animation. The image remains a roughly equal division between white and black segments, and it forms blobs of about <i>three times</i> the size of the blur or <a href="#granularity">Granularity</a> of the image. But on top of this you are guarantied that all parts of the image will form some cycle between both lighter and darker colors, as half the cycle is the negative of the other half. One thing you may not have noticed is that due to the conversion of a random linear value into a sinusoid waveform, you will get a sharper white and black separation of colors (contrast). As such you may like to use the de-contrasting aspect of <a href="../color_mods/#sigmoidal">Sigmoidal Contrast</a> operator to make the resulting image less 'blob' like, and enhance the gradient between the granules, rather than the granules themselves. Now this is only a starting point for what you can do with a cyclic random animation. Everything that you can do with a <a href="#random">Random Image</a>, such as described in <a href="../backgrounds/">Generating Backgrounds</a>, can also be applied to '<i>Random Flux Animation</i>'
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  For example, lets just show the movement of just the 'white' granules... <!-- <CODE EXECUTE>
  magick flux_{?,??,???}.png -threshold 70% \
          -set delay 20 -loop 0 flux_thres_anim.gif
</CODE> -->
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code executed_above="">
  magick flux_anim.gif -threshold 70% flux_thres_anim.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flux_thres_anim.gif"><img src="flux_thres_anim.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Or generate changing electrical filaments that slowly flow over the image. <!-- <CODE EXECUTE>
  magick flux_{?,??,???}.png \
          -sigmoidal-contrast 30x50% -solarize 50% -auto-level \
          -set delay 20 -loop 0 filaments_anim.gif
</CODE> -->
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code executed_above="">
  magick flux_anim.gif  \
          -sigmoidal-contrast 30x50% -solarize 50% -auto-level \
          -set delay 20 filaments_anim.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="filaments_anim.gif"><img src="filaments_anim.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that due to fact that half the cycle is a negation of the first half and we use a <a href="../color_mods/#solarize">Solarize</a> to fold the white and black colors in half, the cycle is actually repeating twice over one animation cycle. It really needs a lot more frames to remove some of very fast changes that is taking place.<br>
            To make the motion less predictable for a longer cyclic sequence, you can also use some <a href="../transform/#gradient_math">Gradient Math</a> to combine multiple Sinusoidal Cycles, from multiple random images, or even just using the other color channels of the same random image.
            <pre>FUTURE: Create even less predictable, long time 'harmonic' cycles. </pre><a name="random_ripples" id="random_ripples"></a> <a name="frequency" id="frequency"></a>
            <h3>Random Ripples</h3>By adding another variation to a <a href="#random_blur">Blurred Random Image</a> we can add another level of complexity that makes these images far more useful, and gives use another control variable beyond its <a href="#granularity">Granularity</a>. But first you need to remember that the random image does not consist of just bright and dark areas, but also contains a slope between those areas. Using that slope as into to the <a href="../transform/#function_sinusoid">Sinusoid Function</a>, you can generate ripples between the spots in the image. Note that key difference to this use of the <a href="../transform/#function_sinusoid">Sinusoid Function</a> to the previous <a href="#random_flux">Random Flux</a> examples was that this time the function is being applied to the image AFTER it was smoothed using blur, instead of before. Also in this case it is the '<i>Frequency</i>' value, and not the second '<i>Phase</i>' value that is more important. For example...
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random_10_gray.png  -function Sinusoid 1,90   ripples_1.png
  magick random_10_gray.png  -function Sinusoid 2,90   ripples_2.png
  magick random_10_gray.png  -function Sinusoid 3,90   ripples_3.png
  magick random_10_gray.png  -function Sinusoid 4,90   ripples_4.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random_10_gray.png"><img src="random_10_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="ripples_1.png"><img src="ripples_1.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_2.png"><img src="ripples_2.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_3.png"><img src="ripples_3.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_4.png"><img src="ripples_4.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>As you can see the larger the '<i>Frequency</i>' of the <a href="../transform/#function_sinusoid">Sinusoid Function</a>, the more ripples are being added into the gradient between the 'granules'. A '<i>Frequency</i>' of '<code>1</code>' will basically magick both the Light and Dark 'blobs' in the source image to white, and leave a dark gap between them. A '<i>Frequency</i>' of '<code>2</code>' squeezes an extra 'ridge' or 'ripple' in that dark gap. As the frequency increases you get more and more 'ripples' between the lightest and darkest areas of the original image, making it more an more complex. As the number of ridges increases, you can lose sight of the original 'blobs' or 'granules' in the image. You can fix this by modifying the gradient before adding the ripples, either by 'clipping' the gradient using a <a href="../color_mods/#level">Level Adjustment</a>, or compress the midtones using <a href="../color_mods/#sigmoidal-contrast">Sigmoidal Contrast</a>. This will give the 'granules' some mass or area, providing areas of 'calm' between the ripples.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random_10_gray.png        -level 25%            random_enhanced.png
  magick random_enhanced.png  -function Sinusoid 4,90    ripples_4e.png
  magick random_10_gray.png   -sigmoidal-contrast 10,50% random_sigmoidal.png
  magick random_sigmoidal.png -function Sinusoid 4,90    ripples_4s.png
</samp></pre>
                  </td>
                </tr>
              </table>
              <table cellspacing="0" cellpadding="0">
                <tr>
                  <td rowspan="2">
                    <a href="random_10_gray.png"><img src="random_10_gray.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;">
                  </td>
                  <td>
                    <a href="random_enhanced.png"><img src="random_enhanced.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="ripples_4e.png"><img src="ripples_4e.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                </tr>
                <tr>
                  <td>
                    <a href="random_sigmoidal.png"><img src="random_sigmoidal.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="ripples_4s.png"><img src="ripples_4s.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
                  </td>
                </tr>
              </table>
            </div>Both methods have advantages and disadvantages, but in essence they will enlarge granules, though not the distance between the white and black sets of granules. The side effect of this is of course a compression the ripples between the two sets of granules.<br>
            The second value '<code>90</code>' used above examples is the '<i>Phase</i>' of the <a href="../transform/#function_sinusoid">Sinusoid Function</a>. It will determine the color that the 'black' granule in the source image will become in the 'rippled' image.
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick random_enhanced.png  -function Sinusoid 3,0     ripples_3e000.png
  magick random_enhanced.png  -function Sinusoid 3,90    ripples_3e090.png
  magick random_enhanced.png  -function Sinusoid 3,180   ripples_3e180.png
  magick random_enhanced.png  -function Sinusoid 3,270   ripples_3e270.png
</samp></pre>
                  </td>
                </tr>
              </table><a href="random_enhanced.png"><img src="random_enhanced.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="=&gt;"> <a href="ripples_3e000.png"><img src="ripples_3e000.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_3e090.png"><img src="ripples_3e090.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_3e180.png"><img src="ripples_3e180.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <a href="ripples_3e270.png"><img src="ripples_3e270.png" width="100" height="100" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a>
            </div>The color of the 'white' granule, will depend on both the '<i>Phase</i>', and the fraction of the '<i>Frequency</i>' that use applied. An integer '<i>Frequency</i>' value will cause both white and black granules to vary in color together (according to the '<i>Phase</i>'). as such with a pahse of '<code>90</code>' both will be white.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr align="bottom">
                <td width="100%" align="justify">
                  However if you apply a fractional '<i>Frequency</i>' value of say '<code>0.5</code>', the 'white source' granule, will be the negative of the 'black source' granule (as determined by the '<i>Phase</i>').
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick random_enhanced.png  -function Sinusoid 3.5,90    ripples_3.5e.png
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="ripples_3.5e.png"><img src="ripples_3.5e.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note for the 'gray' '<i>Phase</i> angles, one of granules is surrounded by a white ring, while the other is surrounded by a black ring. If a '<i>Frequency</i>' value with a '<code>0.5</code>' fraction is used, the first ripple around each spot will be all white or all black, depending on the '<i>Phase</i>' used.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Other 'Frequencies' other than integers, or '<code>0.5</code>' are not recommended as the two sets of granules will not be synchronized in some way.<br>
                <br>
                Similarly Phases other multiple of 90 degrees are not recommended unless generating a 'ripple animation' (see below).<br>
                <br>
                A Phase value of '<code>0</code>' is recommended when generating a 'Dispersion Maps' (see below) as this will cause minimal distortions within the enhanced 'granule' areas.</i></font></td>
              </tr>
            </table>As previously in <a href="#random_flux">Random Flux</a>, you can modify the '<i>Phase</i>' with time so as to generate an animation of the ripples moving from one set of granules to the other. This works particularly well without any contrast enhancement.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="ripples_anim.gif">
  for i in `seq 0 30 359`; do
    magick random_10_gray.png -function Sinusoid 3.5,${i} miff:-
  done |
    magick miff:- -set delay 15 -loop 0 ripples_anim.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="ripples_anim.gif"><img src="ripples_anim.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>ASIDE: the technique used in the above is known as a "Pipelined <a href="../files/#miff">MIFF:</a>" and is possible as the <a href="../files/#miff">MIFF:</a>" file format can simply 'concatenate' images to generate a multiple image file. One point is that the animation seem to change much much slower than a <a href="#random_flux">Flux Animation</a> we created above. That is, because over the one animation cycle a ripple will only travel a short distance, where in a 'flux' animation thge change will travel from the large scale white to black granules in just half the cycle and back again. Now you can combine the above ripple animation with an underlying 'flux' animation from the same random image source to generate a much more dynamic and flowing form, but be warned of that animation speed difference.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  For example, here I just take the previous <a href="#random_flux">Flux Animation</a> created above, and add ripples to it. The ripples will in this case move only because the gradient in the flux animation moves. <!-- <CODE EXECUTE>
  magick flux_{?,??,???}.png -function Sinusoid 3.5,0 \
          -set delay 20 -loop 0  flux_rippled_anim.gif
</CODE> -->
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code executed_above="">
  magick flux_anim.gif -function Sinusoid 3.5,0 flux_rippled_anim.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="flux_rippled_anim.gif"><img src="flux_rippled_anim.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>You can also animate the ripples within the animation. Though you may need to use a much larger 'phase cycle rate' (the 'j = 5 * i' expression) for the ripples themselves. Also as you are generating a cycle within a cycle, you will need to generate a much longer animation 60 frames in this case. However that has the benefit of slowing the larger 'flux' movements down too.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" script="" image="ripples_flux_anim.gif">
  for i in `seq 0 10 359`; do
    j=`expr $i \* 5`
    magick random.png -channel G \
            -function Sinusoid 1,${i} \
            -virtual-pixel tile -blur 0x8 -auto-level \
            -function Sinusoid 2.5,${j} \
            -separate +channel miff:-
  done |
    magick miff:- -set delay 15 -loop 0 ripples_flux_anim.gif
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="ripples_flux_anim.gif"><img src="ripples_flux_anim.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note in the second image how ripples seem to first come out from one point, then later they start back going into the same point, though they never just simply reverse direction. A better multi-cycled flux cycle generator should remove this slight weirdness by removing the 'negative' effect in the flux underlying flux animation.<br>
            <i>FUTURE: Use of Rippled Random Images for Dispersion Mapped Distortions</i>.
            <hr>
            <!-- ---------------------------------------------------------------- -->
            <a name="tile" id="tile"></a>
            <h2>Tiled Canvases</h2>Tile images can be very large or very small, are designed to fit together side-by-side and vertically to cover large areas of space. Thanks to the World Wide Web, there as been an explosion of tile images available for use (finding what you want is another matter). Below are a set of tiled images which I copied from <a href="http://www.ict.griffith.edu.au/anthony/icons/">Anthony's Icon Library</a> for use through out these example pages.
            <table align="center">
              <tr valign="bottom">
                <td align="center">
                  <a href="../images/bg.gif"><img src="../images/bg.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  bg.gif
                </td>
                <td align="center">
                  <a href="../images/tile_aqua.jpg"><img src="../images/tile_aqua.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  tile_aqua.jpg
                </td>
                <td align="center">
                  <a href="../images/tile_water.jpg"><img src="../images/tile_water.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  tile_water.jpg
                </td>
                <td align="center">
                  <a href="rings.jpg"><img src="rings.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  rings.jpg
                </td>
                <td align="center">
                  <a href="../images/tile_disks.jpg"><img src="../images/tile_disks.jpg" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  tile_disks.jpg
                </td>
                <td align="center">
                  <a href="../images/tile_weave.gif"><img src="../images/tile_weave.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  tile_weave.gif
                </td>
              </tr>
            </table>Currently there are quite a number of way in which you can tile an image, over a large area. You can "<code><a href="../option_link.cgi?tile">-tile</a></code>" any image so as to completely replace the original background image (using the "<code>Copy</code>" compose operator). (For more details see <a href="../compose/#tile">Tile Compositing</a>).
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick composite -tile tile_weave.gif -size 60x60  xc:none   tile_copy.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_copy.gif"><img src="tile_copy.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Another way is to read in the tile image using the "<code>tile:</code>" coder, and tile it to a specific size.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 tile:bg.gif  tile_size.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_size.gif"><img src="tile_size.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Note that the "<code>tile:</code>" coder will replace any transparency in the image with the current background color. That is, because internally it generates a canvas of the size requested and 'overlays' the tiling image onto that canvas.<br>
                <br>
                If you want to preserve transparency either set "<code>-background none</code>" or "<code>-compose SRC</code>" (see <a href="../compose/#src">Src Compose Method</a> for details).</i></font></td>
              </tr>
            </table>You can use this to generate a tiled image much larger than you need, then use "<code><a href="../option_link.cgi?composite">-composite</a></code>" to overlay it over the original image. If the tile image is partially transparent then a '<code><a href="../compose/#over">Over</a></code>' "<code><a href="../option_link.cgi?compose">-compose</a></code>" method will need to be specified. It is a very slow method of tiling, particularly for large images, and you have the problem of determining just how big an image you need to create for the overlay.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick test.png -size 200x200 tile:tile_disks.jpg \
          -composite  tile_over.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_over.gif"><img src="tile_over.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>By specify a tile as 'tile fill pattern' for the "<code><a href="../option_link.cgi?draw">-draw</a></code>" operator, you can draw the tile image over another image, to create any shape or figure you like. This is because the "<code><a href="../option_link.cgi?tile">-tile</a></code>" setting will override any of the "<code><a href="../option_link.cgi?fill">-fill</a></code>" color setting used by draw. See <a href="../draw/#settings">MVG Drawing Settings</a>.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 xc: -tile tile_aqua.jpg \
          -draw "circle 30,30 2,30"   tile_draw.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_draw.gif"><img src="tile_draw.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This only works for "<code><a href="../option_link.cgi?draw">-draw</a></code>" and operators like "<code><a href="../option_link.cgi?annotate">-annotate</a></code>" that also make use of "<code><a href="../option_link.cgi?draw">-draw</a></code>" to perform their function. It will not work for image operators that use "<code><a href="../option_link.cgi?fill">-fill</a></code>" color directly, like "<code><a href="../text/#label">label:</a></code>", "<code><a href="../text/#caption">caption:</a></code>", and "<code><a href="../text/#text">text:</a></code>".
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  However "<code><a href="../option_link.cgi?draw">-draw</a></code>" has built in to it some special <a href="../draw/#color">color primitives</a>, such as completely resetting all the pixels in the image to the fill color or tile pattern (if set).
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr valign="bottom">
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick test.png   -tile tile_water.jpg  -draw "color 0,0 reset" \
          tile_reset.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_reset.gif"><img src="tile_reset.gif" width="150" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This is actually exactly the same method as used by some <a href="#solid">Solid Color Canvases</a> methods using a <a href="#specific">Specific Color</a>. Only here we used "<code><a href="../option_link.cgi?tile">-tile</a></code>" instead of a "<code><a href="../option_link.cgi?fill">-fill</a></code>" color.<br>
            A more advanced method is to use a <a href="../distorts/#distort">Distort Operator</a> with a special <a href="../distorts/#distort_viewport">Distort Viewport</a> setting, that was set to the size of the original image (using a <a href="../basics/#define">Defined Global Artifact</a> and <a href="../basics/#arg_percent">Percent Escapes</a>). This basically maps the smaller tiles <a href="../misc/#virtual">Virtual Pixels</a>, that surrounds the small tile image, to generate the larger tiled canvas.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -set option:distort:viewport '%g' +delete  \
          tree.gif -virtual-pixel tile -filter point -distort SRT 0 \
          tile_distort_sized.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_distort_sized.gif"><img src="tile_distort_sized.gif" width="70" height="46" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>See <a href="#tile_distort">Tiling via Distort</a> (below) where we will look at this same technique to tile an image that is already in memory. <a name="tile-offset" id="tile-offset"></a>
            <h3>Offset Tiling Canvases</h3>Sometimes you need a little more control over the exact positioning of a background texture, either for aligning a tile pattern with some other image, or to avoid a bad correlation with some other part of the final image. For many of the standard tiling methods this can be achieved using the "<code><a href="../option_link.cgi?tile-offset">-tile-offset</a></code>" setting. For example, here I roll the tile image being used to directly create a tiled canvas image using "<code>tile:</code>" or "<code>pattern:</code>".
            <div align="center">
              <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                <tr>
                  <td>
                    <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 -tile-offset +30+30 tile:rose: offset_tile.gif
  magick -size 80x80 -tile-offset +20+20 \
                                 pattern:checkerboard offset_pattern.gif
</samp></pre>
                  </td>
                </tr>
              </table><a href="offset_tile.gif"><img src="offset_tile.gif" width="80" height="80" align="middle" vspace="5" hspace="20" border="1" alt="[IM Output]"></a> <a href="offset_pattern.gif"><img src="offset_pattern.gif" width="80" height="80" align="middle" vspace="5" hspace="20" border="1" alt="[IM Output]"></a>
            </div>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i><a href="../crop/#tile-offset">Tile Offset</a> setting was broken before IM version 6.3.9-9 in that the 'X' offset was being used for both 'X' and 'Y' offset values (the given 'Y' value was ignored). This means that while the above examples would have worked (both X and Y offsets are the same) you may not get the expected results when the two values differ.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  This also works for the "<code>magick montage</code>" background "<code><a href="../../option_link.cgi?texture">-texture</a></code>" setting.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  montage tree.gif     -geometry +24+24 \
          -tile-offset +30+30 -texture rose: offset_texture.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="offset_texture.gif"><img src="offset_texture.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You can also use the setting by defining it before the "<code><a href="../../option_link.cgi?tile">-tile</a></code>" or "<code><a href="../../option_link.cgi?fill">-fill</a></code>" setting. For example...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -tile-offset +30+30  -tile rose: \
          -size 80x80 xc: -draw 'color 30,20 reset'    offset_tile_fill.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="offset_tile_fill.gif"><img src="offset_tile_fill.gif" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Make sure that the "<code><a href="../../option_link.cgi?size">-size</a></code>" setting is reset before defining the "<code><a href="../../option_link.cgi?tile">-tile</a></code>" image, but after any other image has been read in.
            <table border="0" cellspacing="0" cellpadding="0" width="100%">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80  xc: \
          -tile-offset +20+20 +size -tile pattern:checkerboard \
          -draw 'color 30,20 reset'  offset_pattern_good.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="offset_pattern_good.gif"><img src="offset_pattern_good.gif" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>In any case it is probably best to define the tile offset and tile image just before its first use, which has the same result as the above solution. <a name="tile_memory" id="tile_memory"></a>
            <h3>Tiling with an Image already In Memory</h3>
            <p>Tiling an image you have in memory (created or modified) is not straight forward, and only a few indirect methods are available.</p><a name="tile_clone" id="tile_clone"></a>
            <h4>Clone and Append the Tile Image</h4>If you are not worried about the exact size of the tiled image, you can just append the image together multiple times. For example, here we tile the image in a 3x3 array.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif \
          \( +clone +clone \) +append \
          \( +clone +clone \) -append \
          tile_clone.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_clone.gif"><img src="tile_clone.gif" width="96" height="96" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>This method of tiling has the advantage of allowing you to flip-tile (mirror tile) the image.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif \
          \( +clone -flop +clone \) +append \
          \( +clone -flip +clone \) -append \
          tile_clone_flip.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_clone_flip.gif"><img src="tile_clone_flip.gif" width="96" height="96" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>In general this method is only practical when you have some idea of how big the image being tiled is. Also as clones are actually very fast and efficient it is a fairly simple and fast tiling method, especially if you use the results to further tile the larger image. <a name="tile_mpr" id="tile_mpr"></a>
            <h4>Tile using MPR: (Memory Program Register)</h4>A better method is to save the image into a special 'In Memory' file format "<code><a href="../files/#mpr">mpr:</a></code>", or named 'memory program register'. From this register you can then either use a "<code><a href="../option_link.cgi?tile">-tile</a></code>" setting, or use the special "<code>tile:</code>" image file reader, both of which can only be set from a 'saved' image file format.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  For example using "<code>tile:</code>" to create a tiled image of a specific size...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif   -write mpr:tile +delete \
          -size 100x100 tile:mpr:tile    tile_mpr.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mpr.gif"><img src="tile_mpr.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Remember that the "<code>tile:</code>" coder will replace any transparency in the image with the current background color. (see above)</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  Or tile over an existing image, by setting the "<code><a href="../option_link.cgi?tile">-tile</a></code>" or "<code><a href="../option_link.cgi?fill">-fill</a></code>" fill pattern, and using "<code><a href="../option_link.cgi?draw">-draw</a></code>" to do a color reset (see <a href="../draw/#color">Color Fill Primitives</a>)...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif  -write mpr:tile +delete \
          granite: -fill mpr:tile  -draw 'color 0,0 reset' \
          tile_mpr_reset.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mpr_reset.gif"><img src="tile_mpr_reset.gif" width="128" height="128" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>If tiling with an image containing transparency, ensure the destination image also has transparency by using "<code>-alpha set</code>". If you do not the resulting image will show the tiles 'hidden' transparency color.</i></font></td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  Or draw using some other <a href="../draw/#primitives">Draw Primitive</a>, such as a circle, using the fill pattern.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif -write mpr:tile +delete \
          granite:  -tile mpr:tile  -draw 'circle 64,64 10,50' \
          tile_mpr_fill.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mpr_fill.gif"><img src="tile_mpr_fill.gif" width="128" height="128" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The name given after "<code><a href="../files/#mpr">mpr:</a></code>" can be anything you like, it is only a label on 'mpr' register name used to store the image, (in memory). It can even be a label, number, color, or even a filename. <a name="tile_distort" id="tile_distort"></a>
            <h4>Tiling using Virtual Pixels via Distort</h4>In this method we use the <a href="../misc/#virtual-pixel">Virtual Pixel Setting</a> to generate a large tiled canvas. This setting defines how the area surronding the actual image (outside the normal image bounds) should look. The easiest way to extract virtual pixels is to use the <a href="../distorts/#distort">Distort Operator</a> with a special <a href="../distorts/#distort_viewport">Distort Viewport</a> setting.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif -set option:distort:viewport 100x100+0+0 \
          -virtual-pixel tile -filter point  -distort SRT 0 \
          tile_distort.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>&nbsp;
                </td>
                <td>
                  <a href="tile_distort.gif"><img src="tile_distort.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You also have access to other styles of virtual pixel tiling settings, such as '<code><a href="../misc/#mirror">Mirror</a></code>', or even '<code><a href="../misc/#checker_tile">CheckerTile</a></code>', and even good offset tiling control using the viewport setting.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif -set option:distort:viewport 100x100-10-10 \
          -background firebrick  -virtual-pixel CheckerTile \
          -distort SRT 0 +repage    tile_distort_checks.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_distort_checks.gif"><img src="tile_distort_checks.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>By using the <a href="../distorts/#distort">General Distortion Operator</a> in this way, you also have the added bonus of distorting the tiled image in some very complex ways. You can see examples of this in <a href="../distorts/#affine_tile">Distort Affine Tiling</a>. As a more complex example, here I use an <a href="../distorts/#arc">Arc Distortion</a> to tile the tree around the origin which is centered in the viewport. The '<code>45</code>' specifies the angle the width of the tree covers, while the '<code>50</code>' defines the radius for the top edge of the tree tile. The rest just follows from this.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick tree.gif -set option:distort:viewport 100x100-50-50 \
          -virtual-pixel tile  -distort Arc '45 0 50' +repage \
          tile_distort_polar.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_distort_polar.gif"><img src="tile_distort_polar.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="pattern" id="pattern"></a>
            <h3>Modifying Built-in IM Patterns/Tiles</h3>See the full list of <a href="https://imagemagick.org/script/formats.php#builtin-images">ImageMagick Built In Images and Patterns</a>. There are a lot of such patterns, but I'll only look at one or two here. Now the built-in patterns are generally very very small images, which can tile to cover large areas. However, on their own they are very plain looking and rather useless. For example, here is one of the larger more interesting patterns that is provided...
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:checkerboard  pattern_default.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_default.gif"><img src="pattern_default.gif" width="30" height="30" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Pattern images are usually tiled over an larger areas, either as part of canvas creation, by setting a "<code><a href="../option_link.cgi?size">-size</a></code>", or as a fill tile (see <a href="#tile">Tiled Canvases</a> above). Without a size setting the default tile size of the pattern will be used, <code>30x30</code> pixels in this case. Now you will probably notice that all the patterns currently provided by IM are all pure black and white, with the single exception of the '<code>checkerboard</code>' pattern I used in the last example.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Here is one pattern I particularly like to use as a tile pattern...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 pattern:hexagons  pattern_hexagons.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_hexagons.gif"><img src="pattern_hexagons.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>If you are not happy with these colors you can replace them using the "<code><a href="../option_link.cgi?opaque">-opaque</a></code>" image operator.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 pattern:hexagons \
          -fill blue -opaque black   -fill skyblue -opaque white \
          pattern_colored.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_colored.gif"><img src="pattern_colored.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>If you want to color the "<code>checkerboard</code>" pattern, then that is best done by first using "<code><a href="../option_link.cgi?auto-level">-auto-level</a></code>" to map the two greys to black and white before substituting those two colors. Here instead of using "<code><a href="../option_link.cgi?opaque">-opaque</a></code>" to replace the colors, I use a "<code><a href="../option_link.cgi?level-colors">+level-colors</a></code>" operator (add IM v6.2.4-1), which is a bit simpler to use.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 pattern:checkerboard -auto-level \
          +level-colors red,blue     pattern_color_checks.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_color_checks.gif"><img src="pattern_color_checks.gif" width="60" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>You can also use "<code><a href="../option_link.cgi?floodfill">-floodfill</a></code>" operator to color the pattern. However for this to work properly you need to do this, <i>before</i> you tile the modified pattern. In this case I also need to expand the tile three times to color it with the regular pattern of colors I wanted.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x54 pattern:hexagons \
          -fill tomato     -opaque white \
          -fill dodgerblue -draw 'color 10,10 floodfill' \
          -fill limegreen  -draw 'color 10,25 floodfill' \
          -roll +15+27 \
          -fill dodgerblue -draw 'color 10,10 floodfill' \
          -fill limegreen  -draw 'color 10,25 floodfill'   miff:- |\
    magick -size 100x100 tile:- pattern_color_hexagons.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_color_hexagons.gif"><img src="pattern_color_hexagons.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>I used a pipeline of two commands in the above to separate the colored pattern creation, from its actual usage. If you like to do this with a single command see <a href="#tile_memory">Tiling an Image In Memory</a> above.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  You can also warp and distort a simple tiling pattern to produce an interesting variations. For example a 'wrinkling' effect (technique courtesy of the wrinkle IM effect from <a href="http://interactimage.com/">Font Image Generator</a>) on a hexagon pattern I found particularly interesting
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 160x100 pattern:hexagons \
          -wave 3x100 -background white -rotate 90 -wave 4x66 -rotate -87 \
          -gravity center -crop 120x90+0+0 +repage   pattern_distorted.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="pattern_distorted.gif"><img src="pattern_distorted.gif" width="120" height="90" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="tile_mod" id="tile_mod"></a>
            <h3>Modifying Tile Images</h3>The biggest problem people face with modifying tiles, whether it's an existing tile, or one of the built in patterns, is that many image operations destroy the 'tilability' of the image. For example, here I have taken the built-in '<code>hexagon</code>' pattern, and tried to modify it to produce a shaded gray-scale pattern of wide hexagonal lines.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:hexagons  -rotate 90 \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          miff:- |\
    magick -size 100x100 tile:-   tile_mod_failure.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mod_failure.jpg"><img src="tile_mod_failure.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The first command generates the 'tile image' while the second actually tiles the image, so we can see how they all fit together. As you can see the resulting tile image does NOT tile properly, with artificial edge distortions clearly visible in the tiled image. Basically we lost the uniformity of the original tile, along the edges of the image. One solution is to use a special <a href="../misc/#virtual-pixel">Virtual Pixels</a> setting, which is used to make operators think the image wraps around the edges, when looking up colors that are beyond the bounds of the actual image proper.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:hexagons  -rotate 90  -virtual-pixel tile \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          miff:- |\
     magick -size 100x100 tile:-   tile_mod_vpixels.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mod_vpixels.jpg"><img src="tile_mod_vpixels.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Here is another example where I join two related tile patterns together, and use various effects to create unusual brick wall tile.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:leftshingle pattern:rightshingle +append \
          -virtual-pixel tile  -blur 0x0.75 -resize 150% -shade 100x45 \
          -fill Peru  -tint 100%   miff:- |\
    magick -size 100x100 tile:-   tile_slanted_bricks.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_slanted_bricks.jpg"><img src="tile_slanted_bricks.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <h4>Alternative</h4>There is an alternative to relying on <a href="../misc/#virtual-pixel">Virtual Pixels</a>. Basically we provide the 'virtual edge pixels' ourselves before operating on the image, so as to avoid any edge effects that may be present. And that is done by tiling the image over a slightly larger area first. After modifying the image, we can re-extract the tile, avoiding the edge distortions that were introduced. It does not have to be lot bigger, depending on the extent of the image operations being performed. I have found 15 to 40 pixels should stop all edge effects in the final result. To re-extract the image we can either "<code><a href="../option_link.cgi?shave">-shave</a></code>" off the extra pixels, or "<code><a href="../option_link.cgi?crop">-crop</a></code>" the original tile size from the middle of the processed image. For example, here I create a 3d "<code><a href="../option_link.cgi?shade">-shade</a></code>" effect using the built-in '<code>hexagons</code>' pattern.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 tile:pattern:hexagons  -rotate 90 \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          -gravity center -crop 18x30+0+0 +repage miff:- |\
    magick -size 100x100 tile:-   tile_mod_success.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_mod_success.jpg"><img src="tile_mod_success.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note the exact position of the extracted tile does not matter. A tilable image can be cut anywhere from the tiled image, as long as it is away from the distorted edges, and you use the same original size of the tile. Here instead of tiling the image over a larger area, we use a 'double clone' technique to double the area the tile covers. When finished we then just center crop 50% of the image to recover our modified tile. This means we have no need to know the exact size of the tile you are processing.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:circles \( +clone \) +append \( +clone \) -append \
          -fill grey -opaque black  -blur 0x0.5 -shade 120x45 \
          -gravity center -crop 50%  +repage    miff:- |\
    magick -size 100x100 tile:-   tile_circles.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td>
                  <a href="tile_circles.jpg"><img src="tile_circles.jpg" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table><a name="tile_gen" id="tile_gen">
            <h3>Generating Tile Images</h3></a> The biggest problem you face when generating images that can tile together is trying to match the edges and corners of the image so that they can fit together seamlessly. If this is not done then all you get is a set of square boxes each with a repeated copy of the image. This is not an easy matter and can be a very frustrating and hair pulling experience. An object appearing in the tile on one edge must re-appear on the other side of the image in order to re-form the whole when the image is tiled. While you can do this fairly easily with computer generated images, it is next to impossible to produce a good tiling image featuring real-world photographs. The other major problem is trying to make the tile not look like it is repeating. The only true solution to this is to make your tile images large enough to contain enough very similar, but still different elements that it becomes difficult to see a repeated pattern. For this reason, generating small tiles that do not seem to repeat is especially difficult.
            <pre>
FUTURE:  Ideas and suggestions for generating tile patterns?  Anyone?

Or roll, add element, roll, add element, etc...

Any and all suggestions and examples accepted.

Suggestions for generating tile from real photos of repeating patterns,
such as water, fallen leaves, clouds, stucco, brickwork, etc...

Generating Escher-like tile patterns.
</pre><a name="tile_random" id="tile_random"></a>
            <h3>Random Noise Tile</h3>Because a raw random noise canvas has no edges characteristics to begin with (every pixel color is completely independent of any of its neighbours), you can tile it without worry about edge distortions. Basically it is so extremely random at the pixel level, no edges match to begin with, so we don't lose anything, by tiling. Unfortunately very few situations would use a raw random noise image, as is, for any real purpose. It is just so horribly random that it is useless. However by modifying the image while preserving its inherent tilability, we can make just about any randomized tile pattern we want.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  For example lets look at the a basic "<code><a href="../option_link.cgi?blur">-blur</a></code>" of the original tile, using the same 'modifying a tile' technique we used in the last example.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
<br>  magick -size 64x64 xc: +noise Random \
          -virtual-pixel tile -blur 0x6 -auto-level  tile_random.jpg

  magick -size 128x128   tile:tile_random.jpg   tiled_random.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_random.jpg"><img src="tile_random.jpg" width="64" height="64" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tiled_random.jpg"><img src="tiled_random.jpg" width="128" height="128" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="top">
                <td width="100%" align="justify">
                  Using this technique you can apply just about any transformation to a raw random noise image image. For example...
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
<br>  magick -size 64x64 xc: +noise Random \
          -virtual-pixel tile  -blur 0x6  -edge 1  -fx G \
          -shade 280x45  -auto-level  tile_random_pits.jpg

  magick -size 128x128 tile:tile_random_pits.jpg tiled_random_pits.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_random_pits.jpg"><img src="tile_random_pits.jpg" width="64" height="64" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tiled_random_pits.jpg"><img src="tiled_random_pits.jpg" width="128" height="128" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>As you can see it is a lot simpler to create randomized tiles using the raw random noise image, and you will not have any edge distortions in the results. This particular image transformation is listed on the <a href="../backgrounds/">Background Images</a> page and is titled "pits". See that page for lots of other image random image transformations, and examples of what they look like. <a name="tile_hex" id="tile_hex"></a>
            <h3>Hexagonal Tiling</h3>Rather than tile in a square fashion, the 'random noise' image allows use to generate a very different sort of tile. By doubling the image dimensions and re-laying the tile in the extra space, but offset by half, we can generate a basic random noise hexagonal tile pattern.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  This is the same sort of tiling effect we get when we tile the special "<code>pattern:hexagons</code>" built-in of ImageMagick.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick pattern:hexagons  tile_hexagons.gif

  magick -size 64x64  pattern:hexagons  tiled_hexagons.gif
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_hexagons.gif"><img src="tile_hexagons.gif" width="30" height="18" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tiled_hexagons.gif"><img src="tiled_hexagons.gif" width="64" height="64" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note however that for this tile to look 'hexagonal' the tile cannot be a normal square, or even a doubled square. The final tile size needs to be a rectangle. The exact ratio for this rectangle actually involves irrational numbers, which is not very good for image work with a pixel array. However a good working ratio is 4:3, which is used by most computer and digital camera images.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr valign="bottom">
                <td width="100%" align="justify">
                  Here we overlay the same 'random noise' image (a rectangle with a 2:3 ratio) two extra times to generate the basic hexagon pattern (in a 4:3 rectangle). The hex-tiled random noise tile is then transformed using the "paint_3s" transformation from the <a href="../backgrounds/">Background Images</a> page, to generate a rather nice looking hexagonal tile pattern.
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
<br>  magick -size 48x64 xc: +noise Random  -write mpr:rand \
          -extent 96x64  -page +48-32 mpr:rand  -page +48+32 mpr:rand \
          -flatten          tile_hex_random.jpg

  magick tile_hex_random.jpg -virtual-pixel tile -blur 0x10 -paint 3 \
          -shade 280x45 -auto-level  tile_hex_layered.jpg

  magick -size 160x160  tile:tile_hex_layered.jpg  tiled_hex_layered.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_hex_layered.jpg"><img src="tile_hex_layered.jpg" width="96" height="64" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tiled_hex_layered.jpg"><img src="tiled_hex_layered.jpg" width="160" height="160" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>If you look at the pattern the tile produces you will see that any specific feature, will have 6 copies of that same feature surrounding it in a circle. This is the 'hexagonal' pattern the tile produces, even though it is still tiled in the same 'square' pattern as all other tiling images. One variant of the above 'hextile' pattern is to double up the tile image vertically, rather than horizontally as we have done above. The result is that the hexagonal pattern will be rotated ninety degrees. It is however still the same type of pattern.
            <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
              <tr valign="top">
                <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                <td align="justify" width="100%"><font size="-1"><i>Mathematically the above is not generating a new <a href="http://en.wikipedia.org/wiki/Wallpaper_group">Wallpaper Group</a> form an existing tile. Both the original 'non-hexagonal' image and the final verson belong to the same '<b>p1</b>' tiling group.<br>
                <br>
                What we are actually doing in the above is converting a rhombus 'prototile' tiling pattern into a larger rectangular orthogonally aligned 'fundamental domain' of the same tiling pattern. In this way you can then tile the image using a standard tiling method.</i></font></td>
              </tr>
            </table><i>Future: Flip the extra image over to generate a larger tiling pattern (<b>pmg</b> tiling group).</i> <i>Future: how to cut out (mask) a hexagon from an image so it will tile perfectly, without gaps or overlaps.</i> <a name="tile_triple_hex" id="tile_triple_hex"></a>
            <h3>Triple Hex Tiling</h3>Like we did when coloring the the "<code>hexagons</code>" built-in pattern (See <a href="#pattern">Modifying Built-in IM Patterns/Tiles</a> above), you can make three different variants of the initial tile, (with rotations for example) before re-mapping them to form the larger tile. Of course, just as I did when coloring the "<code>hexagons</code>" pattern, the final tile image will need to be enlarged three times larger, so as to generate a repeating rectangular tile pattern. The variations between the three tiles generated must not be too different, and should survive any post-processing, otherwise you will not get the benefits of the technique. This means the initial tile must be reasonably large as well, so any distinct features present will be preserved. For example, here we take a very simple line drawing, and rotate it to produce 3 similar variations. These rotated images are then tiled seven times onto a larger canvas (6 times larger) to produce the triple image hex pattern.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre class="bg-light text-dark mx-4"><samp>
  magick -size 24x24 xc: -draw "rectangle 3,11 20,12"  tile_line.gif

  magick tile_line.gif   -gravity center\
          \( +clone -rotate    0 -crop 24x18+0+0 -write mpr:r1 +delete \) \
          \( +clone -rotate  120 -crop 24x18+0+0 -write mpr:r2 +delete \) \
                    -rotate -120 -crop 24x18+0+0 -write mpr:r3 +repage \
          -extent 72x36        -page  +0+0  mpr:r3 \
          -page +24+0  mpr:r1  -page +48+0  mpr:r2 \
          -page -12+18 mpr:r1  -page +12+18 mpr:r2 \
          -page +36+18 mpr:r3  -page +60+18 mpr:r1 \
          -flatten tile_hex_lines.jpg

  magick -size 120x120  tile:tile_hex_lines.jpg  tiled_hex_lines.jpg
</samp></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_line.gif"><img src="tile_line.gif" width="24" height="24" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tile_hex_lines.jpg"><img src="tile_hex_lines.jpg" width="72" height="36" align="middle" vspace="10" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tiled_hex_lines.jpg"><img src="tiled_hex_lines.jpg" width="120" height="120" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The above however only works for tiling a small shape in the middle of the original image. It does not work well for a general image. For a general image hex tiling we also need to mask out an equilateral triangles. The pieces are then rotated so the equilateral trianlge edges are mirrored. This is not an easy task. <a name="tile_diagonal" id="tile_diagonal"></a>
            <h3>Diagonal Mirror Tiling</h3>Here is one way to take any square image and magick it into 8 mirrored images around a central point. Specifically we are generating a complex '<b>p4m</b>' tiling pattern. I first generate <a href="#random_hue">Random Hue Image</a>, and using the bottom-left half of the source image I mirror it diagonally, then horizontally and vertically.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 50x50 xc: +noise Random -virtual-pixel Tile -blur 0x5 \
          -auto-level -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB   tile_diag_source.jpg

  magick tile_diag_source.jpg     \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -flop -chop 1x0 \) +append \
          \( +clone -flip -chop 0x1 \) -append \
          tile_diag_mirror.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_diag_source.jpg"><img src="tile_diag_source.jpg" width="50" height="50" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                  <a href="tile_diag_mirror.jpg"><img src="tile_diag_mirror.jpg" width="99" height="99" align="middle" vspace="10" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The diagonal mirror is generated by doing a <a href="../warping/#transpose">Transpose</a> and then using a mask generated using a <a href="#voronoi">Voronoi, Sparse Color</a>. Note that this diagonal mirror automatically shares one line of pixels across the mirror in the same way, due to the pixel geometry of the square. I also remove one set of pixels along the edge before creating vertical and horizontal <a href="../warping/#flip">Flips and Flops</a>. I also recommend the removal another row and column of pixels along the top and left edge, before using this image as a 'tile'. You don't need to do this, but I think it looks better. Without removing one row and column of edge pixels, you get ugly 'seams' of doubled pixels, where the images join together. An alternative is to tile the raw random image first, then do the <a href="../backgrounds/">Background Pattern</a> conversion, you are less likely to get a 'clipped look' along the mirror lines, but a smoother transition.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 51x51 xc: +noise Random   \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -flop -chop 1x0 \) +append \
          \( +clone -flip -chop 0x1 \) -append \
          -chop 1x1 \
          \
          -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB    tile_p4m.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_p4m.jpg"><img src="tile_p4m.jpg" width="100" height="100" align="middle" vspace="10" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>The first part is the generation of the 'tiling of the random data' the second half I magick the random data into a 'hues' mapping. I also added the extra pixel to the initial image which will be later choped as appropiate to generate a tiling image.<br>
            For a more complete introduction into tiling images and the mathematics behind them, see <a href="http://en.wikipedia.org/wiki/Wallpaper_group">Wikipedia: Wallpaper Group</a>. What we have explored above is only a few of the many tiling patterns you can create.<br>
            The '<b>p4g</b>' is almost exactly the same as the '<b>p4m</b>' tiling above, but uses a 180 degree rotations of the mirrored squares, rather than using flips, to generate the full tiling image. However as the images are not joined by mirrors you can not use an existing image as the tile source as the edges will become disjoint and discontinuous. However you can tile the raw random data then process the resulting tile image, to produce a smooth result.
            <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
              <tr>
                <td width="100%" align="justify">
                  <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                    <tr>
                      <td>
                        <pre><code execute="" random="">
  magick -size 50x50 xc: +noise Random   \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -rotate -90 \) +append \
          \( +clone -rotate 180 \) -append \
          \
          -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB    tile_p4g.jpg
</code></pre>
                      </td>
                    </tr>
                  </table>
                </td>
                <td align="center">
                  <a href="tile_p4g.jpg"><img src="tile_p4g.jpg" width="100" height="100" align="middle" vspace="10" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>Note that due to the non-mirroring nature of the tiling, you do not need need to remove the duplicated row or column of pixels from the edges before you append. Though it does not hurt to do so, if you want to follow the same type of process for both cases.<br>
          </div>
          <hr>
          <!-- ---------------------------------------------------------------- -->
        </div>
      </div>
    </div>
  </main>
  <footer class="magick-footer">
    <div class="container-fluid">
      Created: 19 December 2003<br>
      Updated: 22 March 2011<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://imagemagick.org/Usage/canvas/</code>
    </div>
  </footer>
</body>
</html>
