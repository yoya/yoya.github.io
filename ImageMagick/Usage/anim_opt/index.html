<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Animation Optimization -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/anim_opts/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Animation Optimization</h1>
        <div>
          <dl>
            <dt><b>Index</b></dt>
            <dt>
              <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
            </dt>
            <dd>
              <a href="#intro"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Introduction to Optimization</a>
            </dd>
            <dd>
              <a href="#optimize"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15">General Purpose GIF Optimizer of ImageMagick</a>
            </dd>
            <dd>
              <a href="#frame_opt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Frame Optimization</a>
              <ul>
                <li>
                  <a href="#optframe">Basic Frame Optimization</a>
                </li>
                <li>
                  <a href="#repeated_frame">No Pixel Overlay</a> - repeated image every second frame
                </li>
                <li>
                  <a href="#hole">Moving Hole Animation</a> - a difficult to frame optimize animation
                </li>
                <li>
                  <a href="#doubling">Frame Doubling</a>
                </li>
                <li>
                  <a href="#optimizeplus">Layer Optimize Plus</a>
                </li>
                <li>
                  <a href="#removedups">Remove Duplicate Frames</a>
                </li>
                <li>
                  <a href="#splitting">Splitting Frame Updates</a>
                </li>
                <li>
                  <a href="#removezero">Remove Zero Delay Frames</a>
                </li>
                <li>
                  <a href="#frame_results">Frame Optimization Results and Summary</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#semitrans_opt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Semi-Transparency Handling</a>
            </dd>
            <dd>
              <a href="#color_opt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Color Optimization</a>
              <ul>
                <li>
                  <a href="#color_problem">GIF Color Problem</a>
                </li>
                <li>
                  <a href="#speed">Speed Animation</a> - an animation with too many colors
                </li>
                <li>
                  <a href="#color_frame_first">Frame Opt Before Color Opt?</a>
                </li>
                <li>
                  <a href="#color_fuzz">Fuzzy Color Optimization</a>
                </li>
                <li>
                  <a href="#colortables">Single Global Color Table</a>
                </li>
                <li>
                  <a href="#dithering">Dithering Colors</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#compress_opt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Compression Optimization</a>
              <ul>
                <li>
                  <a href="#opt_trans">Transparency Optimization</a>
                </li>
                <li>
                  <a href="#opt_lzw">LZW Optimization</a>
                </li>
                <li>
                  <a href="#opt_lzw_lossy">Lossy LZW Optimization <font size="-1">- (non-IM)</font></a>
                </li>
                <li>
                  <a href="#opt_lzw_dithered">Ordered Dithered LZW Optimization</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#minor_opt"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Minor Optimizations</a>
            </dd>
            <dd>
              <a href="#gif_links"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15">Other Sources of Information on GIF Optimization</a>
            </dd>
          </dl>These examples start to make use of the <a href="../anim_basics/">Basic Animation Handling</a>, to try to optimize the final display and file size of an animation. This is especially important for complex GIF animations where smaller sub-frame overlays can be used, as well as three types of disposal methods controlling how an animation is handled.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="intro" id="intro"></a>
          <h2>Introduction to Animation Optimization</h2>Optimizing an animation is not easy, especially a GIF animation that has color restrictions, as well as a choice of different frame disposal techniques, and the ability to use smaller 'sub-frame' overlays from one frame to the next. When optimizing animation you should try to optimize them in the following order.
          <ul>
            <li>
              <a href="#minor_opt">Minor Optimizations</a>
            </li>
            <li>
              <a href="#semitrans_opt">Semi-Transparency Handling</a>
            </li>
            <li>
              <a href="#color_opt">Color Optimizations</a>
            </li>
            <li>
              <a href="#frame_opt">Frame Optimizations</a>
            </li>
            <li>
              <a href="#compress_opt">Compression Optimizations</a>
            </li>
            <li>
              <a href="#colortables">Single Global Color Table</a>
            </li>
          </ul>That however is not the order we will look at these optimization techniques. For GIF animations <a href="#frame_opt">Frame Optimization</a> is the most basic optimization technique, and where the most gains can be made. As such it will be looked at first. Probably the hardest aspect of optimization that users have trouble with is <a href="#color_opt">Color Optimizations</a> caused by the color limitations of the GIF animations. One aspect of this <a href="#colortables">Single Global Color Table</a> has to be done as a the last step before saving to GIF or you may loose the operators effect on the final GIF file save.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="optimize" id="optimize"></a>
          <h2>General Purpose GIF Optimizer of ImageMagick</h2>The "<code><a href="../option_link.cgi?layers">-layers</a></code>" method '<code><b>Optimize</b></code>' will use a number of the techniques, that we will discuss in detail below, to attempt to optimize a GIF animation in a single reasonable step. Currently this option is equivalent to (in order)...
          <ul>
            <li>A <a href="../anim_basics/#coalesce">Coalesce</a> the Animation.
            </li>
            <li>Basic <a href="#optframe">Frame Optimization</a>
            </li>
            <li>and <a href="#opt_trans">Transparency Optimization</a>
            </li>
          </ul>At which point you can immediately save the GIF animation. These are reasonably safe optimization steps that can be applied to most animation sequences, however there is no guarantee, that it will result in a smaller GIF animation. This is particularly true of an raw video sequence where a <a href="#opt_trans">Transparency Optimization</a> will generally result in a worsening of the LZW compression ratio. However for most GIF animations, involving cartoon like images, the '<code>Optimize</code>' operator should produce a good well optimized animation. The operator however is still in development, and in future is likely to also include extra standard optimization steps, such as...
          <ul>
            <li>A 50% Threshold of the alpha channel, just as the IM does normally does when saving to the GIF file format, to remove semi-transparent pixels. You can still do the semi-transparency handling yourself before hand to override this, if you like. See <a href="../formats/#boolean_trans">GIF Boolean Transparency</a> for more detail.
            </li>
            <li>Some type of <a href="#color_opt">Color Optimization</a> technique. Exactly what, is still to be decided, and may be selected depending on the animation and the number of colors involved. <i>Suggestions Welcome</i>.
            </li>
            <li>A <a href="#colortables">Single Global Color Table</a>, "<code><a href="../option_link.cgi?map">+map</a></code>" operation.
            </li>
          </ul>In other words, it is hoped that '<code>Optimize</code>' will eventually become the IM generic GIF animation optimizer, for quick and easy use by IM users. Until then be careful of its use, especially in scripts as it will change. Of course as many optimization steps may not be worth the effort for a specific animation. This option will also likely become quite slow. This is the plan, and the goal that this IM Examples section, was looking toward.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="frame_opt" id="frame_opt"></a>
          <h2>Frame Optimizations</h2>Frame optimization is based on overlaying a smaller sub-image rather than a complete overlay of the whole image. This obviously produces a smaller number of pixels and thus a smaller file on disk, to being sent across the network. Also overlaying a smaller frame means the client computer does not have to do as much work in changing pixels on screen. However there are different disposal methods available in the GIF format to handle the last frame displayed, and that can result in different size overlays. Not only that but it is possible to split up the overlays into multiple parts, or update actions, bring about a more complex but more optimized animation. Because of the complexity of doing frame optimizations, any existing frame optimizations are typically always removed first by using "<code><a href="../option_link.cgi?coalesce">-coalesce</a></code>" operation. See <a href="../anim_basics/#coalesce">Coalesce Examples</a>. Naturally that means any hand optimizations that may have existed are also removed, so some caution is advised. <a name="optframe" id="optframe"></a>
          <h3>Basic Frame Optimization</h3>The "<code><a href="../option_link.cgi?deconstruct">-deconstruct</a></code>" method will produce a basic frame optimization for a GIF animation. However as was shown in the <a href="../anim_basics/#deconstruct">Deconstruct Examples</a> of the previous section, this operator does not work with all GIF animations when transparent pixels are involved. Specifically when an animation clears any colored pixel to transparency. That is, it will only work with <a href="#overlay">Overlay Animations</a>. The "<code><a href="../option_link.cgi?layers">-layers</a></code>" method '<code><b>OptimizeFrame</b></code>' is designed to be a GIF Frame Optimizer, which will try to find the smallest sub-frames overlay images, using any GIF disposal method. The result is generally a <a href="#mixed">Mixed Disposal Animation</a> though often it will also generate a <a href="#clear">Cleared Frame Animations</a> or <a href="#overlay">Pure Overlay Animations</a>, if that was determined to be the best solution for the specific animation. Remember the input animation must be a '<i>coalesced animation</i>', so it consists of a sequence of complete image frames, all the same size, without any canvas offsets. Of course any existing dispose methods in coalesced animation is completely irrelevant, and will be ignored by the '<code>OptimizeFrame</code>' method. For example, lets try this with a <a href="../anim_basics/#previous">Dispose Previous Animation</a>, created in the previous section.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick canvas_prev.gif -coalesce  -layers OptimizeFrame  optframe.gif
  gif_anim_montage optframe.gif optframe_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="optframe.gif"><img src="optframe.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="../anim_basics/coalesce_frames.gif"><img src="../anim_basics/coalesce_frames.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/space.gif" align="middle" width="20" height="20" alt="==&gt;"><br>
                <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="optframe_frames.gif"><img src="optframe_frames.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see "<code><a href="../option_link.cgi?layers">-layers</a> OptimizeFrame</code>' correctly returned our animation back into its original frame optimized form, using <a href="../anim_basics/#previous">Previous Disposal</a>. This optimization even works properly for the trickier to handle <a href="../anim_basics/#background">Background Dispose Animations</a>...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick canvas_bgnd.gif -coalesce  -layers OptimizeFrame  optframe_bgnd.gif
  gif_anim_montage optframe_bgnd.gif optframe_bgnd_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="optframe_bgnd.gif"><img src="optframe_bgnd.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="optframe_bgnd_frames.gif"><img src="optframe_bgnd_frames.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The animation is perfectly frame optimized using <a href="../anim_basics/#background">Background Disposal</a>. This operator will work correctly for all GIF animations, and will generally return the best possible simple 'dispose and frame optimization' possible.<br>
          Now for some bad news about any type of simple frame optimization, such as what IM provides... While '<code><a href="#optframe">OptimizeFrame</a></code>' returns the best possible frame optimization for a given animation that IM can figure out, there are is a number of special cases where it does not do well. These include...
          <ul>
            <li>Animations where pixel clearing (returning to transparency) is needed, but the frame overlays are too large to efficiently clear the small areas of pixels that needs to be cleared (see the <a href="#hole">move hole animation</a> below).
            </li>
            <li>Animations involving two or more small areas of change that are distantly separated. These are actually quite common, and horrible to frame optimize. (See <a href="#splitting">Splitting Frame Updates</a> below)
            </li>
            <li>Animations with very complex backgrounds that remain static for long periods (more than 3 frames), but then change slightly before remain static for another long period, etc., etc., etc... Or a static background that becomes greatly obscured for a very short period. It can be near impossible for any computer algorithm to figure out the 'best' frame optimization in this complex situation (IE: What should be regarded as a static background?). Only humans with their intuitive grasp on what they see, can generate a good optimally frame overlay sequence in these cases.</li>
          </ul><i>Examples of difficult to optimize animations wanted, please contribute.</i> If you find an example of an animation which IM fails to produce a good optimization, please mail it to me for further study. This is how new techniques and possible automatic solutions can be developed. I will naturally publish your name as a contributor. <a name="repeated_frame" id="repeated_frame"></a>
          <h3>No Pixel Overlay <font size="-1">- repeated image every second frame</font></h3><a href="../images/paddleball.gif"><img src="../images/paddleball.gif" width="80" height="89" align="right" vspace="0" hspace="5" border="1" alt="[animation]"></a> Sometimes the best optimization for an image involves not overlaying any pixels at all! For example to the right is a simple animation, contributed by nixscripter. If we look at its frames you can see it is not very optimized. But notice that every second frame of the animation is simply repeated.<br clear="all">
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  gif_anim_montage paddleball.gif paddleball_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="paddleball_frames.gif"><img src="paddleball_frames.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
          </div>After frame optimizing it we get a very special GIF disposal sequence.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick paddleball.gif -coalesce -layers OptimizeFrame  paddleball_opt.gif
  gif_anim_montage paddleball_opt.gif paddleball_opt_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="paddleball_opt.gif"><img src="paddleball_opt.gif" width="80" height="89" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="paddleball_opt_frames.gif"><img src="paddleball_opt_frames.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>What is happening is that rather than overlaying the original frame IM chose to recover the first image using a '<a href="../anim_basics/#previous">Previous</a> GIF disposal. As that recovered frame is left as is, there are no changed pixels. So the sub-frame overlay gets reduced nothing. Unfortunately, neither IM or the GIF format allow you have a zero sized image, so a special one transparent pixel minimal image is used instead. This image is known as a <a href="../crop/#crop_missed">Missed Image</a> as it is also extensively used when "<code><a href="../option_link.cgi?crop">-crop</a></code>" 'misses' the actual image data, producing the same result. This image, in effect, only preserves the frames meta-data, such as: <a href="../anim_basics/#dispose">Dispose Method</a>, <a href="../anim_basics/#delay">Time Delay</a>, and <a href="../anim_basics/#loop">Loop Iterations</a>. As such it is an essential part of the animation, even though it is 'empty'. So by overylaying a bare minimal single transparent pixel, IM saved a huge amount of space (and time) in this animation.<br>
          <a name="hole" id="hole"></a>
          <h3>Moving Hole Animation <font size="-1">- difficult to frame optimize</font></h3>Here is one extreme case of GIF animation that does not frame optimize very well by any normal optimization method. This animation basically consists of a simple unchanging background image but with a transparent 'hole' through that background that changed position from frame to frame. To create it I need to make a coalesced image sequence, where I cut up a hole in a fixed background image, using <a href="../anim_mods/#compose">Layer Alpha Composition</a>. I also used a "<code><a href="../option_link.cgi?antialias">+antialias</a></code>" switch to ensure only four colors are used three blues and the transparency. So we don't need to deal with <a href="#colors">Color Optimization Problems</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="middle">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick +antialias -size 100x100 -delay 100 xc:SkyBlue -loop 0 \
          -fill DodgerBlue -draw 'circle 50,50 15,25' \
          -fill RoyalBlue  -draw 'circle 50,50 30,25' \
          null: \( -size 100x100 xc:none -draw 'circle 40,25 27,22' \) \
                \( +clone -rotate 90 \) \( +clone -rotate 90 \) \
                \( +clone -rotate 90 \) -compose DstOut -layers Composite \
          -set dispose background  moving_hole.gif
  gif_anim_montage moving_hole.gif moving_hole_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="moving_hole.gif"><img src="moving_hole.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_frames.gif"><img src="moving_hole_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_size.txt>
    ls -l moving_hole.gif | awk '{printf "%d", $5}'
</CODE> -->
          As you can see the animation works, with a round 'hole' showing the background color of this page, producing an animation file of <a href="moving_hole_size.txt"><img src="moving_hole_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes in size. So lets try a straight-forward frame optimization for this animation.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole.gif  -layers OptimizeFrame  moving_hole_opt.gif
  gif_anim_montage moving_hole_opt.gif moving_hole_opt_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_opt.gif"><img src="moving_hole_opt.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_opt_frames.gif"><img src="moving_hole_opt_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Hang on, nothing happened! The best optimization IM could achieve was no change at all! Is the above coalesced version of this animation its most optimal? Well for the animation as it stands... Yes, this really is the best simple optimization that can be achieved by pure frame disposal optimization! Not good. The problem is that for a GIF animation to 'clear' or 'erase' the pixels drawn by previous frames, it needs to use a '<a href="../anim_basics/#background">Background</a>' dispose method. Though in some special situations a '<a href="../anim_basics/#previous">Previous</a>' dispose method can also be used. However '<a href="../anim_basics/#background">Background</a>' dispose only can clear areas that were just overlaid. As the first frame was a complete overlay of the whole image, the whole image will be cleared. Even though only a small section of the animation needs to have its pixels cleared. As a consequence the whole of the second frame needs to be overlaid, even though most of that frame was just previously displayed! This horrible catch-22 situation continues all the way across the rest of the animation, producing no basic frame optimizations. I did say this animation would be difficult to frame optimize. <a name="doubling" id="doubling"></a>
          <h3>Frame Doubling <font size="-1">- a method to frame optimize 'holes'</font></h3>All is not lost however. By adding some extra frames to the animation, you can give the '<code><a href="#optframe">OptimizeFrame</a></code>' method some room in which to make better use of the GIF disposal methods available. Here for example we add an extra frame by doubling up the first image, but giving it a zero time delay so as not to change the overall timings of the animation.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole.gif[0] -set delay 0   moving_hole.gif \
          -layers OptimizeFrame    moving_hole_dup.gif
  gif_anim_montage moving_hole_dup.gif moving_hole_dup_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_dup.gif"><img src="moving_hole_dup.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_dup_frames.gif"><img src="moving_hole_dup_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_dup_size.txt>
    ls -l moving_hole_dup.gif | awk '{printf "%d", $5}'
</CODE> -->
          By doubling the first frame the animation was now reduced from <a href="moving_hole_size.txt"><img src="moving_hole_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes down to <a href="moving_hole_dup_size.txt"><img src="moving_hole_dup_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes in size. So even though the animation now has five frames, it is now much smaller in overall size, because of the massive reduction in the size of the sub-frame image overlays. Doubling essentially separates the pixel clearing function of the dispose method, from the pixel overlaying function performed by the next frame. Both the dispose and the overlay are done as part of the same frame update by GIF animation programs, so no loss of speed or quality should be noticeable. This is a complex and tricky technique, and one that is rarely seen or understood by GIF animation designers or GIF optimization programs, but its benefits are well worth it then it is needed. However the reduction in sub-frame image sizes only lasts for a short time, as later frames having to also clear out pixel for the next frame, so the frames become large again to continue to clear out later pixels. That is, because pixel clearing always result in larger frames, never smaller. So lets try and double <i>all</i> the frames (except the last which never needs doubling) to see how that affects the final image...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole.gif  \( -clone 0--1 -set delay 0 \) \
          +delete -insert 2 -insert 1 -insert 0 \
          -layers OptimizeFrame  moving_hole_double.gif
  gif_anim_montage x2 moving_hole_double.gif moving_hole_double_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_double.gif"><img src="moving_hole_double.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_double_frames.gif"><img src="moving_hole_double_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_double_size.txt>
  ls -l moving_hole_double.gif | awk '{printf "%d", $5}'
</CODE> -->
          As you can see while we have almost twice as many frames, all the image sizes are much smaller, producing an animation that is <a href="moving_hole_double_size.txt"><img src="moving_hole_double_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes in size, a smaller result, though not nearly as big a saving as the first single frame doubling we performed. So that you can follow what is happening, the '<code><a href="../anim_basics/#background">Background</a></code>' frame is an exact duplicate of the previous frame, making no change to what is being displayed. However, it defines the area of the animation that needs to cleared before the next frame image is overlaid. The following '<code><a href="../anim_basics/#none">None</a></code>' frame then fills in the pixels that need to be changed, as well as the pixels that the previous frames disposal also cleared. In the above animation that means the pixels that was needed to shape the new hole, and well as the pixels that was used to fill-in the previous 'hole'. The result is smaller but not nearly as much, as adding extra frames does have its own cost. At least each of the added frames also does not have its own color table, or this animation would have in fact become larger, due to the size of the extra color tables! <a name="optimizeplus" id="optimizeplus"></a>
          <h3>Layer Optimize Plus <font size="-1">- Automatic frame doubling Optimization</font></h3>I am please to say that as of version 6.2.7, IM can now do frame doubling optimization automatically, as part of its normal frame optimization handling. However as adding frames to make an animation smaller is so radical a move, it was given its own separate "<code><a href="../option_link.cgi?layers">-layers</a></code>" method '<code><b>OptimizePlus</b></code>'. For example, lets get IM to do the frame doubling optimization...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole.gif  -layers OptimizePlus   moving_hole_oplus.gif
  gif_anim_montage x2 moving_hole_oplus.gif moving_hole_oplus_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_oplus.gif"><img src="moving_hole_oplus.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_oplus_frames.gif"><img src="moving_hole_oplus_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_oplus_size.txt>
  ls -l moving_hole_oplus.gif | awk '{printf "%d", $5}'
</CODE> -->
          That is, IM gave you the same result as our previous frame doubling example. Thus the GIF file is still <a href="moving_hole_oplus_size.txt"><img src="moving_hole_oplus_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes in size. However '<code>OptimizePlus</code>' will only frame double if the number of pixels in the current and next frame of the resulting animation (3 frames) is reduced, so we can let IM decide whether to frame double or not. As "<code><a href="../option_link.cgi?layers">-layers</a></code>" method '<code><a href="#optimizeplus">OptimizePlus</a></code>' adds extra frames as it creates an frame optimized GIF animation, it also will remove any unneeded or extra frames that make no change to the final animation (merging delay times as appropriate). That is, it will also do an automatic '<code><a href="#removedups">RemoveDups</a></code>' (see next). The '<code><a href="#optframe">OptimizeFrame</a></code>' method will not do this. <a name="removedups" id="removedups"></a>
          <h3>Remove Duplicate Frames <font size="-1">- merging consecutive duplicate images</font></h3>Unfortunately if you <a href="../anim_basics/#coalesce">coalesce</a>" this animation, you will also get all the extra frames that the above added.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole_oplus.gif -coalesce gif:- |\
     gif_anim_montage x2 - moving_hole_oplus_cframes.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="moving_hole_oplus_cframes.gif"><img src="moving_hole_oplus_cframes.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>To let you remove such useless duplicate frames from a coalesced animation, a '<code><b>RemoveDups</b></code>' method has been provided. This compares each frame with the next frame in the animation, and removes the first frame if they are identical (with color similarity set by the current <a href="../color_basics/#fuzz">Fuzz Factor</a>). Also to ensure that any timings in the animation are not lost, the <a href="../anim_basics/#delay">Timing Delays</a> of the two frames are also merged. For example..
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole_oplus.gif -coalesce -layers RemoveDups  gif:- |\
     gif_anim_montage - moving_hole_oplus_rmdups_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="moving_hole_oplus_rmdups_frames.gif"><img src="moving_hole_oplus_rmdups_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>And we now have our original coalesced form of the animation. For another method of removing the extra frames see the '<code><a href="#removezero">RemoveZero</a></code>' method below. <a name="splitting" id="splitting"></a>
          <h3>Splitting Frame Updates <font size="-1">- separately updating two distant changes</font></h3>As you have seen with frame doubling, by separating the 'clearing of pixels' from the overlaying of new pixels, we can reduce the overall size of a single frame overlay. However this animation still produces some very large overlays, which mostly consist of pixels that don't actually change from one frame to the next. That is, the main overlay frame is only updating two rather small areas that are quite distant from each other thereby producing a single large overlay image. Rather than trying to update both changes simultaneously while will also includiing all those the unchanged pixels in-between the two area, we instead update each area separatally. That is, we <i>split the frame update into two phases</i>, one for each of the separated areas that changed. In this case we can fill in the hole first, then create the new hole as a separate update.It does not actually matter (except with possible regard to disposals) which of the two separate changes happen in which order, but you should try to be logical about it. It may also be that one change is easier to create than another. For example, here I insert extra frames to fill in the old hole as a separate update to the 'digging' of the new hole. This is the easier intermediate frame to generate as well as the most logical ordering of actions. Of course you do not need to do this for the last frame, as that frame is just junked before the animation loops.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="middle">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole.gif \
          \( +antialias -size 100x100 -delay 0 xc:SkyBlue \
             -fill DodgerBlue -draw 'circle 50,50 15,25' \
             -fill RoyalBlue  -draw 'circle 50,50 30,25' \) \
          \( +clone \) -insert 1 \( +clone \) -insert 3  +swap \
          -set dispose background  moving_hole_split.gif
  gif_anim_montage x2 moving_hole_split.gif moving_hole_split_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="moving_hole_split.gif"><img src="moving_hole_split.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_split_frames.gif"><img src="moving_hole_split_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Remember the added intermediate frame is different from the surrounding user displayed frames (the ones with a non-zero time delay). This is not simple 'frame doubling', but the separating two distant small changes. This addition of intermediate frames is not a simple step that can be automated. Although it is possible that a smart heuristic could be developed to generate these intermediate frames, it is not always obvious what should be done, let alone if it should be done. <i>If you like to try to generate such an heuristic, please mail me.</i> So lets try a standard frame optimization after adding these extra frames...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole_split.gif \
               -layers OptimizeFrame     moving_hole_split_opt.gif
  gif_anim_montage x2 moving_hole_split_opt.gif \
                      moving_hole_split_opt_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_split_opt.gif"><img src="moving_hole_split_opt.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_split_opt_frames.gif"><img src="moving_hole_split_opt_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_split_opt_size.txt>
    ls -l moving_hole_split_opt.gif | awk '{printf "%d", $5}'
</CODE> -->
          The addition of these 'zero delay intermediate frames', allows this animation frame optimize better than the original unoptimized animation, producing a <a href="moving_hole_split_opt_size.txt"><img src="moving_hole_split_opt_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> byte animation. However for this specific case it isn't as good as using an automated <a href="#double">Frame Doubling</a> technique (See the '<a href="#optimizeplus">OptimizePlus</a>' layers method above). However adding 'zero delay intermediate frames' does not stop you from also doing that 'frame doubling' technique as well...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole_split.gif \
               -layers OptimizePlus moving_hole_split_oplus.gif
  gif_anim_montage x2 moving_hole_split_oplus.gif \
                      moving_hole_split_oplus_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="moving_hole_split_oplus.gif"><img src="moving_hole_split_oplus.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="moving_hole_split_oplus_frames.gif"><img src="moving_hole_split_oplus_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_split_oplus_size.txt>
  ls -l moving_hole_split_oplus.gif | awk '{printf "%d", $5}'
</CODE> -->
          This animation now has two extra 'zero delay intermediate frames' per frame update. The first fills in the old hole, the second clearing an area that will contain transparent pixels, before finally the pixels that should not have been cleared is restored. The result is the most optimal frame optimization possible for this specific problem animation, resulting in <a href="moving_hole_split_oplus_size.txt"><img src="moving_hole_split_oplus_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes in the final file size. That is, our 4 frame animation was made smaller, by adding 6 extra zero time delay frames! More than double the original number of frames. Weird but true! Of course it would also be nice if GIF animation programs actually recognise <a href="../anim_basics/#zero">Zero Delay Intermediate Frames</a> for what they are, namely, intermediate updates between the real frames of the animation. But even so when the updates are highly separated, and very small, the slight pause caused by the extra frames is rarely visible.<br>
          Of course, if the two separated parts of the animation are not actually related, then they do not need to be time synchronized. Another alternative is that instead of adding extra frames, to split the animation to two completely separate animations that you can displaying together on a web page. See <a href="../anim_mods/#split">Splitting up an Animation</a>. This particular animation however cannot be split up into separate time disjoint animations. First the distant changes need to be time synchronised. and second the four areas that do change, overlap in both the horizontal and vertical directions. This means a simple HTML 'table' cannot rejoin the sub-animations into a complete whole, without some type of CSS trickery. <i>Can you prove me wrong?</i> <i>FUTURE: reference to a better example of animating 'two distant objects'. in 'Animation Handling', say involving two separately moving objects.</i> <a name="removezero" id="removezero"></a>
          <h3>Remove Zero Delay Frames <font size="-1">- removing intermediate updates</font></h3>Of course sometimes you are not interested or want to remove these added intermediate frames from an animation, leaving just the frames that will actually be shown to an user for some period of time. You can't just <a href="../anim_basics/#coalesce&quot;">coalesce</a> the animation and use the '<code><a href="#removedups">RemoveDups</a></code>' method as not all 'Intermediate Frames' are similar to the surounding frames, and are thus not duplicates. However as these types of frame have a <a href="../anim_basics/#zero">Zero Time Delay</a> you can use another special "<code><a href="../option_link.cgi?layers">-layers</a></code>" method, '<code><b>RemoveZero</b></code>' which will remove any frame that has a zero time delay. This same method will also remove the frames added using <a href="#double">Frame Doubling</a> and '<code><a href="#optimizeplus">OptimizePlus</a></code>' techniques as well. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick moving_hole_split_oplus.gif -coalesce -layers RemoveZero gif:- |\
     gif_anim_montage - moving_hole_split_rmzero_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="moving_hole_split_rmzero_frames.gif"><img src="moving_hole_split_rmzero_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>Which again returns the animation back to just the user viewable frames, simplifying the animation. Of course after removing <a href="../anim_basics/#zero">Zero Delay Intermediate Frames</a>, it is very difficult to re-add them as the change information is contained is lost. Consequentially the animation may not frame optimize very well afterward. Optimization is one of the main purposes of such frames after all. <a name="frame_results" id="frame_results"></a>
          <h3>Frame Optimization Results and Summary</h3>Lets summarize our optimizations of the moving hole animation... <!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_sizes.txt>
  ( ls -l moving_hole.gif; \
    ls -l moving_hole_opt.gif; \
    ls -l moving_hole_dup.gif; \
    ls -l moving_hole_double.gif; \
    ls -l moving_hole_oplus.gif; \
    ls -l moving_hole_split_opt.gif; \
    ls -l moving_hole_split_oplus.gif; \
  ) | awk '{printf "%6s %s\n", $5, $NF}' -
</CODE> -->
          <div align="center">
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="moving_hole_sizes.txt"><img src="moving_hole_sizes.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>As you can see by using some complex frame handling, with the help of IM and some human intervention, we were able to frame optimize the 'moving hole' animation to almost half its original size, though with just under three times the number of frames of the original. Of course results can vary greatly from animation to animation, but the techniques we used for frame optimization are the same. It just needs a little care and fore-thought, which humans are good at, and computers are not.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>There is the point, that IM should not only account for the number of pixels in current set of frames being looked at, but also the overall size of the extra frame added, and perhaps the overall compression results obtained, when making the decision about how to frame optimize the image.<br>
              <br>
              On the other hand IM also does not look at the resulting savings in the number of pixels that may result, beyond the frames that are directly involved. That is, later frames sizes may also be smaller as a result of frame doubling, or the disposal method used. This is especially true when the choice is whether to use 'previous image dispose' method, which can have substantial pixel count reductions later in an animation sequence, rather than immediately in the very next frame. A good choice here often requires human input.<br>
              <br>
              As such I can make no guarantee that IM will produce the best optimization choices, for a specific animation. However it certainly gives it a good try, without the use of recursion, to make that choice. That is, only using immediate pixel counts for its decision.<br>
              <br>
              A recursive algorithm, one that makes a choice, then see what the best final size of the animation that results from that choice, (including recursive choices further along) can produce a guaranteed best optimization. However it could also be an extremely slow operator, and for a large animation could take years to make the final decision. It would also need to include <a href="#compress_opt&quot;">compression optimization</a> choices, as these could effect the final outcome. In other words, while such an algorithm could guarantee the best optimization, it does so at a heavy computational cost.<br>
              <br>
              Of course a human being with an intimate knowledge of what the animation is trying to achieve, will generally do better in complex animations, as you saw above with <a href="#splitting">splitting frame updates</a>.<br>
              <br>
              If you would like to try an create a recursive GIF optimization operator please do. I will help in any way I can. It would beat just about every other GIF optimization program on the market. Also most GIF animation developers will probably be very grateful of your efforts (money-wise).</i></font></td>
            </tr>
          </table>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="semitrans_opt" id="semitrans_opt"></a>
          <h2>Semi-Transparency Handling</h2>The GIF file format does not allow the use of semi-transparent pixels (See <a href="../formats/#boolean_trans">GIF Boolean Transparency</a>). This is a fact, and before you can properly optimize an animation, or even save it to GIF format, you need to handle any semi-transparent pixels that may be present, in a way that is suitable for the animation. By default if you don't handle these pixels, IM will use a 50% threshold to magick these pixels into either fully-transparent or fully-opaque. However that may not be the best way to handle the problem, particularly in images that contain large areas of semi-transparent pixels, such as shadow effects. For example, I wanted to create a Stargate Asgard Teleport animation that could take just about any sub-image as the object being teleported.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -channel RGBA -fill white \
          \( medical.gif -repage 100x100+34+65 -coalesce -set delay 200 \) \
          \( +clone -motion-blur 0x20+90 -blur 0x3 -colorize 100% \
                +clone -colorize 30%  +swap  -composite  -set delay 10  \) \
          \( +clone -roll +0-20 -blur 0x3 -colorize 30% \
             -motion-blur 0x15+90 -motion-blur 0x15-90 -set delay 10 \) \
          \( +clone -colorize 30% \
             -motion-blur 0x30+90 -blur 0x5 -crop +0+10\! \) \
          \( +clone -motion-blur 0x50+90 -blur 0x2 -crop +0+20\! \) \
          \( +page -size 100x100 xc:none -set delay 200 \) \
          -set dispose background -coalesce   -loop 0     teleport.miff
  gif_anim_montage teleport.miff teleport_frames.png
</samp></pre>
                </td>
              </tr>
            </table><a href="teleport_frames.png"><img src="teleport_frames.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>I purposely left the animation in the IM internal MIFF: file format as this ensures that the original image is preserved without modification, and used a PNG: file format to display the frames so that you can see all the semi-transparent pixels contained in it! This is not only important for animations with semi-transparent pixels, but also ones with lots of colors. Once the image sequence has been saves into GIF, your chances of generating a good color optimization goes from good, to difficult.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Okay I have an animation sequence. If I attempt to save this directly as GIF, IM will just threshold all those semi-transparent pixels.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff teleport_thres.gif
  gif_anim_montage teleport_thres.gif teleport_thres_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_thres.gif"><img src="teleport_thres.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_thres_frames.gif"><img src="teleport_thres_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The result doesn't really look anything like what we wanted. The default 50% transparency handling makes the animation look like a look like a shrinking 'egg'. Definitely not what I want to achieve with this animation.. If this type of transparency handling is acceptable this is the way to apply it, before continuing with your other optimizations...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -channel A -threshold 50% +channel \
                 ...do further processing now...       teleport.gif
</samp></pre>
                </td>
              </tr>
            </table>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                <!--
In fact it is this semi-transparency handling method that is incorperated into
the <A HREF="#optimize" >General Optimization Method</A>, "<CODE>-layers '<A
HREF="#optimize" >Optimize</A>' </CODE>".
-->
                An extra advantage of using the above DIY, is that you can control the threshold level. Say '<code>10%</code>' to remove almost every semi-transparent pixel present, to '<code>90%</code>' to make them all opaque.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -channel A -threshold 90% +channel teleport_thres90.gif
  gif_anim_montage teleport_thres90.gif teleport_thres90_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_thres90.gif"><img src="teleport_thres90.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_thres90_frames.gif"><img src="teleport_thres90_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>But applying a threshold for animations, like this one, is not a good solution, as it really spoils the transparency effect I am trying to achieve.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The best overall solution to preserving all the special effects in the above animation is to just <a href="../anim_mods/#flatten">Add a Solid Color Background</a>.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -bordercolor skyblue \
                  -coalesce -border 0 teleport_bgnd.gif
  gif_anim_montage teleport_bgnd.gif teleport_bgnd_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_bgnd.gif"><img src="teleport_bgnd.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_bgnd_frames.gif"><img src="teleport_bgnd_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>This removes ALL the transparency from the animation, but at the cost of only allowing the animation to work on specific background color. But if you are creating the animation for a specific web page, that may be quite acceptable. Note however for images with sharp outlines, using a dither pattern like this can produce a 'dotty' outline to the sharp edges. As such, it is not recommended for the general case. The other solution is to try and generate some pattern of transparent and opaque pixels so as to try and preserve the images semi-transparency. And for this IM offers a large range of dithering options that can solve this problem. <i>FUTURE: some link to a to be created section on transparency dithering, such as <a href="../quantize/#color_trans">Quantization and Dithering</a>.</i> Note that the obvious first solution of using a <a href="../quantize/#monochrome">Monochrome Dithering</a> of the alpha channel is not simple, probably requiring some advance <a href="../anim_mods/#composite">Multi-Image Composition</a> to do correctly.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                A simple solution is to use a <a href="../quantize/#ordered-dither">Diffused Pixel Ordered Dither</a> technique, which can be restricted to just the alpha channel, to remove the semi-transparent pixels.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -channel A -ordered-dither o8x8  teleport_od.gif
  gif_anim_montage teleport_od.gif teleport_od_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_od.gif"><img src="teleport_od.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_od_frames.gif"><img src="teleport_od_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The result is reasonable, but looks like a dissolving object than teleporting.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Using a <a href="../quantize/#halftone">Halftone</a> will produce a much nicer effect by making the transparency pattern bolder.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -channel A -ordered-dither h8x8a teleport_htone.gif
  gif_anim_montage teleport_htone.gif teleport_htone_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_htone.gif"><img src="teleport_htone.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_htone_frames.gif"><img src="teleport_htone_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                But for this specific animation, I found that using a <a href="../quantize/#thresholds_xml">User Designed Dither Map</a> to produce vertical lines (from a horizontal line dither pattern) produces an effect that enhances the teleporting animation while removing semi-transparent pixels.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick teleport.miff -rotate 90 \
          -channel A -ordered-dither hlines -rotate -90 teleport_lines.gif
  gif_anim_montage teleport_lines.gif teleport_lines_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="teleport_lines.gif"><img src="teleport_lines.gif" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="teleport_lines_frames.gif"><img src="teleport_lines_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>So as you can see there are quite a number of possibilities to handling the semi-transparency in a GIF animation.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="color_opt" id="color_opt"></a>
          <h2>Color Optimization</h2>Handling semi-transparent pixels is only the first limitation of the GIF file format. The next one is a 256 color limit for each color table in the animation. You are allowed to have a separate color table for each frame. This means a single animation can have more than 256 colors. However, even that may not always be a good idea. If you just like a quick summary of the color optimization options available, I suggest you jump to the examples on <a href="../video/#gif">Video to GIF</a> conversion where the color problems of an animation is at its worst. <a name="color_problem" id="color_problem"></a>
          <h3>GIF Color Problem</h3>GIF animations in particular have problems in handling colors, as you it first does not allow semi-transparent colors, then has a 256 color limit per frame, or a 256 global color limit. Finally your best frame optimization will not work very well unless the colors used for a pixel in one frame also match the same color, in the next frame, when that part of the image did NOT change! This may seem like an easy problem but <a href="../quantize/#intro">Color Reduction</a> is itself an extremely complex field, which required its own full section in IM Examples. Color problems are actually why most GIF animations you find on the World Wide Web are of the cartoon variety, or are very bad looking. Especially if resized from a larger version of the animation. In <a href="../anim_mods/#resize">Resizing Animations</a> will probably require more effort in color optimization, than in the actual resize process itself. Here I will assume you have the original source of the animation. But that is not always possible, so if you are optimizing a modified GIF animation, some extra caution may be needed. However if you have an animation with to many colors, the first thing you need to remember is...
          <div align="center">
            <b>Do not save directly to GIF format,<br>
            use the MIFF file format, &nbsp; OR &nbsp; separate PNG images.</b>
          </div>As soon as you save to GIF, you have lost control of your GIF color optimization efforts, and you probably have a very bad looking GIF animation that will not optimize very well using various <a href="#frame_opt">Frame Optimization</a> techniques. <a name="speed" id="speed"></a>
          <h3>Speed Animation <font size="-1">- an Animation with too many colors</font></h3>First we need to generate a GIF animation with a vast number of colors, so that we can really test out the problems involved in color optimization.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="middle">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -dispose none -channel RGBA \
          \( medical.gif -repage 100x60+5+14  -coalesce -set delay 100 \) \
          \( medical.gif -repage 100x44+34+6  -coalesce -set delay 10 \
             -motion-blur 0x12+0  -motion-blur 0x12+180 -wave -8x200 \) \
          \( medical.gif -repage 100x60+63+14 -coalesce -set delay 100 \) \
          \( medical.gif -repage 100x44+34+6  -coalesce -set delay 10 \
             -motion-blur 0x12+0  -motion-blur 0x12+180 -wave +8x200 \) \
          null: \( +page  -size 120x15 xc:SkyBlue xc:RoyalBlue \
                   -size 120x70 gradient:SkyBlue-RoyalBlue \
                   +swap -append -blur 0x3 -background white -rotate -25 \
                \) -gravity center -compose DstOver -layers Composite \
          -loop 0   speed.miff

  magick  speed.miff  speed.gif
  gif_anim_montage  speed.gif  speed_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="speed.gif"><img src="speed.gif" width="100" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="speed_frames.gif"><img src="speed_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that I did not save the animation directly to the GIF format but saved it in a MIFF format file, "<code><a href="speed.miff">speed.miff</a></code>" first. This preserves all aspects of the originally created (or modified) animation, including GIF meta-data, timing delays, as well as all the colors of the image without distortion. Only after preserving the original animation, did I directly convert the original animation to GIF format. That way I could show what the above code is meant to achieve, and why I called it 'speed'. This was done also to provide a base line GIF animation for study and later comparison. So lets look at various details of our original animation..
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="speed_nframes.txt">
  magick identify -format "Number of Frames: %n\n" speed.miff | head -1
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_nframes.txt"><img src="speed_nframes.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="speed_ncf.txt">
  magick identify -format "Colors in Frame %p: %k\n"  speed.miff
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_ncf.txt"><img src="speed_ncf.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="speed_ncolors.txt">
  magick speed.miff +append  -format "Total Number of Colors: %k"  info:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_ncolors.txt"><img src="speed_ncolors.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>As you can see, each image in the animation has a very large number of colors. Not only does each frame have a different number of colors, but the first and third frames are very similar color-wise, though not quite exactly the same. However the GIF file format can only save a maximum of 256 color per frame, the ImageMagick saved this to GIF format it did so in the fastest, and dumbest way possible... It reduced the number of colors of each frame in the animation (a process called <a href="../quantize/#colors">Color Quantization</a>)...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="speed_ncolors2.txt">
  magick identify -format "Colors in Frame %p: %k\n"  speed.gif
  magick speed.gif +append  -format "Total Number of Colors: %k"  info:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_ncolors2.txt"><img src="speed_ncolors2.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Because the reduced number of colors in each frame is slightly different, IM also needed to supply a separate colormap for each frame in the animation. This means that the GIF file has one 'Global Color Table' and it always does, but also three separate 'Local Color Tables'. The "<code>magick identify</code>" command cannot tell you how many such local color tables a GIF file has, as the information is too format specific, and not important to the image processing IM normally does. However the more specific "<code><a href="http://www.ict.griffith.edu.au/anthony/software/#giftrans">Giftrans</a></code>" program can tell you how many low level local color tables were used...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="speed_ctables.txt">
  giftrans -L speed.gif 2&gt;&amp;1 | grep -c "Local Color Table:"
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_ctables.txt"><img src="speed_ctables.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div><!-- <CODE EXECUTE ASSERT>
  [ "`cat speed_ctables.txt`" -lt 3 ] && echo >&2 \
    "ASSERTION FAILURE: Color Example had too few Local Color Tables"
</CODE> -->
          As you can see this animation has <a href="speed_ctables.txt"><img src="speed_ctables.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> local color tables, one less than the number of frames present in the image, just as I predicted. Not only does each frame have a different set of colors, but also a slightly different pattern of colors (the image dither pattern), as described in <a href="../quantize/#dither_sensitive">Problems with Error Correction Dithers</a>. Normally this default operation of IM <a href="../quantize/">Color Quantization and Dithering</a> is very good, and perfectly suited for pictures, especially real life photos. In fact the individual frames of an animation will generally look great. All the problems are when we try to later string those individually color reduced frames into an single animation sequence. <a name="color_frame_first" id="color_frame_first"></a>
          <h3>Frame Opt before Color Opt?</h3>As you saw above saving an animation directly to a GIF format, works, but you will get quite a lot of color differences from one frame to the next, which s bad for later <a href="#optframe">Frame Optimization</a> (as you will see later). To prevent color differences causing such problems you can do the <a href="#optframe">Frame Optimization</a> before saving the animation, and thus avoiding the introduced color differences from one frame to another. <!--
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover table-striped" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE _EXECUTE>
  magick speed.miff  -layers OptimizeFrame  speed_opt.gif
  gif_anim_montage  speed_opt.gif  speed_opt_frames.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="speed_opt.gif"
     ><IMG SRC="speed_opt.gif"         WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="speed_opt_frames.gif"
     ><IMG SRC="speed_opt_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see the animation was frame optimized perfectly, reducing the
overlays to just the areas that changed from one frame to the next. </P>
-->
           However be warned that doing frame optimization before color reducing however change the dynamics of the color reduction. Often less of the static unmoving areas will appear in the optimized sub-frame, which means that the color quantization for that frame can give those colors less importance, and therefor less colors. <a name="color_fuzz" id="color_fuzz"></a>
          <h3>Fuzzy Color Optimization</h3>However sometimes you don't have access to the original animation before it was saved to GIF format. This is especially true if you downloaded the original animation from the WWW. That means you already have an animation with all those GIF color distortions already present, producing problems with later optimizations. Now because a slightly different set of colors are used from one frame to the next, and a different pattern of pixels are used for each frame in the animation, each frame can be regarded as a completely different image. For example lets compare the first and third frames, which share large amount of the same background image....
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick compare  speed.gif'[0,2]' speed_compare.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="speed_compare.gif"><img src="speed_compare.gif" width="100" height="60" align="absmiddle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The red areas of the above example shows two solid square areas of the areas that are different, just as you would expect. But it also shows bands of color differences outlining the background of the two frames. These represent the 'churning' dither pattern along the edges of the background gradient where different color pixels were used to represent the exact same background. This was also the frame pair showing least background disturbances caused by using different sets of colors, and dither patterns. The actual consecutive frame differences are far worse, producing near a near solid red difference.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Image differences like this are also a problem if your source images were stored using the JPEG image format. This format uses a lossy-compression method that (even at 100% quality) causes slight color differences, in the images. However the differences are generally confined to a halo around the actual areas of difference, rather that throughout the image.<br>
              <br>
              All I can say is, avoid JPEG images for use in animations unless you plan to use one single image as a static background image for ALL your frames.</i></font></td>
            </tr>
          </table>As so many pixels in the animation are different from one frame to the next it is not surprising then that when we try to <a href="#frame_opt">Frame Optimize</a> the animation, we get no optimization at all...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick speed.gif  -layers OptimizeFrame  speed_opt2.gif
  gif_anim_montage  speed_opt2.gif  speed_opt2_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="speed_opt2_frames.gif"><img src="speed_opt2_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>However most the pixel color differences between unchanging parts of the animation frames are actually rather small. It wouldn't have been a very good <a href="../quantize/#intro">Color reduction</a>, if this wasn't the case. That means that by asking IM to relax its color comparisons a little, you can ask it to ignore minor color differences. This is done by setting an appropriate <a href="../color_basics/#fuzz">Fuzz Factor</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick speed.gif  -fuzz 5%  -layers OptimizeFrame  speed_opt3.gif
  gif_anim_montage speed_opt3.gif speed_opt3_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="speed_opt3_frames.gif"><img src="speed_opt3_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div>As you can see with the addition of a small <a href="../color_basics/#fuzz">Fuzz Factor</a>, IM will now ignore the pixels that are only slightly different, producing a reasonable <a href="#frame_opt">Frame Optimization</a>. How much of a fuzz factor you need depend on just how much trouble IM had in color reducing the original images. In this case not a lot, so only a very small factor was needed. If a small fuzz factor produces an acceptable result, then just set it for your <a href="#optframe">Frame Optimization</a> and <a href="#trans_opt">Transparency Optimization</a>. Just remember you still have a separate color table for each frame to take care of, which is the next point of discussion. Note also that the <a href="#frame_opt">Frame Optimization</a> decided to use a '<a href="../anim_basics/#previous">Previous Disposal</a> for the second frame. That is, after displaying the second frame return the image to the previous frame disposal (the first image) before overlaying. This resulted in a smaller overlay image size, than if no disposal was used thoughout. If you wanted just a simple <a href="../anim_basics/#overlay">Overlay Animation</a>, only using <a href="../anim_basics/#none">None Disposal</a> thoughout, you could have used the old <a href="../anim_basics/#deconstruct">Deconstruct</a> operator (also known as <a href="../anim_basics/#compareany">Layers CompareAny</a>) to generate it instead.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick speed.gif  -fuzz 5%  -deconstruct  speed_opt4.gif
  gif_anim_montage speed_opt4.gif speed_opt4_frames.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="speed_opt4_frames.gif"><img src="speed_opt4_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
          </div><a name="colortables" id="colortables"></a>
          <h3>Generating a Single Global Color Table</h3>Now as each and every frame has a different set of colors, IM was forced to save the image, with a separate color table for every frame: one global one for the first frame, and 3 local color tables for the later frames. For example, here I used the very simple program "<code><a href="http://www.ict.griffith.edu.au/anthony/software/#giftrans">Giftrans</a></code>" program to report how many frame color tables were created.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  giftrans -L speed.gif 2&gt;&amp;1 | grep -c "Local Color Table:"
</samp></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="speed_ctables.txt"><img src="speed_ctables.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>For a fully-coalesced (or film strip like) animation, having separate color tables for each frame is perfectly fine and reasonable, and in such situations this is not a problem. That is, for slide shows of very different images, separate color tables will produce the best looking result. As such this is the normal working behaviour of IM. All these extra color tables is however very costly as each colortable can use a lot of space. Up to 768 bytes (256 colors × 3 bytes per color or 3/4 kilobytes) for each frame in the image. Not only that, but the GIF compression does not compress these color tables, only pixel data! If having this much file space for separate color tables is a problem, especially for an image that doesn't change color a lot, as is the case with most GIF animations, then you can get IM to only use the requires global color table, and not add any local color tables. ---To remove local color maps all the image must become type palette and all use the same palette, For the command line you can do this by setting a "-map image" to define the command palette, You cannot use -colors as that works of individual images. The command line solution is a special "<code><a href="../option_link.cgi?map">+map</a></code>" option, that does a global color reduction to a common palette that is added to all images. NOTE any change to the image will likely invalidate the palette, so while color reduction should be done BEFORE you do GIF frame and/or compression optimizations, the common palette needs to be last, just before saving. If "<code><a href="../option_link.cgi?map">+map</a></code>" does not need to reduce the number of colors in an image it will not do it or dither colors, just add a common palette across all images. --- IM can generate a single global color table, if all the frames use the same color palette. In IM color palettes are only assigned to an image either by reading them in from an image format that is using such a palette, or by assigning it one using the "<code><a href="../option_link.cgi?map">-map</a></code>" color reduction operator. See <a href="../quantize/#map">Dither with Pre-defined Colormap</a> for more details. One way to generate this single color table is to simply "<code><a href="../option_link.cgi?append">-append</a></code>" all the frames together, then using the "<code><a href="../option_link.cgi?colors">-colors</a></code>" command to reduce the number of colors to a minimal set (less than 256, or smaller if you want an even smaller color table). The resulting color table can then be applied to the original image using "<code><a href="../option_link.cgi?map">-map</a></code>". For example, here reduce the image to a single set of 64 colors. This uses the special <a href="../files/#mpr">MPR in-memory register</a> to assign the generated color map to the "<code><a href="../option_link.cgi?map">-map</a></code>" command.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick speed.gif \
          \( -clone 0--1 -background none +append \
              -quantize transparent  -colors 63  -unique-colors \
             -write mpr:cmap    +delete \) \
          -map mpr:cmap      speed_cmap.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="speed_cmap.gif"><img src="speed_cmap.gif" width="100" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Now if you examine the resulting animation using "<code><a href="http://www.ict.griffith.edu.au/anthony/software/#giftrans">Giftrans</a></code>" you will find that the image now uses a single 'global' color table, rather than a separate color table for each frame.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>I use a "<code><a href="../option_link.cgi?background">-background</a></code>" color of '<code>None</code>' before appending the images together, allowing you to use this on un-coalesced animations, and not have the possibility adding extra unneeded colors.<br>
              <br>
              The special "<code><a href="../option_link.cgi?quantize">-quantize</a></code>" setting of '<code>transparent</code>' colorspace was used to ensure that IM does not attempt to generate semi-transparent colors in its colormap. An useless thing as we are saving the result to GIF which cannot handle semi-transparency.<br>
              <br>
              Finally I color reduce to 63 colors, to leave space for a transparent color. Some animations need transparency, while others (like this one) may still need it later for <a href="#compress_opt">Compression Optimization</a>.</i></font></td>
            </tr>
          </table>To make this easier, IM also provides a special option "<code><a href="../option_link.cgi?map">+map</a></code>" which will generate a common color map (of 256 colors) over all the frames, applying it globally. This is a lot simpler than the DIY method above.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick speed.miff  -alpha off +map   speed_map.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="speed_map.gif"><img src="speed_map.gif" width="100" height="60" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE NOIMAGE OUT=speed_map_ctables.txt>
  giftrans -L speed_map.gif 2>&1 | grep -c "Local Color Table:"
</CODE>
<CODE EXECUTE ASSERT>
  [ "`cat speed_map_ctables.txt`" != 0 ] && echo >&2 \
    "ASSERTION FAILURE: Map Common Palette did not remove Local Color Tables!"
</CODE> -->
          This resulted in <a href="speed_map_ctables.txt"><img src="speed_map_ctables.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> 'local' (or extra unwanted) color tables in the resulting image. I will be using the single color table version of the animation for the next optimization sections, though you could actually do this at any point in your animation optimizations and especially before the final save. <!-- <CODE EXECUTE>
  ls -l speed.gif | awk '{printf "%d", $5}' > speed_size.txt
  ls -l speed_map.gif | awk '{printf "%d", $5}' > speed_map_size.txt
</CODE> -->
          As a result of color table optimization, the animation which was <a href="speed_size.txt"><img src="speed_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes for our directly converted GIF, is now <a href="speed_map_size.txt"><img src="speed_map_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes, after using the "<code><a href="../option_link.cgi?map">+map</a></code>" operator. The more frames (and 'local color tables') an animation has, the larger the saving. Now as any modification to an animation will generally remove the saved palette for each of the images, it is important that the "<code><a href="../option_link.cgi?map">+map</a></code>" operator be the last operation before saving the animation to GIF. Remember
          <div align="center">
            <b>Removal of local color maps should be the last optimization, before saving to GIF format.</b>
          </div><a name="dithering" id="dithering"></a>
          <h3>Ordered Dither, removing the 'static'</h3>
          <div align="center">
            <font size="+2"><b><img src="../img_www/const_barrier.gif" width="39" height="35" align="top"> Under Construction <img src="../img_www/const_hole.gif" width="144" height="50" align="middle"></b></font>
          </div>Note however that in all the techniques we have looked at so far all can have a dither pattern that changes from one overlay to another. A churning of the pixels that can look like TV static.
          <pre>... small number of colors ...</pre>With a frame optimization of a smaller unmoving area, you can even get a rectangular areas of static that looks even worse. ... Ordered Dither ... For now refer to the more practical and less detailed <a href="../video/#gif">Video to GIF, Optimization Summary</a>.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="compress_opt" id="compress_opt"></a>
          <h2>Compression Optimization</h2>Once you have your animation saved into a GIF format, by handling semi-transparent pixels and using color and frame optimizations, you are also able to get some smaller file size reductions by catering to the GIF compression algorithm. The LZW compression or Run-length Compression that the GIF file format can use will compress better if it finds larger areas of constant color, or pixel sequences that repeat over and over. <a name="opttrans" id="opttrans"></a> <a name="opt_trans" id="opt_trans"></a>
          <h3>Transparency Optimization</h3>As you saw in <a href="#frame_opt">Frame Optimization</a> an overlaid image will often be just repeating what is already being displayed. That is, it is overlaying the same colored pixels that is already present after the GIF disposal methods have been applied. But why bother repeating those pixels. If you are already using transparency in an image, you have a transparent pixel color available. But converting those areas into transparency, get larger areas of uniform transparent pixels. That can compress better, than using a mix of different colors, needed to match the same area being overlaid. For example, here is a simple <a href="#frame_opt">Frame Optimized</a>, <a href="../anim_basics/#overlay">Overlay Animation</a>...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="middle">
              <td width="10%"></td>
              <td width="90%" align="center">
                <a href="../anim_basics/bunny_bgnd_frames.gif"><img src="../anim_basics/bunny_bgnd_frames.gif" align="middle" vspace="2" hspace="0" border="0" alt="[IM Output]"></a>
              </td>
              <td align="center" rowspan="3">
                <a href="../anim_basics/bunny_bgnd.gif"><img src="../anim_basics/bunny_bgnd.gif" width="120" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Lets now use the "<code><a href="../option_link.cgi?layers">-layers</a></code>", method '<code><b>OptimizeTransparency</b></code>' (Added IM v6.3.4-4) to replace any pixel that does change the displayed result with transparency.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="middle">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick bunny_bgnd.gif -layers OptimizeTransparency \
                                    +map   bunny_bgnd_opttrans.gif
  gif_anim_montage bunny_bgnd_opttrans.gif bunny_bgnd_opttrans_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="bunny_bgnd_opttrans.gif"><img src="bunny_bgnd_opttrans.gif" width="120" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td align="center">
                <a href="bunny_bgnd_opttrans_frames.gif"><img src="bunny_bgnd_opttrans_frames.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><!-- <CODE EXECUTE>
  ls -lH bunny_bgnd.gif | awk '{printf "%d", $5}' >  bunny_bgnd_size.txt
  ls -l  bunny_bgnd_opttrans.gif | awk '{printf "%d", $5}' \
                                            > bunny_bgnd_opttrans_size.txt
</CODE> -->
          As you can see the sub-frames now have large transparent areas, which do not effect the final resulting animation. Areas that need the pixels changed are still overlaid, but the areas that does not change have been made transparent. That includes within the object being animated as well, leaving rather horible looking 'holes'. As the larger constant transparent colored areas will (in theory) compress better, the resulting 'messy' animation is a lot smaller, reducing the file size from the frame optimized result of <a href="bunny_bgnd_size.txt"><img src="bunny_bgnd_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes down to <a href="bunny_bgnd_opttrans_size.txt"><img src="bunny_bgnd_opttrans_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes. This is quite a big savings for a very small effort. Note that the optimization method did not need to be a <a href="../anim_basics/#coalesced">Coalesced Animation</a>, and that the size of the sub-frames is left unchanged, so as to preserve the disposal needs of this and later frames. As such any savings is just in terms of improved compression ratios for the same number of pixels in the animation, and not in that actual number of pixels saved into the file. It should thus be done after you have completed any <a href="#frame_opt">Frame Optimization</a> needed, as one of your final optimization steps.
          <pre>FUTURE: link to a 'remove background' from animation</pre>Of course like most of the other "<code><a href="../option_link.cgi?layers">-layers</a></code>" methods (comparison or optimization) you can specify a <a href="../color_basics/#fuzz">Fuzz Factor</a> to adjust, 'how similar' colors are thought to be. That lets you handle animations that were badly color dithered, though if you had studied the <a href="#color_opt">Color Optimization</a> above you should not have that problem. The free animated GIF tool "<code><b><a href="http://utter.chaos.org.uk/~pdh/software/intergif.htm">InterGIF</a></b></code>" also provides this same type of transparency compression optimization shown above, but without the ability to also support a 'fuzz factor' to also make 'close' color changes transparent. I do not recommend it, except as an alternative when IM is not available. <a name="opt_lzw" id="opt_lzw"></a>
          <h3>LZW Optimization <font size="-1">- (non-IM)</font></h3>Some applications can further optimise the compression ratio of the images in an animation to make it them even smaller. However to do this requires a specialized knowledge of the LZW compression that the GIF image file format typically uses. Basically, if a specific sequence of pixels has already been handled by the LZW compression algorithm, it will not bother to magick them into transparent pixels as doing so will not improve the images compression. It sounds weird but it works. Unfortunately <i>ImageMagick will not do this</i>, as it is such a complex process that takes a great deal of skill and resources to get a reasonably good heuristic to produce a good result in the general case. I can however give you a practical example of this technique using the "<code><a href="http://www.lcdf.org/gifsicle/">Gifsicle</a></code>" application at its highest '<code>-O2</code>' optimization level.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  gifsicle -O2 bunny_bgnd.gif -o bunny_bgnd_lzw_gifsicle.gif
  gif_anim_montage bunny_bgnd_lzw_gifsicle.gif bunny_bgnd_lzw_frames.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="bunny_bgnd_lzw_gifsicle.gif"><img src="bunny_bgnd_lzw_gifsicle.gif" width="120" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <div align="center">
            <a href="bunny_bgnd_lzw_frames.gif"><img src="bunny_bgnd_lzw_frames.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                <!-- <CODE EXECUTE>
  ls -l bunny_bgnd_lzw_gifsicle.gif | awk '{printf "%d", $5}' \
                                     > bunny_bgnd_lzw_gifsicle_size.txt
</CODE> -->
                LZW compression optimization reduced the image from <a href="bunny_bgnd_opttrans_size.txt"><img src="bunny_bgnd_opttrans_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes with simple transparency optimization, to <a href="bunny_bgnd_lzw_gifsicle_size.txt"><img src="bunny_bgnd_lzw_gifsicle_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> bytes for "Gifsicle". Not a large improvement. The more important aspect however is that while LZW optimization converted unchanged pixel to transparency (as we did using <a href="#opt_trans">Transparency Optimization</a> above), it did not change a sequence of pixels that had already been seen. That is, only groups of pixels that have <i>not</i> already been repeated within the animation were changed, as those pixel would (presumably) already compress well using LZW compression patterns. Note that the selection of what pixels should be made transparent, to generate repeated pixel patterns, is very complex and difficult, and can even depend on the exact LZW implementation as well. It is a heuristic, not a perfectly predictable algorithm. As such different programs will generally produce different results depending on the specific image being compressed. One program may produce a better compression ratio for one image, and another may be better for a different image. <a name="opt_lzw_lossy" id="opt_lzw_lossy"></a>
                <h3>Lossy LZW Optimization <font size="-1">- (non-IM)</font></h3>Another compression improvement method involved the slight modification of the pixel colors themselves to 'close color matches' so as to increase the repetition of the color references in the image. A repeated pattern naturally compresses better, and as such can produce a higher compression ratios. A fork of the previous "Gifsicle" application, known as <a href="https://kornel.ski/lossygif">giflossy</a>, also generats a '<code>gifsicle</code>' program, but one with the option to modify the image in minor ways (it is 'lossy') to reduce the size of GIF images, especially in animation, much further.
                <table border="0" cellspacing="0" cellpadding="0" width="100%">
                  <tr valign="top">
                    <td width="100%" align="justify">
                      <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                        <tr>
                          <td>
                            <pre class="bg-light text-dark mx-4"><samp>
  gifsicle -O3 --lossy=80 bunny_bgnd.gif -o bunny_bgnd_giflossy.gif
  gif_anim_montage bunny_bgnd_giflossy.gif bunny_bgnd_lossy_frames.gif
</samp></pre>
                          </td>
                        </tr>
                      </table>
                    </td>
                    <td>
                      <a href="bunny_bgnd_giflossy.gif"><img src="bunny_bgnd_giflossy.gif" width="120" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
                    </td>
                  </tr>
                </table>
                <div align="center">
                  <a href="bunny_bgnd_lossy_frames.gif"><img src="bunny_bgnd_lossy_frames.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                </div>
                <hr>
                <footer class="magick-footer">
                  <div class="container-fluid">
                    Created: 22 March 2007 ((sub-division of "animation")<br>
                    Updated: 23 April 2007<br>
                    Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
                    Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
                    URL: <code>https://imagemagick.org/Usage/anim_opt/</code>
                  </div>
                </footer>
                <table border="0" cellspacing="0" cellpadding="0" width="100%">
                  <tr valign="bottom">
                    <td width="100%" align="justify">
                      <!-- <CODE EXECUTE>
  ls -l bunny_bgnd_giflossy.gif | awk '{printf "%d", $5}' \
                                     > bunny_bgnd_giflossy_size.txt
</CODE> -->
                      This resulted in a size of <a href="bunny_bgnd_giflossy_size.txt"><img src="bunny_bgnd_giflossy_size.txt.gif" align="absmiddle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a> , which is amazing 1/3 reduction in size. Unfortunately this method involved changing the resulting image, and as such the optimization is lossy, as it can loose subtle color information. On the plus side it allows you to compress the individual frames, rather than the frame-to-frame optimization. Here for example I generated a difference image of the previous non-lossy LWZ compression against a lossy LWZ compression.
                      <div align="center">
                        <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                          <tr>
                            <td>
                              <pre class="bg-light text-dark mx-4"><samp>
  magick compare bunny_bgnd_lossy_frames.gif bunny_bgnd_lzw_frames.gif \
          bunny_bgnd_diff_frames.gif
</samp></pre>
                            </td>
                          </tr>
                        </table><a href="bunny_bgnd_diff_frames.gif"><img src="bunny_bgnd_diff_frames.gif" align="middle" vspace="2" hspace="5" border="0" alt="[IM Output]"></a>
                      </div>As you can see almost all the color modifications was in the original 'grass' background image, rather than the cartoon bunny. Basically it slightly modified things just enough to make a huge difference, and for this image not a real noticable difference in look. Of course <a href="../quantize/">Color Quantization and Dithering</a> is itself a lossy operation and is usually needed anyway, so using a lossy compression method for GIF images, and GIF animations is not regarded as very bad.
                      <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
                        <tr valign="top">
                          <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                          <td align="justify" width="100%"><font size="-1"><i>Another example of such an algorithm that was patented for use by Photoshop see <a href="http://www.patentstorm.us/patents/7031540-fulltext.html">US Patent 7031540 - Transformation to increase the lempel-ziv compressibility of images with minimal visual distortion</a>. It is heavy reading but details the methods it uses to achieve better compression.</i></font></td>
                        </tr>
                      </table><a name="opt_lzw_dithered" id="opt_lzw_dithered"></a>
                      <h3>Ordered Dithered LZW Optimization</h3>As the dithering process is usually a more lossy process than LZW optimizations, a better solution may be to try to introduce the repeatable patterns as part of the dithering process. That can be achieved by using <a href="../quantize/#ordered-dither">Ordered Dithering</a> to produce such patterns, and thus much stronger LZW compression savings than all the previous LZW Optimization method. As a bonus it can also improve the <a href="#frame_opt">Frame Optimization</a> of real life animations with static backgrounds. That would be especially true if you artificially clean up the background so it does become a static unchanging background. Of course Ordered Dither Compression Optimization only works for images that have not previously been dithered or otherwise color optimized. As such it only works for animations that have yet to be optimized for the GIF image format. Also currently IM Ordered dither only works for an uniform color palette. IM has yet to have a 'best color' or 'user supplied' palette implementation of ordered dither, though I have seen programs that use such an algorithm for very limited (and fixed) color pallets. <i>Do you know of such an algorithm?</i> For a practical example of using ordered dither for improved LZW compression optimization, see <a href="../video/#gif_ordered_dither">Ordered Dithered Video</a>. <a name="opt_lzw_other" id="opt_lzw_other"></a>
                      <h3>Other LZW Optimization</h3>Other improvements in LZW optimization can also be achieved by other re-arragements of the 'dither pattern' in the image. And some GIF tools can do exactly that. However any such optimization should always be checked by a human eye before being approved, as sometimes a subtile but bad color changes can result.
                      <h3>Compression Optimization Summary</h3>Here is a complete summary of the final file sizes achieved using compression optimizations. <!-- <CODE EXECUTE NOIMAGE OUT=bunny_bgnd_compress_sizes.txt>
  ( ls -lH bunny_bgnd.gif; \
    ls -l  bunny_bgnd_opttrans.gif; \
    ls -l  bunny_bgnd_lzw_gifsicle.gif; \
  ) | awk '{printf "%6s %s\n", $5, $NF}' -
</CODE> -->
                      <div align="center">
                        <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
                          <tr>
                            <td>
                              <a href="bunny_bgnd_compress_sizes.txt"><img src="bunny_bgnd_compress_sizes.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                            </td>
                          </tr>
                        </table>
                      </div>As you can see only slight improvements in final animation size was achieved by using the very complex <a href="#lwz_opt">LZW Optimization</a>, over the built-in <a href="#trans_opt">Transparency Optimization</a>. However the results are also highly variable between the many GIF optimization application programs available, and the specific animation that is being optimized. If you really need to get the very last byte from a file size, then a <a href="#lwz_opt">LZW Optimization</a> may be just what you need. And if you really need the very best results, you should try a number of different programs (and thus heuristic implementations) to see which one compresses your specific animation better, including what other optimization features they provide. Typically a <a href="#trans_opt">Transparency Optimization</a> is good enough for most purposes. With <a href="#lwz_opt">LZW Optimization</a> only producing a slightly better result, producing a very minor saving for network transmission sizes, rather than disk storage size, as the latter uses larger 'chunks' or 'blocks' of storage. Because of this I feel the <a href="#lwz_opt">LZW Optimization</a>, overkill, and I don't think it is worth the effort, or the money (most of these tools are commercially sold).
                      <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
                        <tr valign="top">
                          <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
                          <td align="justify" width="100%"><font size="-1"><i>Unfortunately I have found that these GIF optimizers do not handle ALL types of pre-optimized animations very well.<br>
                          <br>
                          For example, my tests show that "<code><a href="http://www.lcdf.org/gifsicle/">Gifsicle</a></code>" fails to handle an animation that was already optimized using a 'background disposal' technique.<br>
                          <br>
                          On the other hand I found that "<code><a href="http://www.chaos.org.uk/~pdh/software/intergif.htm">InterGIF</a></code>" will not handle animations that have already been optimized to use an initial canvas and 'previous disposals' technique. It also is limited to the use of <a href="#trans_opt">Transparency Optimization</a>, which IM now provides.<br>
                          <br>
                          I thus recommend you do not mix GIF optimization utilities by feeding one utilities output into another. At least not without first coalescing the animation to remove any previous frame optimizations.<br>
                          <br>
                          IM, Gifsicle and InterGIF, all provide such coalescing options to remove their own optimizations, though I cannot guarantee the non-IM applications will coalesce ALL animations correctly. IM will.<br>
                          <br></i></font></td>
                        </tr>
                      </table>Because you can't use these programs reliably with IM's advanced <a href="#frame_opt">Frame Optimization</a> techniques (which selects and switches to using different GIF disposal techniques automatically), I have often found that IM will often produce an overall better result that just using these LZW compression optimizers. I also suggest you also <a href="../anim_basics/#coalesce">Coalesce</a> the result again afterward and compare its frames against the original un-optimized animation, to ensure that the non-IM program did not somehow stuff up the animation entirely (see note above). Believe me I have seen it happen, and scripts should double check animations remain valid.<br>
                      Another tutorial (using windows tools) about this type of optimization is <a href="http://www.webreference.com/dev/gifanim/frame.html">WebReference Frame Optimation</a>. Note that the site is mis-named as it is about compression optimization.
                      <hr>
                      <!-- ---------------------------------------------------------------- -->
                      <a name="minor_opt" id="minor_opt"></a>
                      <h2>Minor Optimizations</h2>There are a few other optimization techniques that you can use with GIF animations that are often so obvious that they are overlooked.
                      <ul>
                        <li><b>Remove GIF comments.</b><br>
                        Many GIF animations have a large text comment added. Often these were added automatically by graphical editors as a form of advertising. For example, "<code>Gimp</code>" by default adds "<code>Created with The GIMP</code>" to images. If the comment is not needed, it is a waste of space. Remove them by adding a "<code><a href="../option_link.cgi?set">+set</a> comment</code>" operator to the IM "<code>magick</code>" command before the GIF is saved. Please note however that if the comment is a copyright notice, it may not be a good idea to remove it for legal reasons.</li>
                        <li><b>Reduce the number of colors.</b><br>
                        If animation looks okay with fewer colors, use a smaller color table. The color tables are always a power of two, so if you can use less than 32 colors, that is a lot smaller than using 256 colors. This is especially magick important as color tables are not compressed by the LZW compression used for the GIF image data. Also using fewer colors will generally produce better LZW compression as more common pixel sequences are found. This is not always the case however as color dithering (due to the color reduction) can also make the compression worse. Turning of dithering or using an ordered dither can be magick important here.</li>
                        <li><b>Half the number of user visible frames.</b><br>
                        If you can handle a less smooth animation, then halving the total number frames can produce a good improvement in the final file size. Of course you don't get a file half the size, and the animation quality is reduced. But it can produce a very large file size reduction.</li>
                        <li><b>Crop/Resize the animation.</b><br>
                        A smaller image size means a smaller file size. So if you don't need a big animation, don't use a big animation. A small thumbnail to represent a larger animation or video, is often preferable in a listing that the real thing.</li>
                        <li><b>Alternative Compressions.</b><br>
                        If you do not plan to use the animation as an animation, that is you just want to store it, turn off the LZW compression, and "gzip" or "bzip2" compress the WHOLE file for storage! The result is a lot smaller, though it requires web servers to give the right 'content' and 'compression' hints to browsers for it to be directly usable by client browsers. The "<code>Apache</code>" web server, doesn't do this by default, but can be made to do so. Better still, archive the whole directory of uncompressed animations into a single file, for even better storage compression.</li>
                      </ul>If you have any other optimization ideas, please let me know.
                      <hr>
                      <!-- ---------------------------------------------------------------- -->
                      <a name="gif_links" id="gif_links"></a>
                      <h2>Other Sources of Information on GIF Optimization</h2>The above completes the various basic methods and techniques for handling animations. However to form a complete picture. You should continue into the next IM examples page, detailing techniques for handling actual problems with real <a href="../anim_mods/">Animations of Images</a>. Also many of the above techniques are demonstrated in the practical examples of <a href="../video/#gif">Video to GIF Optimization</a>. I also recommend you thoroughly read about <a href="../quantize/">Color Quantization</a>, if you are really serious about dealing with GIF animations, as color reduction is often the key to good GIF animation handling. Other useful sources for GIF Animation Optimization techniques that I have found on the WWW include...
                      <ul>
                        <li>
                          <a href="http://www.ddj.com/documents/s=2904/nam1012433888/index.html">Dr Dobb's - Optimizing GIF Animations</a>
                        </li>
                        <li>
                          <a href="http://www.webreference.com/dev/gifanim/">Optimizing Animated GIFs</a>
                        </li>
                      </ul>Mail me if you think you have a page I should list here. I will only add pages of useful content, so no guarantees about adding your link.
                    </td><!-- ---------------------------------------------------------------- -->
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </div>
      </div>
    </div>
  </main>
</body>
</html>
